# file opened: NMI.asm
   1  0000              ;==============================================================================
   2  0000              ; Project: NMI.zdsp
   3  0000              ; Main File: NMI.asm
   4  0000              ; Date: 27/07/2017 19:49:54
   5  0000              ;
   6  0000              ; Created with zDevStudio - Z80 Development Studio.
   7  0000              ;
   8  0000              ; pasmo --err --bin --public nmi.asm nmi.sys nmi.publics
   9  0000              ;
  10  0000              ;==============================================================================
  11  0000
  12  0000 ~            /* ----------------------------------------------------------------------------
  13  0000 ~            	----
  14  0000 ~            	TODO
  15  0000 ~            	----
  16  0000 ~            	* Rutinas de impresion, incorporar mas caracteres de control, como
  17  0000 ~            	  retroceso, color, etc.
  18  0000 ~            	* Corregir la rutina de tratamiento de errores.
  19  0000 ~
  20  0000 ~            	----
  21  0000 ~            	TIPS
  22  0000 ~            	----
  23  0000 ~            	To compare stuff, simply do a CP, and if the zero flag is set, A and
  24  0000 ~            	the argument were equal, else if the carry is set the argument was
  25  0000 ~            	greater, and finally, if neither is set, then A must be greater.
  26  0000 ~
  27  0000 ~            	cp val                  cp val
  28  0000 ~            	------------------      --------------
  29  0000 ~            	a==val  z       nc      nc      a>=val
  30  0000 ~            	a>val   nz      nc      c       a<val
  31  0000 ~            	a<val   nz      c       nz      a!=val
  32  0000 ~
  33  0000 ~            	Too much time working with x86 processors...
  34  0000 ~
  35  0000 ~            ---------------------------------------------------------------------------- */
  36  0000
  37  0000 ~            /* ----------------------------------------------------------------------------
  38  0000 ~            	-----
  39  0000 ~            	NOTAS
  40  0000 ~            	-----
  41  0000 ~
  42  0000 ~            	Las llamadas a traves de rst $10, rst $18 o rst $30 no funcionan si SP
  43  0000 ~            	apunta dentro de la zona paginada. Si funcionan las llamadas a traves
  44  0000 ~            	de rst $08.
  45  0000 ~            	Esto es valido para dot commands y codigo NMI, ambos en pagina 0.
  46  0000 ~            	Validado para la pagina 5 tambien.
  47  0000 ~
  48  0000 ~            	Ademas, para que la llamada rst $08 M_EXECCMD funcione en una pagina
  49  0000 ~            	distinta de la 0, es preciso que el puntero HL apunte fuera de la zona
  50  0000 ~            	paginada tambien. Modificada funcion fExecCMD. REVISAR SI ES NECESARIO
  51  0000 ~            	EN OTRAS FUNCIONES DE LA API DISTINTAS A M_EXECCMD.
  52  0000 ~
  53  0000 ~            	Las MACROS para cambiar de pagina precisan que SP apunte fuera de la
  54  0000 ~            	zona paginada.
  55  0000 ~
  56  0000 ~            	La llamada a rst $30 db $0a utiliza 4 bytes de la pila.
  57  0000 ~
  58  0000 ~            	CONTROL DE ERRORES EN LAS LLAMADAS AL SISTEMA
  59  0000 ~
  60  0000 ~            	1378 ACTIONS functions.asm:
  61  0000 ~            	Revisar llamadas a la API y systituir por funciones.
  62  0000 ~
  63  0000 ~            	-----------------------------------------------------------------------
  64  0000 ~
  65  0000 ~            	lb	label
  66  0000 ~            	db	byte variable
  67  0000 ~            	dw	word variable
  68  0000 ~
  69  0000 ~            	Ptr	pointer
  70  0000 ~            	Fn	file name
  71  0000 ~            	msg	string message
  72  0000 ~
  73  0000 ~            ---------------------------------------------------------------------------- */
  74  0000
  75  0000              ;==============================================================================
  76  0000              ; DEFINITIONS
  77  0000              ;==============================================================================
  78  0000
  79  0000              		INCLUDE "NMI.inc"
# file opened: NMI.inc
   1+ 0000              ;==============================================================================
   2+ 0000              ; Project: NMI.zdsp
   3+ 0000              ; File: NMI.inc
   4+ 0000              ; Date: 29/07/2017 10:58:43
   5+ 0000              ;
   6+ 0000              ; Created with zDevStudio - Z80 Development Studio.
   7+ 0000              ;
   8+ 0000              ;==============================================================================
   9+ 0000
  10+ 0000              ;==============================================================================
  11+ 0000              ; DEFINITIONS
  12+ 0000              ;==============================================================================
  13+ 0000
  14+ 0000              M_VERSION	MACRO
  15+ 0000 ~            		//db 'v0.0.20'
  16+ 0000 ~            		db 'v-.-.--'
  17+ 0000              		ENDM
  18+ 0000
  19+ 0000              ; -----------------------------------------------------------------------------
  20+ 0000              ; DivIDE and DivMMC paging definitions
  21+ 0000              ; -----------------------------------------------------------------------------
  22+ 0000              PAGE_START	EQU $2000
  23+ 0000              PAGE_LENGTH	EQU $1c00
  24+ 0000              RAM_PAGE	EQU $3df9		; Page number
  25+ 0000
  26+ 0000              NMI_STACK	EQU $5c00
  27+ 0000              BACKED_UP_RAM	EQU $5b00		; Size: 57 + 64 = 121
  28+ 0000
  29+ 0000              ; -----------------------------------------------------------------------------
  30+ 0000              ; max number of entries in dir, it must be multiple of 22
  31+ 0000              ; -----------------------------------------------------------------------------
  32+ 0000              		//DEFINE _POINTER4BYTES
  33+ 0000              		IFDEF _POINTER4BYTES
  34+ 0000 ~            MAXENTR		equ 322*22	// 7084
  35+ 0000              		ELSE
  36+ 0000              MAXENTR		equ 100*22 //436*22	// 9592
  37+ 0000              		ENDIF
  38+ 0000
  39+ 0000              ; -----------------------------------------------------------------------------
  40+ 0000              ; Overlay system
  41+ 0000              ; -----------------------------------------------------------------------------
  42+ 0000              SIZ_OVR		equ 693			; size of overlay buffer
  43+ 0000
  44+ 0000              ; -----------------------------------------------------------------------------
  45+ 0000              ; Colors and attributes
  46+ 0000              ; -----------------------------------------------------------------------------
  47+ 0000              BLACK		equ 0
  48+ 0000              BLUE		equ 1
  49+ 0000              RED		equ 2
  50+ 0000              MAGENTA		equ 3
  51+ 0000              GREEN		equ 4
  52+ 0000              CYAN		equ 5
  53+ 0000              YELLOW		equ 6
  54+ 0000              WHITE		equ 7
  55+ 0000
  56+ 0000              BRIGHT		equ $40
  57+ 0000              FLASH		equ $80
  58+ 0000
  59+ 0000              ; -----------------------------------------------------------------------------
  60+ 0000              ; Key table
  61+ 0000              ; -----------------------------------------------------------------------------
  62+ 0000              K_EDIT		equ $07
  63+ 0000              K_LEFT		equ $08
  64+ 0000              K_RIGHT		equ $09
  65+ 0000              K_DOWN		equ $0a
  66+ 0000              K_UP		equ $0b
  67+ 0000              K_DELETE	equ $0c
  68+ 0000              K_ENTER		equ $0d
  69+ 0000
  70+ 0000              K_AT		equ $ac			; SS+I
  71+ 0000              K_TO		equ $cc			; SS+F
  72+ 0000              K_MERGE		equ $d5			; SS+T
  73+ 0000
  74+ 0000              ; no mapping on speccy BASIC
  75+ 0000
  76+ 0000              K_BREAK		equ $1c
  77+ 0000
  78+ 0000              K_SS_ENTER	equ $1d
  79+ 0000
  80+ 0000              K_CS_ENTER	equ $1e
  81+ 0000
  82+ 0000              ; -----------------------------------------------------------------------------
  83+ 0000              ; Colors used in GUI
  84+ 0000              ; -----------------------------------------------------------------------------
  85+ 0000              COL_MID		equ BLACK*8+WHITE	; black paper, white ink
  86+ 0000              COL_TOP		equ WHITE*8+BLACK	; white paper, black ink
  87+ 0000              COL_BOT		equ WHITE*8+BLACK	; white paper, black ink
  88+ 0000              COL_CUR		equ BRIGHT+BLUE*8+WHITE	; blue paper, bright white ink
  89+ 0000              COL_ERR		equ BRIGHT+RED*8+WHITE	; red paper, bright white ink
  90+ 0000
  91+ 0000              ;==============================================================================
  92+ 0000              ; MACROS
  93+ 0000              ;==============================================================================
  94+ 0000
  95+ 0000              ; -----------------------------------------------------------------------------
  96+ 0000              ; MACRO	CHECK_VERSION
  97+ 0000              ; Return esxDOS version into register a
  98+ 0000              ;
  99+ 0000              ; v0.8.5-DivIDE   $00b8 (184)
 100+ 0000              ; v0.8.5-DivMMC   $00b8 (184)
 101+ 0000              ; v0.8.6-DivIDE   $00a8 (168)
 102+ 0000              ; v0.8.6-DivMMC   $00a8 (168)
 103+ 0000              ; v0.8.7-DivIDE   $00a7 (167)
 104+ 0000              ; v0.8.7-DivMMC   $00a7 (167)
 105+ 0000              ; v0.8.8-DivIDE   $00a8 (168)
 106+ 0000              ; v0.8.8-DivMMC   $00a8 (168)
 107+ 0000              ; v0.8.9-DivIDE   $00a8 (168)
 108+ 0000              ; v0.8.9-DivMMC   $00a8 (168)
 109+ 0000              ; -----------------------------------------------------------------------------
 110+ 0000
 111+ 0000              		MACRO CHECK_VERSION
 112+ 0000 ~
 113+ 0000 ~            		ld hl, $00b8+1
 114+ 0000 ~            		ld a, '0'
 115+ 0000 ~            		cp (hl)
 116+ 0000 ~            		jr nz, notV085
 117+ 0000 ~            		inc hl
 118+ 0000 ~            		inc hl
 119+ 0000 ~            		ld a, '8'
 120+ 0000 ~            		cp (hl)
 121+ 0000 ~            		jr nz, notV085
 122+ 0000 ~            		inc hl
 123+ 0000 ~            		inc hl
 124+ 0000 ~            		ld a, '5'
 125+ 0000 ~            		cp (hl)
 126+ 0000 ~            		jr z, ver085
 127+ 0000 ~
 128+ 0000 ~            notV085		ld hl, $00a7+1
 129+ 0000 ~            		ld a, '0'
 130+ 0000 ~            		cp (hl)
 131+ 0000 ~            		jr nz, notV087
 132+ 0000 ~            		inc hl
 133+ 0000 ~            		inc hl
 134+ 0000 ~            		ld a, '8'
 135+ 0000 ~            		cp (hl)
 136+ 0000 ~            		jr nz, notV087
 137+ 0000 ~            		inc hl
 138+ 0000 ~            		inc hl
 139+ 0000 ~            		ld a, '7'
 140+ 0000 ~            		cp (hl)
 141+ 0000 ~            		jr z, ver087
 142+ 0000 ~
 143+ 0000 ~            notV087		ld hl, $00a8+1
 144+ 0000 ~            		ld a, '0'
 145+ 0000 ~            		cp (hl)
 146+ 0000 ~            		jr nz, notV086
 147+ 0000 ~            		inc hl
 148+ 0000 ~            		inc hl
 149+ 0000 ~            		ld a, '8'
 150+ 0000 ~            		cp (hl)
 151+ 0000 ~            		jr nz, notV086
 152+ 0000 ~            		inc hl
 153+ 0000 ~            		inc hl
 154+ 0000 ~            		ld a, '6'
 155+ 0000 ~            		cp (hl)
 156+ 0000 ~            		jr z, ver086
 157+ 0000 ~            		ld a, '8'
 158+ 0000 ~            		cp (hl)
 159+ 0000 ~            		jr z, ver088
 160+ 0000 ~            		ld a, '9'
 161+ 0000 ~            		cp (hl)
 162+ 0000 ~            		jr z, ver089
 163+ 0000 ~
 164+ 0000 ~            notV086		xor a
 165+ 0000 ~            ver085
 166+ 0000 ~            ver087
 167+ 0000 ~            ver086
 168+ 0000 ~            ver088
 169+ 0000 ~            ver089
 170+ 0000              		ENDM
 171+ 0000
 172+ 0000              ;==============================================================================
 173+ 0000              ; MACROS TO WORK WITH DIVXXX PAGES AND ESXDOS
 174+ 0000              ;==============================================================================
 175+ 0000
 176+ 0000              ; -----------------------------------------------------------------------------
 177+ 0000              ; MACRO	INITPG numPg
 178+ 0000              ; Initialize page numPg writing numPg at RAM_PAGE
 179+ 0000              ;
 180+ 0000              ; $05e5	out ($e3), a	; d3 e3		; return to page a
 181+ 0000              ;	ret		; c9
 182+ 0000              ;
 183+ 0000              ; $0721	ld (hl), a	; 77
 184+ 0000              ;	or a		; b7
 185+ 0000              ;	ret		; c9
 186+ 0000              ;
 187+ 0000              ; $0dea	ld a, 0		; 3e 00
 188+ 0000              ;	out ($e3), a	; d3 e3		; return to page 0
 189+ 0000              ;	ld a, b		; 78
 190+ 0000              ;	ret		; c9
 191+ 0000
 192+ 0000              ; -----------------------------------------------------------------------------
 193+ 0000
 194+ 0000              		MACRO	INITPG numPg
 195+ 0000 ~
 196+ 0000 ~            		ld	a, numPg
 197+ 0000 ~            .InitPagesL1	cp	6
 198+ 0000 ~            		jr	c, .InitPagesL2		; end if a < 6
 199+ 0000 ~
 200+ 0000 ~            		dec	a
 201+ 0000 ~            		ld	b, a
 202+ 0000 ~
 203+ 0000 ~            		ld	hl, .InitPagesL1
 204+ 0000 ~            		push	hl
 205+ 0000 ~            		ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; return to page 0
 206+ 0000 ~            		push	hl
 207+ 0000 ~            		ld	hl, $0721		; ld (hl), a; or a; ret; mark page a
 208+ 0000 ~            		push	hl
 209+ 0000 ~            		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 210+ 0000 ~            		push	hl
 211+ 0000 ~            		ld	hl, RAM_PAGE
 212+ 0000 ~            		ret
 213+ 0000 ~            .InitPagesL2
 214+ 0000 ~
 215+ 0000              		ENDM
 216+ 0000
 217+ 0000              ; -----------------------------------------------------------------------------
 218+ 0000              ; MACRO LOADPG pgNum, offset, file
 219+ 0000              ; LOAD 7168 bytes of code from file into page pgNum at address offset
 220+ 0000              ;
 221+ 0000              ; $05e5	out ($e3), a	; d3 e3		; return to page a
 222+ 0000              ;	ret		; c9
 223+ 0000              ;
 224+ 0000              ; $0dd9	ld a, b		; 78
 225+ 0000              ;	push bc		; c5
 226+ 0000              ;	ld hl, $2000	; 21 00 20	; START OF PAGE
 227+ 0000              ;	ld bc, $1c00	; 01 00 1c	; 7168 bytes (7K)
 228+ 0000              ; 	rst $08		; cf
 229+ 0000              ;	db $9d		; 9d		; F_READ
 230+ 0000              ;	pop bc		; c1
 231+ 0000              ;	push af		; f5
 232+ 0000              ;	ld a, b		; 78
 233+ 0000              ;	rst $08		; cf
 234+ 0000              ;	db $9b		; 9b		; F_CLOSE
 235+ 0000              ;	pop af		; f1
 236+ 0000              ;	ld b, a		; 47
 237+ 0000              ; $0dea	ld a, 0		; 3e 00
 238+ 0000              ;	out ($e3), a	; d3 e3		; return to page 0
 239+ 0000              ;	ld a, b		; 78
 240+ 0000              ;	ret		; c9
 241+ 0000              ; -----------------------------------------------------------------------------
 242+ 0000
 243+ 0000              		MACRO	LOADPG pgNum, offset, file
 244+ 0000 ~
 245+ 0000 ~            		ld	hl, .LoadPageL1
 246+ 0000 ~            		push	hl
 247+ 0000 ~
 248+ 0000 ~            		ld	hl, file
 249+ 0000 ~            		ld	b, FA_OPEN_EX|FA_READ
 250+ 0000 ~            		ld	a, SYS_DRIVE
 251+ 0000 ~            		rst	$08
 252+ 0000 ~            		db	F_OPEN
 253+ 0000 ~
 254+ 0000 ~            		ld	b, a			; a = HANDLE
 255+ 0000 ~            		push	bc
 256+ 0000 ~            		ld	bc, 0
 257+ 0000 ~            		ld	de, offset
 258+ 0000 ~            		ld	l, 0			; 0 from start of file
 259+ 0000 ~            		rst	$08
 260+ 0000 ~            		db	F_SEEK
 261+ 0000 ~            		pop	bc			; b = HANDLE
 262+ 0000 ~
 263+ 0000 ~            		ld	hl, $0dd9		; ld a, b; push bc; ld hl, $2000; ld bc, $1c00; rst $08; db F_READ; pop bc; push af; ld a, b; rst $08; db F_CLOSE; popaf; ld b, a; ld a, 0; out ($e3), a; ld a, b; ret
 264+ 0000 ~            		push	hl
 265+ 0000 ~
 266+ 0000 ~            		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 267+ 0000 ~            		push	hl
 268+ 0000 ~            		ld	a, pgNum
 269+ 0000 ~            		ret
 270+ 0000 ~            .LoadPageL1
 271+ 0000              		ENDM
 272+ 0000
 273+ 0000              ; -----------------------------------------------------------------------------
 274+ 0000              ; MACRO CALLPG pgNum, addr
 275+ 0000              ; CALL to address addr on page pgNum
 276+ 0000              ;
 277+ 0000              ; $05e5	out ($e3), a	; d3 e3		; return to page a
 278+ 0000              ;	ret		; c9
 279+ 0000              ;
 280+ 0000              ; $0dea	ld a, 0		; 3e 00
 281+ 0000              ;	out ($e3), a	; d3 e3		; return to page 0
 282+ 0000              ;	ld a, b		; 78
 283+ 0000              ;	ret		; c9
 284+ 0000              ; -----------------------------------------------------------------------------
 285+ 0000
 286+ 0000              		MACRO	JUMPPG pgNum, addr
 287+ 0000 ~
 288+ 0000 ~            		//ld	hl, .RunPgL1
 289+ 0000 ~            		//push	hl
 290+ 0000 ~            		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 291+ 0000 ~            		//push	hl
 292+ 0000 ~            		ld	hl, addr
 293+ 0000 ~            		push	hl
 294+ 0000 ~            		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 295+ 0000 ~            		push	hl
 296+ 0000 ~            		ld	a, pgNum
 297+ 0000 ~            		ret
 298+ 0000 ~            //.RunPgL1
 299+ 0000              		ENDM
 300+ 0000
 301+ 0000              ; -----------------------------------------------------------------------------
 302+ 0000              ; MACRO	RETPG0
 303+ 0000              ; RETURN to page 0 address on stack
 304+ 0000              ;
 305+ 0000              ; $0dea	ld a, 0		; 3e 00
 306+ 0000              ;	out ($e3), a	; d3 e3		; return to page 0
 307+ 0000              ;	ld a, b		; 78
 308+ 0000              ;	ret		; c9
 309+ 0000              ; -----------------------------------------------------------------------------
 310+ 0000
 311+ 0000              		//MACRO	RETPG0
 312+ 0000
 313+ 0000              		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; return to page 0
 314+ 0000              		//push	hl
 315+ 0000              		//ret
 316+ 0000
 317+ 0000              		//ENDM
 318+ 0000
 319+ 0000
# file closed: NMI.inc
  80  0000              		INCLUDE "../esxdos.inc"
# file opened: ../esxdos.inc
   1+ 0000              HOOK_BASE	equ 128			; 80
   2+ 0000              MISC_BASE	equ HOOK_BASE+8		; 88
   3+ 0000              FSYS_BASE	equ MISC_BASE+16	; 98
   4+ 0000
   5+ 0000              DISK_STATUS	equ HOOK_BASE+0		; 80 (128)      ; hookcodes for block devices
   6+ 0000              DISK_READ	equ HOOK_BASE+1
   7+ 0000              DISK_WRITE	equ HOOK_BASE+2
   8+ 0000              DISK_IOCTL	equ HOOK_BASE+3
   9+ 0000              DISK_INFO	equ HOOK_BASE+4
  10+ 0000
  11+ 0000              M_DOSVERSION	equ MISC_BASE+0		; 88 (136)
  12+ 0000              M_GETSETDRV	equ MISC_BASE+1		; 89
  13+ 0000              M_DRIVEINFO	equ MISC_BASE+2		; 8A
  14+ 0000              M_TAPEIN	equ MISC_BASE+3		; 8B (139)
  15+ 0000              M_TAPEOUT	equ MISC_BASE+4		; 8C
  16+ 0000              M_GETHANDLE	equ MISC_BASE+5		; 8D
  17+ 0000              M_GETDATE	equ MISC_BASE+6		; 8E
  18+ 0000              M_EXECCMD	equ MISC_BASE+7		; 8F (143)
  19+ 0000              M_AUTOLOAD	equ MISC_BASE+8		; 90 (144)
  20+ 0000
  21+ 0000              F_MOUNT		equ FSYS_BASE+0		; 98 (152)
  22+ 0000              F_UMOUNT	equ FSYS_BASE+1		; 99
  23+ 0000              F_OPEN		equ FSYS_BASE+2		; 9A
  24+ 0000              F_CLOSE		equ FSYS_BASE+3		; 9B
  25+ 0000              F_SYNC		equ FSYS_BASE+4		; 9C
  26+ 0000              F_READ		equ FSYS_BASE+5		; 9D
  27+ 0000              F_WRITE		equ FSYS_BASE+6		; 9E
  28+ 0000              F_SEEK		equ FSYS_BASE+7		; 9F
  29+ 0000              F_FGETPOS	equ FSYS_BASE+8		; A0
  30+ 0000              F_FSTAT		equ FSYS_BASE+9		; A1
  31+ 0000              F_FTRUNCATE	equ FSYS_BASE+10	; A2
  32+ 0000              F_OPENDIR	equ FSYS_BASE+11	; A3
  33+ 0000              F_READDIR	equ FSYS_BASE+12	; A4
  34+ 0000              F_TELLDIR	equ FSYS_BASE+13	; A5
  35+ 0000              F_SEEKDIR	equ FSYS_BASE+14	; A6
  36+ 0000              F_REWINDDIR	equ FSYS_BASE+15	; A7
  37+ 0000              F_GETCWD	equ FSYS_BASE+16	; A8
  38+ 0000              F_CHDIR		equ FSYS_BASE+17	; A9
  39+ 0000              F_MKDIR		equ FSYS_BASE+18	; AA
  40+ 0000              F_RMDIR		equ FSYS_BASE+19	; AB
  41+ 0000              F_STAT		equ FSYS_BASE+20	; AC
  42+ 0000              F_UNLINK	equ FSYS_BASE+21	; AD
  43+ 0000              F_TRUNCATE	equ FSYS_BASE+22	; AE
  44+ 0000              F_CHMOD		equ FSYS_BASE+23	; AF
  45+ 0000              F_RENAME	equ FSYS_BASE+24	; B0 (176)
  46+ 0000              F_GETFREE	equ FSYS_BASE+25	; B1
  47+ 0000
  48+ 0000              FA_READ		equ %00000001		; Read access
  49+ 0000              FA_WRITE	equ %00000010		; Write access
  50+ 0000
  51+ 0000              FA_OPEN_EX	equ %00000000		; Open if exists, else error
  52+ 0000              FA_OPEN_AL	equ %00001000		; Open if exists, if not create
  53+ 0000
  54+ 0000              FA_CREATE_NEW	equ %00000100		; Create if not exists, if exists error
  55+ 0000              FA_CREATE_AL	equ %00001100		; Create if not exists, else open and truncate
  56+ 0000
  57+ 0000              FA_USE_HEADER	equ %01000000		; Use +3DOS header (passed in DE)
  58+ 0000
  59+ 0000              ; NMI stuff
  60+ 0000              SYS_DRIVE	equ "$"			; expect /tmp, /sys, etc dirs only on sys drive, so use "$"
  61+ 0000              ;NMI_OVERLAY	equ $3000		; NMI.SYS is loaded here up to $0d00 bytes
  62+ 0000              NMI_OVERLAY	equ $2f00		; NMI.SYS is loaded here up to $0e00 bytes
  63+ 0000              NMI_SIZE	equ $0e00
  64+ 0000
  65+ 0000              A_WRITE		equ %00000001
  66+ 0000              A_READ		equ %10000000
  67+ 0000              A_RDWR		equ %10000001
  68+ 0000              A_HIDDEN	equ %00000010
  69+ 0000              A_SYSTEM	equ %00000100
  70+ 0000              A_ARCH		equ %00100000
  71+ 0000              A_EXEC		equ %01000000
  72+ 0000              A_ALL		equ %11100111
  73+ 0000
  74+ 0000              ; -----------------------------------------------------------------------------
  75+ 0000              ; directory attribute (missing from esxdos.inc)
  76+ 0000              ; -----------------------------------------------------------------------------
  77+ 0000              A_DIR		equ %00010000
  78+ 0000
  79+ 0000              ; -----------------------------------------------------------------------------
  80+ 0000              ; current drive (missing from esxdos.inc)
  81+ 0000              ; -----------------------------------------------------------------------------
  82+ 0000              CUR_DRIVE	equ '*'
  83+ 0000
  84+ 0000
# file closed: ../esxdos.inc
  81  0000              		INCLUDE "../errors.inc"
# file opened: ../errors.inc
   1+ 0000              EOK		equ 1			; O.K. ESXDOS
   2+ 0000              ENONSENSE	equ 2			; Nonsense in ESXDOS
   3+ 0000              ESTEND		equ 3			; Statement END error
   4+ 0000              EWRTYPE		equ 4			; Wrong file TYPE
   5+ 0000              ENOENT		equ 5			; No such FILE or DIR
   6+ 0000              EIO		equ 6			; I/O ERROR
   7+ 0000              EINVAL		equ 7			; Invalid FILENAME
   8+ 0000              EACCES		equ 8			; Access DENIED
   9+ 0000              ENOSPC		equ 9			; Drive FULL
  10+ 0000              ENXIO		equ 10			; Invalid I/O REQUEST   ; Request beyond the limits of the device
  11+ 0000              ENODRV		equ 11			; No such DRIVE
  12+ 0000              ENFILE		equ 12			; Too many OPEN FILES
  13+ 0000              EBADF		equ 13			; Bad file DESCRIPTOR
  14+ 0000              ENODEV		equ 14			; No such DEVICE
  15+ 0000              EOVERFLOW	equ 15			; File pointer OVERFLOW
  16+ 0000              EISDIR		equ 16			; Is a DIRECTORY
  17+ 0000              ENOTDIR		equ 17			; Not a DIRECTORY
  18+ 0000              EEXIST		equ 18			; File already EXISTS
  19+ 0000              EPATH		equ 19			; Invalid PATH
  20+ 0000              ENOSYS		equ 20			; No SYS
  21+ 0000              ENAMETOOLONG	equ 21			; Path too LONG
  22+ 0000              ENOCMD		equ 22			; No such COMMAND
  23+ 0000              EINUSE		equ 23			; File in USE
  24+ 0000              ERDONLY		equ 24			; File is READ ONLY
  25+ 0000              EVERIFY		equ 25			; Verify FAILED
  26+ 0000              ELOADKO		equ 26			; Loading .KO FAILED
  27+ 0000              ENOTEMPTY	equ 27			; Directory NOT EMPTY
  28+ 0000              EMAPRAM		equ 28			; MAPRAM is ACTIVE
  29+ 0000
  30+ 0000              EDRVBUSY	equ 29			; Drive is BUSY
  31+ 0000              EFILESYS	equ 30			; Unknown FILESYSTEM
  32+ 0000              EDEVBUSY	equ 31			; Device is BUSY
  33+ 0000
  34+ 0000              EEOC		equ 128			; End of cluster chain
  35+ 0000              EEOF		equ 129			; End of file
  36+ 0000
# file closed: ../errors.inc
  82  0000
  83  0000              ;==============================================================================
  84  0000              ; LOADER - PAGE 0
  85  0000              ;==============================================================================
  86  0000
  87  0000              		DEFINE DivXXXPg 0
  88  0000              		org NMI_OVERLAY
  89  2F00
  90  2F00              pg0start	MODULE initNMI
  91  2F00
  92  2F00              		INCLUDE "loader.asm"
# file opened: loader.asm
   1+ 2F00              ;==============================================================================
   2+ 2F00              ; Project: NMI.zdsp
   3+ 2F00              ; File: loader.asm
   4+ 2F00              ; Date: 18/10/2022 13:32:34
   5+ 2F00              ;
   6+ 2F00              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2F00              ;
   8+ 2F00              ;==============================================================================
   9+ 2F00
  10+ 2F00              ; ==============================================================================
  11+ 2F00              ; LOADER - divXXX page 0
  12+ 2F00              ; ==============================================================================
  13+ 2F00
  14+ 2F00 ED 73 E8 30  		ld (dwSavedSP), sp
  15+ 2F04 22 EF 30     		ld (dwPtrNMIbuf), hl
  16+ 2F07
  17+ 2F07              		; -------------------
  18+ 2F07              		; save screen to disk
  19+ 2F07              		; -------------------
  20+ 2F07              		;
  21+ 2F07 AF           lbSaveScreen	xor a
  22+ 2F08 32 ED 30     		ld (dbSavRAM), a
  23+ 2F0B
  24+ 2F0B 18 0A        		jr lbSkipErr		// ERROR J, P y S. Al estar en pagina 5 no va rst $30.
  25+ 2F0D
  26+ 2F0D 21 00 40     		ld hl, 16384
  27+ 2F10 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  28+ 2F13 F7           		rst $30
  29+ 2F14 0A           		db $0a
  30+ 2F15 30 21        		jr nc, lbChkFirstTime
  31+ 2F17
  32+ 2F17 3E FF        lbSkipErr	ld a, $ff
  33+ 2F19 32 ED 30     		ld (dbSavRAM), a
  34+ 2F1C
  35+ 2F1C 21 00 31     		ld hl, dbFnBackupFile	; asciiz string containing path and/or filename
  36+ 2F1F 06 0E        		ld b, FA_CREATE_AL|FA_WRITE
  37+ 2F21              					; create if not exists, else open and truncate
  38+ 2F21              					; write access
  39+ 2F21 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  40+ 2F23 CF           		rst $08			; screen is saved allways in SYS_DRIVE
  41+ 2F24 9A           		db F_OPEN		; open file
  42+ 2F25              		;jp c, printError1
  43+ 2F25 32 F2 30     		ld (dbFileHandle), a	; file handle
  44+ 2F28
  45+ 2F28 21 00 40     		ld hl, 16384		; source
  46+ 2F2B 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  47+ 2F2E 3A F2 30     		ld a, (dbFileHandle)	; file handle
  48+ 2F31 CF           		rst $08			;
  49+ 2F32 9E           		db F_WRITE		; write buffer to file
  50+ 2F33              		;jr c, closeFilePrintError1
  51+ 2F33
  52+ 2F33 3A F2 30     		ld a, (dbFileHandle)	; file handle
  53+ 2F36 CF           		rst $08			;
  54+ 2F37 9B           		db F_CLOSE		; close file
  55+ 2F38              		;jr c, printError1
  56+ 2F38              		; -------------------
  57+ 2F38
  58+ 2F38 3A F1 30     lbChkFirstTime	ld a, (dbFirstTime)
  59+ 2F3B B7           		or a
  60+ 2F3C CA 41 30     		jp z, lbStart
  61+ 2F3F
  62+ 2F3F              		CHECK_VERSION
  62+ 2F3F             >
  62+ 2F3F 21 B9 00    >		ld hl, $00b8+1
  62+ 2F42 3E 30       >		ld a, '0'
  62+ 2F44 BE          >		cp (hl)
  62+ 2F45 20 0E       >		jr nz, notV085
  62+ 2F47 23          >		inc hl
  62+ 2F48 23          >		inc hl
  62+ 2F49 3E 38       >		ld a, '8'
  62+ 2F4B BE          >		cp (hl)
  62+ 2F4C 20 07       >		jr nz, notV085
  62+ 2F4E 23          >		inc hl
  62+ 2F4F 23          >		inc hl
  62+ 2F50 3E 35       >		ld a, '5'
  62+ 2F52 BE          >		cp (hl)
  62+ 2F53 28 37       >		jr z, ver085
  62+ 2F55             >
  62+ 2F55 21 A8 00    >notV085		ld hl, $00a7+1
  62+ 2F58 3E 30       >		ld a, '0'
  62+ 2F5A BE          >		cp (hl)
  62+ 2F5B 20 0E       >		jr nz, notV087
  62+ 2F5D 23          >		inc hl
  62+ 2F5E 23          >		inc hl
  62+ 2F5F 3E 38       >		ld a, '8'
  62+ 2F61 BE          >		cp (hl)
  62+ 2F62 20 07       >		jr nz, notV087
  62+ 2F64 23          >		inc hl
  62+ 2F65 23          >		inc hl
  62+ 2F66 3E 37       >		ld a, '7'
  62+ 2F68 BE          >		cp (hl)
  62+ 2F69 28 21       >		jr z, ver087
  62+ 2F6B             >
  62+ 2F6B 21 A9 00    >notV087		ld hl, $00a8+1
  62+ 2F6E 3E 30       >		ld a, '0'
  62+ 2F70 BE          >		cp (hl)
  62+ 2F71 20 18       >		jr nz, notV086
  62+ 2F73 23          >		inc hl
  62+ 2F74 23          >		inc hl
  62+ 2F75 3E 38       >		ld a, '8'
  62+ 2F77 BE          >		cp (hl)
  62+ 2F78 20 11       >		jr nz, notV086
  62+ 2F7A 23          >		inc hl
  62+ 2F7B 23          >		inc hl
  62+ 2F7C 3E 36       >		ld a, '6'
  62+ 2F7E BE          >		cp (hl)
  62+ 2F7F 28 0B       >		jr z, ver086
  62+ 2F81 3E 38       >		ld a, '8'
  62+ 2F83 BE          >		cp (hl)
  62+ 2F84 28 06       >		jr z, ver088
  62+ 2F86 3E 39       >		ld a, '9'
  62+ 2F88 BE          >		cp (hl)
  62+ 2F89 28 01       >		jr z, ver089
  62+ 2F8B             >
  62+ 2F8B AF          >notV086		xor a
  62+ 2F8C             >ver085
  62+ 2F8C             >ver087
  62+ 2F8C             >ver086
  62+ 2F8C             >ver088
  62+ 2F8C             >ver089
  63+ 2F8C 21 63 31     		ld hl, msgUnkVer
  64+ 2F8F B7           		or a
  65+ 2F90 CA 9C 30     		jp z, lbPrtErr			; unknown version
  66+ 2F93 32 EE 30     		ld (dbEsxDOSv), a
  67+ 2F96
  68+ 2F96              		;
  69+ 2F96              		; Obtain speccy RAM size
  70+ 2F96              		;
  71+ 2F96              		; Version       RAM SIZE        PC      RAM pg act      TR-DOS
  72+ 2F96              		; 0.8.5         +30             +27     +29             +30
  73+ 2F96              		; 0.8.6+        +27             +28     +30             +31
  74+ 2F96              		;
  75+ 2F96 2A EF 30     		ld hl, (dwPtrNMIbuf)
  76+ 2F99 11 1E 00     		ld de, 30
  77+ 2F9C 3A EE 30     		ld a, (dbEsxDOSv)
  78+ 2F9F FE 35        		cp '5'
  79+ 2FA1 28 03        		jr z, lbRAMsize
  80+ 2FA3 11 1B 00     		ld de, 27
  81+ 2FA6 19           lbRAMsize		add hl, de
  82+ 2FA7 7E           		ld a, (hl)
  83+ 2FA8 32 EC 30     		ld (dbSpeccyRAM), a
  84+ 2FAB
  85+ 2FAB              		;
  86+ 2FAB              		; Obtain divXXX RAM size
  87+ 2FAB              		;
  88+ 2FAB 21 B1 30     		ld hl, lbTest
  89+ 2FAE 11 00 5B     		ld de, BACKED_UP_RAM
  90+ 2FB1 01 37 00     		ld bc, lbTestLen
  91+ 2FB4 ED B0        		ldir
  92+ 2FB6
  93+ 2FB6 CD 00 5B     		call BACKED_UP_RAM			; e=l=number of 8k pages
  94+ 2FB9 22 EA 30     		ld (dwDivRAM), hl
  95+ 2FBC
  96+ 2FBC 3A EE 30     		ld a, (dbEsxDOSv)
  97+ 2FBF 21 3F 31     		ld hl, msgErrVer
  98+ 2FC2 BF FE 39     		cp a, '9'			; minimum version supported
  99+ 2FC5 C2 9C 30     		jp nz, lbPrtErr
 100+ 2FC8
 101+ 2FC8 3A EA 30     		ld a, (dwDivRAM)
 102+ 2FCB 21 12 31     		ld hl, msgErrRAM
 103+ 2FCE FE 06        		cp 6				; minimum divRAM supported
 104+ 2FD0 DA 9C 30     		jp c, lbPrtErr
 105+ 2FD3
 106+ 2FD3              		//
 107+ 2FD3              		// Initialize RAM pages and load page 5 with NMI navigator
 108+ 2FD3              		//
 109+ 2FD3 31 00 5C     		ld sp, NMI_STACK		; necessary to use MACROS
 110+ 2FD6              		INITPG (dwDivRAM)
 110+ 2FD6             >
 110+ 2FD6 3A EA 30    >		ld	a, (dwDivRAM)
 110+ 2FD9 FE 06       >.InitPagesL1	cp	6
 110+ 2FDB 38 16       >		jr	c, .InitPagesL2		; end if a < 6
 110+ 2FDD             >
 110+ 2FDD 3D          >		dec	a
 110+ 2FDE 47          >		ld	b, a
 110+ 2FDF             >
 110+ 2FDF 21 D9 2F    >		ld	hl, .InitPagesL1
 110+ 2FE2 E5          >		push	hl
 110+ 2FE3 21 EA 0D    >		ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; return to page 0
 110+ 2FE6 E5          >		push	hl
 110+ 2FE7 21 21 07    >		ld	hl, $0721		; ld (hl), a; or a; ret; mark page a
 110+ 2FEA E5          >		push	hl
 110+ 2FEB 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 110+ 2FEE E5          >		push	hl
 110+ 2FEF 21 F9 3D    >		ld	hl, RAM_PAGE
 110+ 2FF2 C9          >		ret
 110+ 2FF3             >.InitPagesL2
 110+ 2FF3             >
 111+ 2FF3              		LOADPG 5, offsetPg5, dbFnNMISys
 111+ 2FF3             >
 111+ 2FF3 21 18 30    >		ld	hl, .LoadPageL1
 111+ 2FF6 E5          >		push	hl
 111+ 2FF7             >
 111+ 2FF7 21 F3 30    >		ld	hl, dbFnNMISys
 111+ 2FFA 06 01       >		ld	b, FA_OPEN_EX|FA_READ
 111+ 2FFC 3E 24       >		ld	a, SYS_DRIVE
 111+ 2FFE CF          >		rst	$08
 111+ 2FFF 9A          >		db	F_OPEN
 111+ 3000             >
 111+ 3000 47          >		ld	b, a			; a = HANDLE
 111+ 3001 C5          >		push	bc
 111+ 3002 01 00 00    >		ld	bc, 0
 111+ 3005 11 82 02    >		ld	de, offsetPg5
 111+ 3008 2E 00       >		ld	l, 0			; 0 from start of file
 111+ 300A CF          >		rst	$08
 111+ 300B 9F          >		db	F_SEEK
 111+ 300C C1          >		pop	bc			; b = HANDLE
 111+ 300D             >
 111+ 300D 21 D9 0D    >		ld	hl, $0dd9		; ld a, b; push bc; ld hl, $2000; ld bc, $1c00; rst $08; db F_READ; pop bc; push af; ld a, b; rst $08; db F_CLOSE; popaf; ld b, a; ld a, 0; out ($e3), a; ld a, b; ret
 111+ 3010 E5          >		push	hl
 111+ 3011             >
 111+ 3011 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 111+ 3014 E5          >		push	hl
 111+ 3015 3E 05       >		ld	a, 5
 111+ 3017 C9          >		ret
 111+ 3018             >.LoadPageL1
 112+ 3018              		LOADPG 6, offsetPg6, dbFnNMISys
 112+ 3018             >
 112+ 3018 21 3D 30    >		ld	hl, .LoadPageL1
 112+ 301B E5          >		push	hl
 112+ 301C             >
 112+ 301C 21 F3 30    >		ld	hl, dbFnNMISys
 112+ 301F 06 01       >		ld	b, FA_OPEN_EX|FA_READ
 112+ 3021 3E 24       >		ld	a, SYS_DRIVE
 112+ 3023 CF          >		rst	$08
 112+ 3024 9A          >		db	F_OPEN
 112+ 3025             >
 112+ 3025 47          >		ld	b, a			; a = HANDLE
 112+ 3026 C5          >		push	bc
 112+ 3027 01 00 00    >		ld	bc, 0
 112+ 302A 11 8E 1A    >		ld	de, offsetPg6
 112+ 302D 2E 00       >		ld	l, 0			; 0 from start of file
 112+ 302F CF          >		rst	$08
 112+ 3030 9F          >		db	F_SEEK
 112+ 3031 C1          >		pop	bc			; b = HANDLE
 112+ 3032             >
 112+ 3032 21 D9 0D    >		ld	hl, $0dd9		; ld a, b; push bc; ld hl, $2000; ld bc, $1c00; rst $08; db F_READ; pop bc; push af; ld a, b; rst $08; db F_CLOSE; popaf; ld b, a; ld a, 0; out ($e3), a; ld a, b; ret
 112+ 3035 E5          >		push	hl
 112+ 3036             >
 112+ 3036 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 112+ 3039 E5          >		push	hl
 112+ 303A 3E 06       >		ld	a, 6
 112+ 303C C9          >		ret
 112+ 303D             >.LoadPageL1
 113+ 303D
 114+ 303D AF           		xor a
 115+ 303E 32 F1 30     		ld (dbFirstTime),a
 116+ 3041
 117+ 3041              		//
 118+ 3041              		// Cargamos NMI navigator en pagina 5 la primera vez que se produce una NMI
 119+ 3041              		// Seria deseable comprobar que la pagina 5 no ha sido alterada cada vez que se produce una NMI
 120+ 3041              		//
 121+ 3041
 122+ 3041              lbStart		//
 123+ 3041              		// Run NMI navigator on page 5
 124+ 3041              		//
 125+ 3041 31 00 5C     		ld sp, NMI_STACK		; necessary to use MACROS
 126+ 3044 21 E8 30     		ld hl, dwSavedSP
 127+ 3047 11 00 5B     		ld de, BACKED_UP_RAM		; $5b00
 128+ 304A 01 09 00     		ld bc, 9
 129+ 304D ED B0        		ldir
 130+ 304F 2A EF 30     		ld hl, (dwPtrNMIbuf)
 131+ 3052 11 09 5B     		ld de, BACKED_UP_RAM+9		; $5b00+9
 132+ 3055 01 1F 00     		ld bc, 31
 133+ 3058 ED B0        		ldir
 134+ 305A              		JUMPPG 5, page5.mainNMI
 134+ 305A             >
 134+ 305A             >		//ld	hl, .RunPgL1
 134+ 305A             >		//push	hl
 134+ 305A             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 134+ 305A             >		//push	hl
 134+ 305A 21 00 20    >		ld	hl, page5.mainNMI
 134+ 305D E5          >		push	hl
 134+ 305E 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 134+ 3061 E5          >		push	hl
 134+ 3062 3E 05       >		ld	a, 5
 134+ 3064 C9          >		ret
 134+ 3065             >//.RunPgL1
 135+ 3065 ED 7B E8 30  lbBack		ld sp, (dwSavedSP)		; necessary to back to NMI handler
 136+ 3069
 137+ 3069              		; ------------------------
 138+ 3069              		; restore screen from disk
 139+ 3069              		; ------------------------
 140+ 3069              		;
 141+ 3069 3A ED 30     lbRestoreScreen	ld a, (dbSavRAM)
 142+ 306C B7           		or a
 143+ 306D 20 09        		jr nz, lbToFile
 144+ 306F
 145+ 306F 11 00 40     		ld de, 16384
 146+ 3072 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
 147+ 3075 F7           		rst $30
 148+ 3076 0B           		db $0b
 149+ 3077 C9           		ret
 150+ 3078
 151+ 3078 21 00 31     lbToFile	ld hl, dbFnBackupFile	; asciiz string containg path and/or filename
 152+ 307B 06 01        		ld b, FA_OPEN_EX|FA_READ
 153+ 307D              					; open if exists, else error
 154+ 307D              					; read access
 155+ 307D 3E 24        		ld a, SYS_DRIVE		; system/boot drive
 156+ 307F CF           		rst $08			; screen is saved allways in SYS_DRIVE
 157+ 3080 9A           		db F_OPEN		; open file
 158+ 3081              		;jp c, printError1
 159+ 3081 32 F2 30     		ld (dbFileHandle), a	; file handle
 160+ 3084
 161+ 3084 21 00 40     		ld hl, 16384		; dest
 162+ 3087 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
 163+ 308A 3A F2 30     		ld a, (dbFileHandle)	; file handle
 164+ 308D CF           		rst $08			;
 165+ 308E 9D           		db F_READ		; read buffer from file
 166+ 308F              		;jr c, closeFilePrintError1
 167+ 308F
 168+ 308F 3A F2 30     		ld a, (dbFileHandle)	; file handle
 169+ 3092 CF           		rst $08			;
 170+ 3093 9B           		db F_CLOSE		; close file
 171+ 3094              		;jr c, printError1
 172+ 3094              		; ------------------------
 173+ 3094
 174+ 3094              		; -----------------------
 175+ 3094              		; delete screen from disk
 176+ 3094              		; -----------------------
 177+ 3094              		;
 178+ 3094 21 00 31     lbDeleteScreen	ld hl, dbFnBackupFile	; null-terminated string containg path and/or filename
 179+ 3097 3E 24        		ld a, SYS_DRIVE		; system/boot drive
 180+ 3099 CF           		rst $08
 181+ 309A AD           		db F_UNLINK		; unlink file
 182+ 309B              		;jr c, printError1
 183+ 309B              		; -----------------------
 184+ 309B
 185+ 309B C9           		ret			; ret from NMI handler
 186+ 309C              					; state is restored and program execution resumed
 187+ 309C
 188+ 309C 31 00 5C     lbPrtErr	ld sp, $5c00		; necessary to use rst $10
 189+ 309F              		//rst $18
 190+ 309F              		//DW $0d6b		; ROM CLS COMMAND
 191+ 309F 7E           __1		ld a, (hl)
 192+ 30A0 23           		inc hl
 193+ 30A1 B7           		or a
 194+ 30A2 28 05        		jr z, __2
 195+ 30A4 E5           		push hl
 196+ 30A5 D7           		rst $10
 197+ 30A6 E1           		pop hl
 198+ 30A7 18 F6        		jr __1
 199+ 30A9
 200+ 30A9 ED 7B E8 30  __2		ld sp, (dwSavedSP)
 201+ 30AD CD 94 30     		call lbDeleteScreen
 202+ 30B0 C9           		ret
 203+ 30B1
 204+ 30B1              ; --------------------------------------------
 205+ 30B1              ; Velesoft's solution to check divXXX RAM size
 206+ 30B1              ; --------------------------------------------
 207+ 30B1
 208+ 30B1              dbTestedByte	equ $3FFF		; last byte of page
 209+ 30B1
 210+ 30B1              lbTest		DISP BACKED_UP_RAM
 211+ 5B00
 212+ 5B00              		//di
 213+ 5B00 21 37 5B     		ld hl, dbPtrTestBuf
 214+ 5B03 06 3F        		ld b, 00111111b		; 3Fh (63) Last possible page
 215+ 5B05
 216+ 5B05 78           __3		ld a, b
 217+ 5B06 F6 80        		or 10000000b		; 80h (128) CONMEM = 1, MAPRAM = 0
 218+ 5B08 D3 E3        		out (0E3h), a
 219+ 5B0A 3A FF 3F     		ld a, (dbTestedByte)
 220+ 5B0D 77           		ld (hl), a
 221+ 5B0E 23           		inc hl
 222+ 5B0F 78           		ld a, b
 223+ 5B10 32 FF 3F     		ld (dbTestedByte), a
 224+ 5B13 10 F0        		djnz __3
 225+ 5B15              		;
 226+ 5B15              		; Empieza a contar de 63 a 0
 227+ 5B15              		; cambia pagina = contador, con CONMEM = 1, MAPRAM = 0
 228+ 5B15              		; guarda en (49223+63-contador) lo que hay en (3FFF)
 229+ 5B15              		; guarda en (3FFF) el contador
 230+ 5B15              		;
 231+ 5B15
 232+ 5B15 3E BF        		ld a, 10111111b		; 0BFh (191) CONMEM = 1, MAPRAM = 0, BANK = 63
 233+ 5B17 D3 E3        		out (0E3h), a
 234+ 5B19 3A FF 3F     		ld a, (dbTestedByte)
 235+ 5B1C 5F           		ld e, a
 236+ 5B1D 21 37 5B     		ld hl, dbPtrTestBuf
 237+ 5B20 06 3F        		ld b, 00111111b		; 3Fh (63)  Last possible page
 238+ 5B22              		;
 239+ 5B22              		; activa la pagina 63 con CONMEM = 1 y MAPRAM = 0
 240+ 5B22              		; guarda en e lo que hay en (3FFF)
 241+ 5B22              		; que es el valor mas alto de pagina existente!
 242+ 5B22              		;
 243+ 5B22
 244+ 5B22 78           __4		ld a, b
 245+ 5B23 F6 80        		or 10000000b		; 80h (128) CONMEM = 1, MAPRAM = 0
 246+ 5B25 D3 E3        		out (0E3h), a
 247+ 5B27 7E           		ld a, (hl)
 248+ 5B28 32 FF 3F     		ld (dbTestedByte), a
 249+ 5B2B 23           		inc hl
 250+ 5B2C 10 F4        		djnz __4
 251+ 5B2E              		;
 252+ 5B2E              		; Empieza a contar de 63 a 0
 253+ 5B2E              		; cambia pagina = contador, con CONMEM = 1, MAPRAM = 0
 254+ 5B2E              		; guarda en (3FFF) lo que hay en (49223+63-contador)
 255+ 5B2E              		;
 256+ 5B2E
 257+ 5B2E 1C           		inc e
 258+ 5B2F 26 00        		ld h, 0
 259+ 5B31 6B           		ld l, e
 260+ 5B32              		;ld a, %00000010	; CONMEM = 0, MAPRAM = 0, BANK = 2 -> dot command
 261+ 5B32 3E 00        		ld a, %00000000		; CONMEM = 0, MAPRAM = 0, BANK = 0 -> NMI code
 262+ 5B34 D3 E3        		out (0E3h), a
 263+ 5B36              		;
 264+ 5B36              		; Devuelve en hl el valor mas alto de pagina existente
 265+ 5B36              		;
 266+ 5B36
 267+ 5B36              		//ei
 268+ 5B36 C9           		ret
 269+ 5B37
 270+ 5B37              dbPtrTestBuf	ENT			; buffer of 64 bytes, 1 byte per page
 271+ 30E8
 272+ 30E8              lbTestLen	equ $-lbTest
 273+ 30E8
 274+ 30E8              ; -----------------------------------------------------------------------------
 275+ 30E8              ; LOADER data
 276+ 30E8              ; -----------------------------------------------------------------------------
 277+ 30E8
 278+ 30E8              ;
 279+ 30E8              ; Order must be the same as in data.asm
 280+ 30E8              ;-------------------
 281+ 30E8 00 00        dwSavedSP	DW 0
 282+ 30EA 00 00        dwDivRAM	DW 0
 283+ 30EC 00           dbSpeccyRAM	DB 0
 284+ 30ED 00           dbSavRAM	DB 0
 285+ 30EE 00           dbEsxDOSv	DB 0
 286+ 30EF 00 00        dwPtrNMIbuf	DW 0
 287+ 30F1              ;-------------------
 288+ 30F1
 289+ 30F1 FF           dbFirstTime	DB $ff
 290+ 30F2 00           dbFileHandle	DB 0
 291+ 30F3
 292+ 30F3 2F 53 59 53  dbFnNMISys	DB '/SYS/NMI.SYS', 0
 292+ 30F7 2F 4E 4D 49
 292+ 30FB 2E 53 59 53
 292+ 30FF 00
 293+ 3100 2F 54 4D 50  dbFnBackupFile	DB '/TMP/_NMI_BAK.SCR', 0
 293+ 3104 2F 5F 4E 4D
 293+ 3108 49 5F 42 41
 293+ 310C 4B 2E 53 43
 293+ 3110 52 00
 294+ 3112
 295+ 3112 0D 45 52 52  msgErrRAM	DB 13,'ERROR: Device with 32K or more RAM required', 0
 295+ 3116 4F 52 3A 20
 295+ 311A 44 65 76 69
 295+ 311E 63 65 20 77
 295+ 3122 69 74 68 20
 295+ 3126 33 32 4B 20
 295+ 312A 6F 72 20 6D
 295+ 312E 6F 72 65 20
 295+ 3132 52 41 4D 20
 295+ 3136 72 65 71 75
 295+ 313A 69 72 65 64
 295+ 313E 00
 296+ 313F 0D 45 52 52  msgErrVer	DB 13,'ERROR: Only works on esxDOS v0.8.9', 0
 296+ 3143 4F 52 3A 20
 296+ 3147 4F 6E 6C 79
 296+ 314B 20 77 6F 72
 296+ 314F 6B 73 20 6F
 296+ 3153 6E 20 65 73
 296+ 3157 78 44 4F 53
 296+ 315B 20 76 30 2E
 296+ 315F 38 2E 39 00
 297+ 3163 0D 45 52 52  msgUnkVer	DB 13,'ERROR: Unknown esxDOS version',0
 297+ 3167 4F 52 3A 20
 297+ 316B 55 6E 6B 6E
 297+ 316F 6F 77 6E 20
 297+ 3173 65 73 78 44
 297+ 3177 4F 53 20 76
 297+ 317B 65 72 73 69
 297+ 317F 6F 6E 00
 298+ 3182
# file closed: loader.asm
  93  3182
  94  3182              		; -------------------------------------------------------------
  95  3182              		IF $ > NMI_OVERLAY+NMI_SIZE
  96  3182 ~            		LUA
  97  3182 ~            		sj.error("Page ".._c("DivXXXPg")..": Resulting code too long ("
  98  3182 ~            		..(_c("$")-(_c("NMI_OVERLAY")+_c("NMI_SIZE"))).." bytes)")
  99  3182 ~            		ENDLUA
 100  3182              		ENDIF
 101  3182              		; -------------------------------------------------------------
 102  3182
 103  3182              		ENDMODULE
 104  3182
 105  3182              pg0end
 106  3182
 107  3182              ;==============================================================================
 108  3182              ; MAIN - PAGE 5
 109  3182              ;==============================================================================
 110  3182
 111  3182              		UNDEFINE DivXXXPg
 112  3182              		DEFINE DivXXXPg 5
 113  3182              		DISP PAGE_START
 114  2000
 115  2000              offsetPg5	EQU $$$-NMI_OVERLAY	; offset relative to start of file
 116  2000              					; used to load page 5
 117  2000
 118  2000              pg5start	MODULE page5
 119  2000
 120  2000              		INCLUDE "main.asm"
# file opened: main.asm
   1+ 2000              ;==============================================================================
   2+ 2000              ; Project: NMI.zdsp
   3+ 2000              ; File: main.asm
   4+ 2000              ; Date: 29/08/2017 13:39:54
   5+ 2000              ;
   6+ 2000              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2000              ;
   8+ 2000              ;==============================================================================
   9+ 2000
  10+ 2000              ;==============================================================================
  11+ 2000              ; MAIN - divXXX page 5
  12+ 2000              ;==============================================================================
  13+ 2000
  14+ 2000 21 00 5B     mainNMI		ld hl, BACKED_UP_RAM	; DB 21,00,5B	; $5b00
  15+ 2003 11 84 35     		ld de, savedSP		; DB 11,CA,37
  16+ 2006 01 28 00     		ld bc, 31+9		; DB 01,28,00
  17+ 2009 ED B0        		ldir			; DB ED,B0
  18+ 200B
  19+ 200B              		//ld sp, (savedSP)
  20+ 200B              		//jp init.start
  21+ 200B
  22+ 200B              mainL1		//jp reload.start
  23+ 200B ED 7B 84 35  		ld sp, (savedSP)
  24+ 200F              		//jp startup.start
  25+ 200F CD 98 27     		call startup.start
  26+ 2012
  27+ 2012 01 00 18     mainL2		ld bc, 24*256+0		; 24 lines from line 0
  28+ 2015 3E 07        		ld a, COL_MID		; color
  29+ 2017 CD 21 24     		call clrScr
  30+ 201A CD 71 21     		call prTop
  31+ 201D
  32+ 201D CD BE 21     mainL3		call prMid
  33+ 2020
  34+ 2020 CD 80 21     mainL4		call prBot
  35+ 2023 CD 55 21     		call prCur
  36+ 2026
  37+ 2026 CD 51 23     mainL5		call waitKey
  38+ 2029
  39+ 2029 4F           		ld c, a			; c <- key pressed
  40+ 202A              		;
  41+ 202A CD 3A 23     		call beep
  42+ 202D              		;
  43+ 202D 21 AC 31     		ld hl, dbdwTbActions
  44+ 2030 7E           nextKey		ld a, (hl)		; a <- key to check
  45+ 2031 B7           		or a
  46+ 2032 28 F2        		jr z, mainL5		; end of table
  47+ 2034 23           		inc hl
  48+ 2035 5E           		ld e, (hl)		;
  49+ 2036 23           		inc hl			;
  50+ 2037 56           		ld d, (hl)		; de <- address of action routine
  51+ 2038 23           		inc hl
  52+ 2039 B9           		cp c			; key pressed = key to check ?
  53+ 203A 20 F4        		jr nz, nextKey		; no, try next key to check
  54+ 203C              		;
  55+ 203C D5           		push de
  56+ 203D CD 31 21     		call readEnt		; read current dir entry (entry at cursor)
  57+ 2040 E1           		pop hl
  58+ 2041              		;
  59+ 2041 E9           		jp (hl)			; yes, jump to action routine
  60+ 2042
  61+ 2042 CD 19 24     exitNMI		call wait
  62+ 2045
  63+ 2045              		//ld sp, (savedSP)	///
  64+ 2045              		//RETPG0		; return to NMI loader on page 0
  65+ 2045
  66+ 2045 31 00 5C     		ld sp, NMI_STACK	; necessary to use PAGING MACROS
  67+ 2048              		JUMPPG 0, initNMI.lbBack; return to NMI loader on page 0
  67+ 2048             >
  67+ 2048             >		//ld	hl, .RunPgL1
  67+ 2048             >		//push	hl
  67+ 2048             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
  67+ 2048             >		//push	hl
  67+ 2048 21 65 30    >		ld	hl, initNMI.lbBack
  67+ 204B E5          >		push	hl
  67+ 204C 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
  67+ 204F E5          >		push	hl
  67+ 2050 3E 00       >		ld	a, 0
  67+ 2052 C9          >		ret
  67+ 2053             >//.RunPgL1
  68+ 2053
  69+ 2053              ; -----------------------------------------------------------------------------
  70+ 2053              ; NAVIGATION FUNCTIONS
  71+ 2053              ; -----------------------------------------------------------------------------
  72+ 2053
  73+ 2053              ; ----------------
  74+ 2053              ; go to parent dir
  75+ 2053              ; ----------------
  76+ 2053              ;
  77+ 2053 3A 83 35     upDir		ld a, (flgROOT)
  78+ 2056 B7           		or a
  79+ 2057 C2 26 20     		jp nz, mainL5		; only if not on root dir
  80+ 205A
  81+ 205A 21 86 31     		ld hl, dotDot		; '..'
  82+ 205D CD DE 22     		call fChDir
  83+ 2060 C3 0B 20     		jp mainL1		; reload dir and reprint all
  84+ 2063
  85+ 2063              ; ------------------
  86+ 2063              ; moves to prev line
  87+ 2063              ; ------------------
  88+ 2063              ;
  89+ 2063 CD 51 21     prevLn		call clCur
  90+ 2066 3A AC 35     		ld a, (curLn)		; between 0 and 21
  91+ 2069 B7           		or a
  92+ 206A 28 07        		jr z, prevLn1
  93+ 206C 3D           		dec a
  94+ 206D 32 AC 35     		ld (curLn), a
  95+ 2070 C3 20 20     		jp mainL4		; reprint bottom and cursor
  96+ 2073 CD A4 20     prevLn1		call prevCk
  97+ 2076 DA 20 20     		jp c, mainL4
  98+ 2079 3E 15        		ld a, 21
  99+ 207B 32 AC 35     		ld (curLn), a
 100+ 207E 18 3E        		jr prevPg1
 101+ 2080
 102+ 2080              ; ------------------
 103+ 2080              ; moves to next line
 104+ 2080              ; ------------------
 105+ 2080              ;
 106+ 2080 CD 51 21     nextLn		call clCur
 107+ 2083              		;ld      a, (Xlim)       ; between 1 and 22
 108+ 2083              		;dec     a
 109+ 2083 3A B2 35     		ld a, (Xlim)		; between 0 and 21
 110+ 2086 47           		ld b, a
 111+ 2087 3A AC 35     		ld a, (curLn)		; between 0 and 21
 112+ 208A B8           		cp b
 113+ 208B 30 0B        		jr nc, nextLn1		; curLn >= Xlim-1
 114+ 208D FE 15        		cp 21
 115+ 208F 28 07        		jr z, nextLn1
 116+ 2091 3C           		inc a
 117+ 2092 32 AC 35     		ld (curLn), a
 118+ 2095 C3 20 20     		jp mainL4		; reprint bottom and cursor
 119+ 2098 CD DD 20     nextLn1		call nextCk
 120+ 209B D2 20 20     		jp nc, mainL4
 121+ 209E AF           		xor a
 122+ 209F 32 AC 35     		ld (curLn), a
 123+ 20A2 18 63        		jr nextPg1
 124+ 20A4
 125+ 20A4              ; ------------------
 126+ 20A4              ; moves to prev page
 127+ 20A4              ; ------------------
 128+ 20A4              ;
 129+ 20A4 2A B0 35     prevCk		ld hl, (Xof)
 130+ 20A7 11 16 00     		ld de, 22
 131+ 20AA B7           		or a			; clear carry flag
 132+ 20AB ED 52        		sbc hl, de
 133+ 20AD C9           		ret
 134+ 20AE
 135+ 20AE 3A AC 35     prevPg		ld a, (curLn)		; between 0 and 21
 136+ 20B1 B7           		or a
 137+ 20B2 28 0A        		jr z, prevPg1
 138+ 20B4 CD 51 21     		call clCur
 139+ 20B7 AF           		xor a
 140+ 20B8 32 AC 35     		ld (curLn), a
 141+ 20BB C3 20 20     		jp mainL4		; reprint bottom and cursor
 142+ 20BE              		;
 143+ 20BE CD A4 20     prevPg1		call prevCk
 144+ 20C1 DA 20 20     		jp c, mainL4		; reprint bottom and cursor
 145+ 20C4 22 B0 35     		ld (Xof), hl
 146+ 20C7 CD 51 21     		call clCur
 147+ 20CA              		;xor     a              ;
 148+ 20CA              		;ld      (curLn), a     ; preserves cursor position
 149+ 20CA              		;
 150+ 20CA              		;       RECUPERAR DE pPrvDir EL PUNTERO A LA PAGINA ANTERIOR
 151+ 20CA              		;
 152+ 20CA 2A AE 35     		ld hl, (pCurPg)
 153+ 20CD 2B           		dec hl
 154+ 20CE
 155+ 20CE              		IFDEF _POINTER4BYTES
 156+ 20CE ~            		  ld de, pCurDir+3
 157+ 20CE ~            		  ld bc, 4
 158+ 20CE              		ELSE
 159+ 20CE 11 B8 35     		  ld de, pCurDir+2
 160+ 20D1 01 03 00     		  ld bc, 3
 161+ 20D4              		ENDIF
 162+ 20D4 ED B8        		lddr			; con lddr nos ahorramos restarle 4 a pCurPg
 163+ 20D6 23           		inc hl
 164+ 20D7 22 AE 35     		ld (pCurPg), hl
 165+ 20DA              		;
 166+ 20DA C3 1D 20     		jp mainL3		; reprint mid, bottom and cursor
 167+ 20DD
 168+ 20DD              ; ------------------
 169+ 20DD              ; moves to next page
 170+ 20DD              ; ------------------
 171+ 20DD              ;
 172+ 20DD 2A B0 35     nextCk		ld hl, (Xof)
 173+ 20E0 11 16 00     		ld de, 22
 174+ 20E3 19           		add hl, de
 175+ 20E4 ED 5B B4 35  		ld de, (ofY)
 176+ 20E8              		;
 177+ 20E8              		; If ofY is zero, end of directory not reached yet
 178+ 20E8              		;
 179+ 20E8 7A           		ld a,d
 180+ 20E9 B3           		or e
 181+ 20EA 37           		scf
 182+ 20EB C8           		ret z
 183+ 20EC B7           		or a			; clear carry flag
 184+ 20ED E5           		push hl
 185+ 20EE ED 52        		sbc hl, de
 186+ 20F0 E1           		pop hl
 187+ 20F1 C9           		ret
 188+ 20F2
 189+ 20F2              nextPg		;ld      a, (Xlim)       ; between 1 and 22
 190+ 20F2              		;dec     a
 191+ 20F2 3A B2 35     		ld a, (Xlim)		; between 0 and 21
 192+ 20F5 47           		ld b, a
 193+ 20F6 3A AC 35     		ld a, (curLn)		; between 0 and 21
 194+ 20F9 B8           		cp b
 195+ 20FA 28 0B        		jr z, nextPg1
 196+ 20FC C5           		push bc
 197+ 20FD CD 51 21     		call clCur
 198+ 2100 F1           		pop af
 199+ 2101 32 AC 35     		ld (curLn), a
 200+ 2104 C3 20 20     		jp mainL4		; reprint bottom and cursor
 201+ 2107              		;
 202+ 2107 CD DD 20     nextPg1		call nextCk
 203+ 210A D2 20 20     		jp nc, mainL4		; reprint bottom and cursor
 204+ 210D 22 B0 35     		ld (Xof), hl
 205+ 2110 CD 51 21     		call clCur
 206+ 2113              		;xor     a              ;
 207+ 2113              		;ld      (curLn), a     ; preserves cursor position
 208+ 2113              		;
 209+ 2113              		;       GUARDAR EN pPrvDir EL PUNTERO A LA PAGINA ACTUAL
 210+ 2113              		;
 211+ 2113 21 B6 35     		ld hl, pCurDir
 212+ 2116 ED 5B AE 35  		ld de, (pCurPg)
 213+ 211A              		IFDEF _POINTER4BYTES
 214+ 211A ~            		  ld bc, 4
 215+ 211A              		ELSE
 216+ 211A 01 03 00     		  ld bc, 3
 217+ 211D              		ENDIF
 218+ 211D ED B0        		ldir
 219+ 211F ED 53 AE 35  		ld (pCurPg), de
 220+ 2123              		;
 221+ 2123              		;       CARGAR EN pCurDir EL PUNTERO A LA PAGINA SIGUIENTE
 222+ 2123              		;
 223+ 2123              		IFDEF _POINTER4BYTES
 224+ 2123 ~            		  ld hl, pCurDir+22*4
 225+ 2123 ~            		  ld bc, 4
 226+ 2123              		ELSE
 227+ 2123 21 F8 35     		  ld hl, pCurDir+22*3
 228+ 2126 01 03 00     		  ld bc, 3
 229+ 2129              		ENDIF
 230+ 2129 11 B6 35     		ld de, pCurDir
 231+ 212C ED B0        		ldir
 232+ 212E              		;
 233+ 212E C3 1D 20     		jp mainL3		; reprint mid, bottom and cursor
 234+ 2131
 235+ 2131              ; -----------------------------------------------------------------------------
 236+ 2131              ; GUI functions
 237+ 2131              ; -----------------------------------------------------------------------------
 238+ 2131
 239+ 2131              ; ----------------------
 240+ 2131              ; read current dir entry
 241+ 2131              ; ----------------------
 242+ 2131              ;
 243+ 2131 CD 9C 22     readEnt		call fOpenDir		; read current dir entry (entry at cursor)
 244+ 2134
 245+ 2134              		IFDEF _POINTER4BYTES
 246+ 2134 ~            		  ld hl, (curLn)	;
 247+ 2134 ~            		  ld de, pCurDir	;
 248+ 2134 ~            		  add hl, hl		;
 249+ 2134 ~            		  add hl, hl		;
 250+ 2134 ~            		  add hl, de		; hl = pCurDir + curLn*4
 251+ 2134 ~            		  ld c, (hl)		; bcde <- (hl)
 252+ 2134 ~            		  inc hl		;
 253+ 2134 ~            		  ld b, (hl)		;
 254+ 2134 ~            		  inc hl		;
 255+ 2134 ~            		  ld e, (hl)		;
 256+ 2134 ~            		  inc hl		;
 257+ 2134 ~            		  ld d, (hl)		;
 258+ 2134              		ELSE
 259+ 2134 ED 4B AC 35  		  ld bc, (curLn)	;
 260+ 2138 11 B6 35     		  ld de, pCurDir	;
 261+ 213B 60           		  ld h, b		;
 262+ 213C 69           		  ld l, c		;
 263+ 213D 29           		  add hl, hl		;
 264+ 213E 09           		  add hl, bc		;
 265+ 213F 19           		  add hl, de		; hl = pCurDir + curLn*3
 266+ 2140 06 00        		  ld b, 0		; bcde <- (hl)
 267+ 2142 4E           		  ld c, (hl)		;
 268+ 2143 23           		  inc hl		;
 269+ 2144 5E           		  ld e, (hl)		;
 270+ 2145 23           		  inc hl		;
 271+ 2146 56           		  ld d, (hl)		;
 272+ 2147              		ENDIF
 273+ 2147              		;
 274+ 2147 CD B5 22     		call fSeekDir
 275+ 214A              		;
 276+ 214A CD AC 22     		call fReadDir
 277+ 214D              		//jp c, printError	; REVISAR !!!
 278+ 214D
 279+ 214D CD 93 22     		call fClose
 280+ 2150
 281+ 2150 C9           		ret
 282+ 2151
 283+ 2151              ; ------------
 284+ 2151              ; clear cursor
 285+ 2151              ; ------------
 286+ 2151              ;
 287+ 2151 3E 07        clCur		ld a, COL_MID		; color
 288+ 2153 18 02        		jr prCurL0
 289+ 2155
 290+ 2155              ; -----------
 291+ 2155              ; draw cursor
 292+ 2155              ; -----------
 293+ 2155              ;
 294+ 2155 3E 4F        prCur		ld a, COL_CUR		; color
 295+ 2157 4F           prCurL0		ld c, a
 296+ 2158 2A AC 35     		ld hl, (curLn)		; cursor between 0 and 21
 297+ 215B 23           		inc hl			; screen rows between 1 and 22
 298+ 215C 06 05        		ld b, 5			;
 299+ 215E 29           multx2		add hl, hl		;
 300+ 215F 10 FD        		djnz multx2		; hl = hl x 32
 301+ 2161 11 00 58     		ld de, 16384+6144
 302+ 2164 ED 5A        		adc hl, de
 303+ 2166 E5           		push hl
 304+ 2167 D1           		pop de
 305+ 2168 13           		inc de
 306+ 2169 79           		ld a, c
 307+ 216A 77           		ld (hl),a
 308+ 216B 01 1F 00     		ld bc,32-1
 309+ 216E ED B0        		ldir
 310+ 2170 C9           		ret
 311+ 2171
 312+ 2171              ; -------------------
 313+ 2171              ; print top of screen
 314+ 2171              ; -------------------
 315+ 2171              ;
 316+ 2171 01 00 01     prTop		ld bc, 1*256+0		; 1 line from line 0
 317+ 2174 3E 38        		ld a, COL_TOP		; color
 318+ 2176 CD 21 24     		call clrScr
 319+ 2179              		;
 320+ 2179 21 58 32     		ld hl, msgTop1
 321+ 217C CD C9 24     		call prStr
 322+ 217F              		;ld      a, (flgCWD)
 323+ 217F              		;and     a
 324+ 217F              		;jr      z, prTopL1
 325+ 217F              		;ld      a, 129          ; two points
 326+ 217F              		;call    prOk
 327+ 217F              		;prTopL1 ld      hl, (pCWD)
 328+ 217F              		;call    prStr
 329+ 217F              		//ld hl, msgSP
 330+ 217F              		//call prStr
 331+ 217F              		//ld hl, (savedSP)
 332+ 217F              		//ld hl, (NMIbuf_org)
 333+ 217F              		//call utoa
 334+ 217F
 335+ 217F C9           		ret
 336+ 2180
 337+ 2180              //msgSP		db $16,0,64-10,'SP: ', 0
 338+ 2180
 339+ 2180              ; ----------------------
 340+ 2180              ; print bottom of screen
 341+ 2180              ; ----------------------
 342+ 2180              ;
 343+ 2180 01 17 01     prBot		ld bc, 1*256+23		; 1 line from line 23
 344+ 2183 3E 38        		ld a, COL_BOT		; color
 345+ 2185 CD 21 24     		call clrScr
 346+ 2188              		;
 347+ 2188 21 9A 32     		ld hl, msgBot1
 348+ 218B CD C9 24     		call prStr
 349+ 218E 2A B0 35     		ld hl, (Xof)
 350+ 2191 ED 5B AC 35  		ld de, (curLn)
 351+ 2195 19           		add hl, de
 352+ 2196 23           		inc hl
 353+ 2197 CD C3 24     		call utoa
 354+ 219A 21 9F 32     		ld hl, msgBot3
 355+ 219D CD C9 24     		call prStr
 356+ 21A0 2A B4 35     		ld hl, (ofY)
 357+ 21A3 7C           		ld a, h
 358+ 21A4 B5           		or l
 359+ 21A5 20 07        		jr nz, prBot1
 360+ 21A7 3E 2D        		ld a, '-'
 361+ 21A9 CD DC 24     		call prChr
 362+ 21AC 18 03        		jr prBot2
 363+ 21AE CD C3 24     prBot1		call utoa
 364+ 21B1 21 A1 32     prBot2		ld hl, msgBot4
 365+ 21B4 CD C9 24     		call prStr
 366+ 21B7 21 A3 32     		ld hl, msgBot5
 367+ 21BA CD C9 24     		call prStr
 368+ 21BD C9           		ret
 369+ 21BE
 370+ 21BE              ; -------------------
 371+ 21BE              ; print mid of screen
 372+ 21BE              ; -------------------
 373+ 21BE              ;
 374+ 21BE
 375+ 21BE              //msgOffset	db $16,1,8+1+3+1+7,0
 376+ 21BE
 377+ 21BE 01 01 16     prMid		ld bc, 22*256+1		; 22 lines from line 1
 378+ 21C1 3E 07        		ld a, COL_MID		; color
 379+ 21C3 CD 21 24     		call clrScr
 380+ 21C6 CD 9C 22     		call fOpenDir
 381+ 21C9
 382+ 21C9              		IFDEF _POINTER4BYTES
 383+ 21C9 ~            		  ld bc, (pCurDir)
 384+ 21C9 ~            		  ld de, (pCurDir+2)
 385+ 21C9              		ELSE
 386+ 21C9 06 00        		  ld b, 0
 387+ 21CB 3A B6 35     		  ld a, (pCurDir)
 388+ 21CE 4F           		  ld c, a
 389+ 21CF ED 5B B7 35  		  ld de, (pCurDir+1)
 390+ 21D3              		ENDIF
 391+ 21D3 CD B5 22     		call fSeekDir
 392+ 21D6
 393+ 21D6 21 00 00     		ld hl, 0		; counter = 0
 394+ 21D9 E5           prMidL0		push hl
 395+ 21DA CD BE 22     		call fTellDir	; OJO, hay 2 bytes en la pila
 396+ 21DD
 397+ 21DD ~            		/*
 398+ 21DD ~            		///
 399+ 21DD ~            		/// BCDE offset
 400+ 21DD ~            		///
 401+ 21DD ~            		pop hl
 402+ 21DD ~            		push hl
 403+ 21DD ~            		push bc
 404+ 21DD ~            		push de
 405+ 21DD ~            		ld a, l
 406+ 21DD ~            		inc a
 407+ 21DD ~            		ld (msgOffset+1), a
 408+ 21DD ~            		ld hl, msgOffset
 409+ 21DD ~            		call prStr
 410+ 21DD ~            		pop de
 411+ 21DD ~            		pop hl
 412+ 21DD ~            		push hl
 413+ 21DD ~            		push de
 414+ 21DD ~            		call utoa
 415+ 21DD ~            		ld a, ' '
 416+ 21DD ~            		call prChr
 417+ 21DD ~            		pop hl
 418+ 21DD ~            		push hl
 419+ 21DD ~            		call utoa
 420+ 21DD ~            		pop de
 421+ 21DD ~            		pop bc
 422+ 21DD ~            		///
 423+ 21DD ~            		///
 424+ 21DD ~            		///
 425+ 21DD ~            		*/
 426+ 21DD
 427+ 21DD              		;
 428+ 21DD E1           		pop hl
 429+ 21DE E5           		push hl
 430+ 21DF D5           		push de
 431+ 21E0 C5           		push bc
 432+ 21E1 11 B6 35     		ld de, pCurDir
 433+ 21E4              		IFDEF _POINTER4BYTES
 434+ 21E4 ~            		  add hl, hl		;
 435+ 21E4 ~            		  add hl, hl		;
 436+ 21E4 ~            		  add hl, de		; hl = pCurDir + counter*4
 437+ 21E4              		ELSE
 438+ 21E4 44           		  ld b, h		;
 439+ 21E5 4D           		  ld c, l		;
 440+ 21E6 29           		  add hl, hl		;
 441+ 21E7 09           		  add hl, bc		;
 442+ 21E8 19           		  add hl, de		; hl = pCurDir + counter*3
 443+ 21E9              		ENDIF
 444+ 21E9 C1           		pop bc
 445+ 21EA D1           		pop de
 446+ 21EB 71           		ld (hl), c		; (hl) <- bcde
 447+ 21EC 23           		inc hl			;
 448+ 21ED              		IFDEF _POINTER4BYTES
 449+ 21ED ~            		  ld (hl), b		; (hl) <- cde
 450+ 21ED ~            		  inc hl		;
 451+ 21ED              		ENDIF
 452+ 21ED 73           		ld (hl), e		;
 453+ 21EE 23           		inc hl			;
 454+ 21EF 72           		ld (hl), d		;
 455+ 21F0              		;
 456+ 21F0
 457+ 21F0 CD AC 22     		call fReadDir	; en las pruebas: CF=0 A=$01 si hay mas entradas
 458+ 21F3              					;                 CF=1 A=$80 si no hay mas entradas
 459+ 21F3 38 59        		jr c, prMidL3
 460+ 21F5 B7           		or a
 461+ 21F6 28 56        		jr z, prMidL3		; a==0 if end of dir
 462+ 21F8
 463+ 21F8              		//
 464+ 21F8              		// ignore hidden and system files
 465+ 21F8              		//
 466+ 21F8 3A 89 31     		ld a, (bDAttr)
 467+ 21FB
 468+ 21FB E6 06        		and A_HIDDEN or A_SYSTEM
 469+ 21FD 21 2C 37     		ld hl, flgHidden
 470+ 2200 A6           		and (hl)
 471+ 2201 E1           		pop hl
 472+ 2202 20 D5        		jr nz, prMidL0		; nz skip system & hidden files
 473+ 2204 E5           		push hl
 474+ 2205
 475+ 2205              		;
 476+ 2205              		; limit to MAXENTR total dir entries
 477+ 2205              		;
 478+ 2205 E1           		pop hl
 479+ 2206 E5           		push hl
 480+ 2207 ED 5B B0 35  		ld de, (Xof)
 481+ 220B 19           		add hl, de		; total number of directory entries
 482+ 220C B7           		or a			; clear CF
 483+ 220D 11 98 08     		ld de, MAXENTR
 484+ 2210 ED 52        		sbc hl, de
 485+ 2212 28 3A        		jr z, prMidL3		; total number of directory entries = MAXENTR
 486+ 2214
 487+ 2214              		;
 488+ 2214              		; limit to 22 current dir entries
 489+ 2214              		;
 490+ 2214 E1           		pop hl
 491+ 2215 E5           		push hl
 492+ 2216 7D           		ld a, l
 493+ 2217 FE 16        		cp 22
 494+ 2219 30 3D        		jr nc, prMidL4		; if hl >= 22 (read 22 entries
 495+ 221B              					; plus 1 entry for next page)
 496+ 221B              		;
 497+ 221B              		; print directory entry
 498+ 221B              		;
 499+ 221B E1           prMidL1		pop hl
 500+ 221C E5           		push hl
 501+ 221D 7D           		ld a, l
 502+ 221E 3C           		inc a
 503+ 221F 32 D4 32     		ld (msgMid1+1), a
 504+ 2222 32 DE 32     		ld (msgMid4+1), a
 505+ 2225 21 D3 32     		ld hl, msgMid1
 506+ 2228 CD C9 24     		call prStr
 507+ 222B 21 8A 31     		ld hl, bDName
 508+ 222E CD C9 24     		call prStr
 509+ 2231
 510+ 2231 21 DD 32     		ld hl, msgMid4
 511+ 2234 CD C9 24     		call prStr
 512+ 2237 3A 89 31     		ld a, (bDAttr)
 513+ 223A E6 10        		and A_DIR		; check if is dir
 514+ 223C 28 08        		jr z, isFile
 515+ 223E              		;
 516+ 223E              		; is directory
 517+ 223E              		;
 518+ 223E 21 D7 32     isDir		ld hl, msgMid2
 519+ 2241 CD C9 24     		call prStr
 520+ 2244 18 03        		jr prMidL2
 521+ 2246              		;
 522+ 2246              		; is file
 523+ 2246              		;
 524+ 2246 CD DD 26     isFile		call prtSize
 525+ 2249              		;
 526+ 2249              		; FALTA IMPRIMIR FECHA
 527+ 2249              		;
 528+ 2249 E1           prMidL2		pop hl
 529+ 224A 23           		inc hl
 530+ 224B C3 D9 21     		jp prMidL0
 531+ 224E
 532+ 224E              prMidL3		;
 533+ 224E              		; Calculate ofY
 534+ 224E              		;
 535+ 224E E1           		pop hl
 536+ 224F E5           		push hl
 537+ 2250 ED 5B B0 35  		ld de, (Xof)
 538+ 2254 19           		add hl, de
 539+ 2255 22 B4 35     		ld (ofY), hl
 540+ 2258
 541+ 2258              		;
 542+ 2258              		; calculate Xlim
 543+ 2258              		;
 544+ 2258 E1           prMidL4		pop hl
 545+ 2259              		;ld (Xlim), hl
 546+ 2259 2B           		dec hl
 547+ 225A 22 B2 35     		ld (Xlim), hl
 548+ 225D              		;
 549+ 225D              		; Correct cursor position according to current number of dir entries on screen
 550+ 225D              		;
 551+ 225D              		;dec     l
 552+ 225D 3A AC 35     		ld a, (curLn)		; between 0 and 21
 553+ 2260 BD           		cp l
 554+ 2261 38 04        		jr c, prMidL5		; curLn >= Xlim-1
 555+ 2263 7D           		ld a, l
 556+ 2264 32 AC 35     		ld (curLn), a
 557+ 2267
 558+ 2267 CD 93 22     prMidL5		call fClose
 559+ 226A C9           		ret
 560+ 226B
# file closed: main.asm
 121  226B
 122  226B              		; -------------------------------------------------------------
 123  226B              		; FUNCTIONS
 124  226B              		; -------------------------------------------------------------
 125  226B
 126  226B              		include "api.asm"
# file opened: api.asm
   1+ 226B              ;==============================================================================
   2+ 226B              ; Project: NMI.zdsp
   3+ 226B              ; File: api.asm
   4+ 226B              ; Date: 03/11/2022 20:41:05
   5+ 226B              ;
   6+ 226B              ; Created with zDevStudio - Z80 Development Studio.
   7+ 226B              ;
   8+ 226B              ;==============================================================================
   9+ 226B
  10+ 226B              ; =============================================================================
  11+ 226B              ; API calls and error handler
  12+ 226B              ; =============================================================================
  13+ 226B
  14+ 226B              ; -----------------------------------------------------------------------------
  15+ 226B              ; API calls
  16+ 226B              ; -----------------------------------------------------------------------------
  17+ 226B              ;
  18+ 226B 3E 2A        fOpen		ld a, CUR_DRIVE		; current drive
  19+ 226D CF           fOpen1		rst $08			; screen is saved allways in SYS_DRIVE
  20+ 226E 9A           		db F_OPEN		; open file
  21+ 226F DA 78 27     		jp c, prError
  22+ 2272 32 79 31     		ld (fhandle), a		; file handle
  23+ 2275 C9           		ret
  24+ 2276
  25+ 2276 3A 79 31     fRead		ld a, (fhandle)		; file handle
  26+ 2279 CF           		rst $08			;
  27+ 227A 9D           		db F_READ		; read buffer from file
  28+ 227B DA 71 27     		jp c, closeFilePrErr
  29+ 227E C9           		ret
  30+ 227F
  31+ 227F 3A 79 31     fWrite		ld a, (fhandle)		; file handle
  32+ 2282 CF           		rst $08			;
  33+ 2283 9E           		db F_WRITE		; write buffer to file
  34+ 2284 DA 71 27     		jp c, closeFilePrErr
  35+ 2287 C9           		ret
  36+ 2288
  37+ 2288 3A 79 31     fSeek		ld a, (fhandle)		; file handle
  38+ 228B 2E 00        		ld l, 0			; 0 from start of file
  39+ 228D              					; 1 fwd from current pos
  40+ 228D              					; 2 bak from current pos
  41+ 228D CF           		rst $08
  42+ 228E 9F           		db F_SEEK
  43+ 228F DA 71 27     		jp c, closeFilePrErr	; QUE SE HACE CON ESTO !!!
  44+ 2292 C9           		ret
  45+ 2293
  46+ 2293 3A 79 31     fClose		ld a, (fhandle)		; file handle
  47+ 2296 CF           		rst $08			;
  48+ 2297 9B           		db F_CLOSE		; close file
  49+ 2298 DA 78 27     		jp c, prError
  50+ 229B C9           		ret
  51+ 229C
  52+ 229C              		;
  53+ 229C
  54+ 229C 3E 2A        fOpenDir	ld a, CUR_DRIVE		; current drive
  55+ 229E 06 00        		ld b, 0
  56+ 22A0 21 87 31     		ld hl, dotDot+1		; '.'   ; cwdBuf is valid too
  57+ 22A3 CF           		rst $08
  58+ 22A4 A3           		db F_OPENDIR
  59+ 22A5 DA 78 27     		jp c, prError
  60+ 22A8 32 79 31     		ld (fhandle), a
  61+ 22AB C9           		ret
  62+ 22AC
  63+ 22AC 21 89 31     fReadDir	ld hl, bufDir
  64+ 22AF 3A 79 31     		ld a, (fhandle)		; file handle
  65+ 22B2 CF           		rst $08			;
  66+ 22B3 A4           		db F_READDIR		; read directory entry to buffer
  67+ 22B4              		;jp c, closeFilePrErr
  68+ 22B4 C9           		ret			; error check is done in caller function
  69+ 22B5              					; to detect end of directory
  70+ 22B5
  71+ 22B5 3A 79 31     fSeekDir	ld a, (fhandle)		; file handle
  72+ 22B8 CF           		rst $08			;
  73+ 22B9 A6           		db F_SEEKDIR		; set offset of directory
  74+ 22BA DA 71 27     		jp c, closeFilePrErr
  75+ 22BD C9           		ret
  76+ 22BE
  77+ 22BE 3A 79 31     fTellDir	ld a, (fhandle)		; file handle
  78+ 22C1 CF           		rst $08			;
  79+ 22C2 A5           		db F_TELLDIR		; get offset of directory
  80+ 22C3 DA 71 27     		jp c, closeFilePrErr
  81+ 22C6 C9           		ret
  82+ 22C7
  83+ 22C7 3A 79 31     fRewindDir	ld a, (fhandle)
  84+ 22CA CF           		rst $08
  85+ 22CB A7           		db F_REWINDDIR
  86+ 22CC DA 71 27     		jp c, closeFilePrErr
  87+ 22CF C9           		ret
  88+ 22D0
  89+ 22D0 3E 2A        fRename		ld a, CUR_DRIVE		; current drive
  90+ 22D2 CF           		rst $08
  91+ 22D3 B0           		db F_RENAME
  92+ 22D4 DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
  93+ 22D7 C9           		ret
  94+ 22D8
  95+ 22D8              //fUnlink	ld a, CUR_DRIVE		; current drive
  96+ 22D8              fUnlink1	; screen is saved allways in SYS_DRIVE
  97+ 22D8 CF           		rst $08
  98+ 22D9 AD           		db F_UNLINK		; open file
  99+ 22DA DA 78 27     		jp c, prError
 100+ 22DD C9           		ret
 101+ 22DE
 102+ 22DE 3E 2A        fChDir		ld a, CUR_DRIVE		; current drive
 103+ 22E0 CF           		rst $08			;
 104+ 22E1 A9           		db F_CHDIR		; change directory
 105+ 22E2 DA 78 27     		jp c, prError
 106+ 22E5 C9           		ret
 107+ 22E6
 108+ 22E6 3E 2A        fGetCWD		ld a, CUR_DRIVE		; current drive
 109+ 22E8 CF           		rst $08
 110+ 22E9 A8           		db F_GETCWD		; get current working directory
 111+ 22EA DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
 112+ 22ED C9           		ret
 113+ 22EE
 114+ 22EE              fExecCMD	//
 115+ 22EE              		//
 116+ 22EE              		//
 117+ 22EE 11 00 5B     		ld de, BACKED_UP_RAM	// $5b00
 118+ 22F1 01 80 00     		ld bc, 128		// Para poder llamar desde la pagina 5
 119+ 22F4 ED B0        		ldir			//
 120+ 22F6 21 00 5B     		ld hl, BACKED_UP_RAM	// $5b00
 121+ 22F9 CF           		rst $08
 122+ 22FA 8F           		db M_EXECCMD
 123+ 22FB DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
 124+ 22FE C9           		ret
 125+ 22FF
 126+ 22FF              fAutoLoad	; a = $00	LOAD "" (usually tapein)
 127+ 22FF              		; a > $00	HL = asciiz to file name, autoload from disk
 128+ 22FF              		; a = $fe	reset
 129+ 22FF              		; a = $fd	autoload from vdisk. If no boot, loads TR-DOS Navigator
 130+ 22FF              		; a = $fc	enter TR-DOS mode
 131+ 22FF CF           		rst $08
 132+ 2300 90           		db M_AUTOLOAD
 133+ 2301 DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
 134+ 2304 C9           		ret
 135+ 2305
 136+ 2305 AF           fGetSetDrv1	xor a			; a = 0 get current drive
 137+ 2306 CF           fGetSetDrv	rst $08
 138+ 2307 89           		DB M_GETSETDRV
 139+ 2308 DA 78 27     		jp c, prError
 140+ 230B C9           		ret
 141+ 230C
 142+ 230C              fEjectVDisk	; a = drive 0, 1, 2, 3
 143+ 230C              		; add a, a
 144+ 230C              		; add a, a
 145+ 230C              		; add a, a
 146+ 230C              		; or $60
 147+ 230C              		; a = virtual drive $60 (A), $68 (B), $70 (C), $78 (D)
 148+ 230C CF           		rst $08
 149+ 230D 85           		db $85			; EJECT VDISK
 150+ 230E              		;jr c, prError		; error if no disk attached, ignore it
 151+ 230E C9           		ret
 152+ 230F
 153+ 230F              fMountVDisk	; hl = pointer to asciiz TRD o SCL disk image
 154+ 230F              		; a = virtual drive $60 (A), $68 (B), $70 (C), $78 (D)
 155+ 230F 11 9F 31     		ld de, buffer		; BUFFER: returns 'Virtual Disk', 0
 156+ 2312 06 00        		ld b, 0
 157+ 2314 0E 2A        		ld c, CUR_DRIVE		; current drive
 158+ 2316 CF           		rst $08
 159+ 2317 80           		db DISK_STATUS		; MOUNT VDISK   ; $80
 160+ 2318 DA 78 27     		jp c, prError
 161+ 231B C9           		ret
 162+ 231C
 163+ 231C 06 00        fAttachTapeIn	ld b, 0			; in_open
 164+ 231E              					; Attaches .tap file
 165+ 231E              					; A=drive
 166+ 231E              					; HL=Pointer to null-terminated string containg path and/or filename
 167+ 231E 3E 2A        		ld a, CUR_DRIVE		; current drive
 168+ 2320 CF           		rst $08
 169+ 2321 8B           		db M_TAPEIN
 170+ 2322 DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
 171+ 2325 C9           		ret
 172+ 2326
 173+ 2326 06 01        fDetachTapeIn	ld b, 1			; in_close
 174+ 2328              					; No args, just closes and detaches .tap file
 175+ 2328 CF           		rst $08
 176+ 2329 8B           		db M_TAPEIN
 177+ 232A              		;jr c, prError		; error if no file attached, ignore it
 178+ 232A C9           		ret
 179+ 232B
 180+ 232B 06 00        fAttachTapeOut	ld b, 0			; out_open
 181+ 232D              					; Creates/opens .tap file for appending
 182+ 232D              					; A=drive
 183+ 232D              					; HL=Pointer to null-terminated string containg path and/or filename
 184+ 232D 3E 2A        		ld a, CUR_DRIVE		; current drive
 185+ 232F CF           		rst $08
 186+ 2330 8C           		db M_TAPEOUT
 187+ 2331 DA 78 27     		jp c, prError		; QUE SE HACE CON ESTO !!!
 188+ 2334 C9           		ret
 189+ 2335
 190+ 2335 06 01        fDetachTapeOut	ld b, 1			; out_close
 191+ 2337              					; No args, just closes and detaches .tap file
 192+ 2337 CF           		rst $08
 193+ 2338 8C           		db M_TAPEOUT
 194+ 2339              		;jr c, prError		; error if no file attached, ignore it
 195+ 2339 C9           		ret
 196+ 233A
# file closed: api.asm
 127  233A              		include "sharedfunctions.asm"
# file opened: sharedfunctions.asm
   1+ 233A              ;==============================================================================
   2+ 233A              ; Project: NMI.zdsp
   3+ 233A              ; File: sharedfunctions.asm
   4+ 233A              ; Date: 03/11/2022 19:30:44
   5+ 233A              ;
   6+ 233A              ; Created with zDevStudio - Z80 Development Studio.
   7+ 233A              ;
   8+ 233A              ;==============================================================================
   9+ 233A
  10+ 233A              ;==============================================================================
  11+ 233A              ; SPEAKER, KEYBOARD AND SCREEN FUNCTIONS
  12+ 233A              ;==============================================================================
  13+ 233A
  14+ 233A              ; -----------------------------------------------------------------------------
  15+ 233A              ; beep
  16+ 233A              ;
  17+ 233A              ; input:    -
  18+ 233A              ; output:   -
  19+ 233A              ; destroys: a, b
  20+ 233A              ; -----------------------------------------------------------------------------
  21+ 233A              ;
  22+ 233A 06 02        beep		ld b, 2
  23+ 233C C5           beep01		push bc
  24+ 233D 3E 10        		ld a, %00010000
  25+ 233F D3 FE        		out (0xfe), a
  26+ 2341 06 1E        		ld b, 30
  27+ 2343 10 FE        beep02		djnz beep02
  28+ 2345 3E 00        		ld a, %00000000
  29+ 2347 D3 FE        		out (0xfe), a
  30+ 2349 06 1E        		ld b, 30
  31+ 234B 10 FE        beep03		djnz beep03
  32+ 234D C1           		pop bc
  33+ 234E 10 EC        		djnz beep01
  34+ 2350 C9           		ret
  35+ 2351
  36+ 2351              ; -----------------------------------------------------------------------------
  37+ 2351              ; wait for key or mouse
  38+ 2351              ;
  39+ 2351              ; input:    -
  40+ 2351              ; output:   a - key pressed
  41+ 2351              ; destroys: af,bc,de,hl
  42+ 2351              ; -----------------------------------------------------------------------------
  43+ 2351              ;
  44+ 2351 3A 7D 31     waitKey		ld a, (prevJoy)
  45+ 2354 06 06        		ld b, 6
  46+ 2356 4F           _L1		ld c, a
  47+ 2357 C5           		push bc
  48+ 2358 CD D0 23     		call readJoy		; read joystick
  49+ 235B C1           		pop bc
  50+ 235C 32 7D 31     		ld (prevJoy), a
  51+ 235F B7           		or a
  52+ 2360 28 05        		jr z, _L2		; no joystroke
  53+ 2362 B9           		cp c
  54+ 2363 C0           		ret nz			; previous joystroke != actual joystroke
  55+ 2364 10 F0        		djnz _L1
  56+ 2366 C9           		ret
  57+ 2367 3A 7E 31     _L2		ld a, (prevKey)
  58+ 236A 06 06        		ld b, 6
  59+ 236C 4F           _L3		ld c, a
  60+ 236D C5           		push bc
  61+ 236E CD 7D 23     		call readKey		; read keyboard
  62+ 2371 C1           		pop bc
  63+ 2372 32 7E 31     		ld (prevKey), a
  64+ 2375 B7           		or a
  65+ 2376 28 D9        		jr z, waitKey		; no keystroke
  66+ 2378 B9           		cp c
  67+ 2379 C0           		ret nz			; previous keystroke != actual keystroke
  68+ 237A 10 F0        		djnz _L3
  69+ 237C C9           		ret
  70+ 237D
  71+ 237D              ; -----------------------------------------------------------------------------
  72+ 237D              ; Read key
  73+ 237D              ;
  74+ 237D              ; input:    -
  75+ 237D              ; output:   a - key pressed, 0 if none
  76+ 237D              ; destroys: af,bc,de,hl
  77+ 237D              ; -----------------------------------------------------------------------------
  78+ 237D              ;
  79+ 237D FB           readKey		ei
  80+ 237E 76           		halt
  81+ 237F F3           		di
  82+ 2380 CD B9 23     		call ckMods		; checks CAPS SHIFT and SYMBOL SHIFT
  83+ 2383              		;
  84+ 2383 21 F6 30     		ld hl, dbTbKeys
  85+ 2386 7E           nextRow		ld a, (hl)
  86+ 2387 B7           		or a
  87+ 2388 C8           		ret z
  88+ 2389 23           		inc hl
  89+ 238A 06 10        		ld b, %00010000		; b <- col to test
  90+ 238C DB FE        		in a, ($fe)
  91+ 238E 2F           		cpl
  92+ 238F 4F           		ld c, a
  93+ 2390 79           nextCol		ld a, c
  94+ 2391 A0           		and b
  95+ 2392 20 0B        		jr nz, pressed
  96+ 2394 23           ignCol		inc hl			; no key pressed
  97+ 2395 CB 18        		rr b
  98+ 2397 30 F7        		jr nc, nextCol		; next col to test
  99+ 2399              		;
 100+ 2399 11 0A 00     		ld de, 10		;15
 101+ 239C 19           		add hl, de
 102+ 239D 18 E7        		jr nextRow		; next half-row
 103+ 239F
 104+ 239F 7E           pressed		ld a, (hl)		; key pressed
 105+ 23A0 B7           		or a
 106+ 23A1 28 F1        		jr z, ignCol		; if CS o SS, ignore it
 107+ 23A3              		;
 108+ 23A3              		; Check modifiers
 109+ 23A3              		;
 110+ 23A3 46           		ld b, (hl)
 111+ 23A4              		;
 112+ 23A4 11 05 00     		ld de, 5
 113+ 23A7 19           		add hl, de
 114+ 23A8 3A 78 31     		ld a, (flagSS)		; SS pressed
 115+ 23AB B7           		or a
 116+ 23AC 28 01        		jr z, paso1
 117+ 23AE 46           		ld b, (hl)
 118+ 23AF 19           paso1		add hl, de
 119+ 23B0 3A 77 31     		ld a, (flagCS)		; CS pressed
 120+ 23B3 B7           		or a
 121+ 23B4 28 01        		jr z, paso2
 122+ 23B6 46           		ld b, (hl)
 123+ 23B7 78           paso2		ld a, b
 124+ 23B8              		;
 125+ 23B8 C9           		ret
 126+ 23B9
 127+ 23B9              ; ----------------------------------
 128+ 23B9              ; checks CAPS SHIFT and SYMBOL SHIFT
 129+ 23B9              ; ----------------------------------
 130+ 23B9              ;
 131+ 23B9 3E FE        ckMods		ld a, $fe
 132+ 23BB DB FE        		in a, ($fe)
 133+ 23BD 06 01        		ld b, %00000001
 134+ 23BF 2F           		cpl
 135+ 23C0 A0           		and b
 136+ 23C1 32 77 31     		ld (flagCS), a
 137+ 23C4
 138+ 23C4 3E 7F        		ld a, $7f
 139+ 23C6 DB FE        		in a, ($fe)
 140+ 23C8 06 02        		ld b, %00000010
 141+ 23CA 2F           		cpl
 142+ 23CB A0           		and b
 143+ 23CC 32 78 31     		ld (flagSS), a
 144+ 23CF
 145+ 23CF C9           		ret
 146+ 23D0
 147+ 23D0              ; -----------------------------------------------------------------------------
 148+ 23D0              ; Read joystick - based on Velesoft suggestions
 149+ 23D0              ;
 150+ 23D0              ; input:    -
 151+ 23D0              ; output:   a - key pressed, 0 if none
 152+ 23D0              ; destroys: af,bc,hl
 153+ 23D0              ; -----------------------------------------------------------------------------
 154+ 23D0              ;
 155+ 23D0 FB           readJoy		ei
 156+ 23D1 76           		halt
 157+ 23D2 F3           		di
 158+ 23D3 01 1F 00     		ld bc, $1f		; 31
 159+ 23D6 ED 78        		in a, (c)
 160+ 23D8 E6 1F        		and 31			; %00011111
 161+ 23DA 47           		ld b, a
 162+ 23DB E6 03        		and 3			; %00000011
 163+ 23DD FE 03        		cp 3
 164+ 23DF 28 30        		jr z, joy6		; detected incorrect state right+left
 165+ 23E1 78           		ld a, b
 166+ 23E2 E6 0C        		and 12			; %00001100
 167+ 23E4 FE 0C        		cp 12
 168+ 23E6 28 29        		jr z, joy6		; detected incorrect state up+down
 169+ 23E8 78           		ld a, b
 170+ 23E9              		;
 171+ 23E9              		; check directions and fire button
 172+ 23E9              		;
 173+ 23E9 FE 01        		cp 1
 174+ 23EB 20 04        		jr nz, joy1
 175+ 23ED 3A 09 32     		ld a, (kRight)
 176+ 23F0 C9           		ret
 177+ 23F1 FE 02        joy1		cp 2
 178+ 23F3 20 04        		jr nz, joy2
 179+ 23F5 3A 00 32     		ld a, (kLeft)
 180+ 23F8 C9           		ret
 181+ 23F9 FE 04        joy2		cp 4
 182+ 23FB 20 04        		jr nz, joy3
 183+ 23FD 3A 03 32     		ld a, (kDown)
 184+ 2400 C9           		ret
 185+ 2401 FE 08        joy3		cp 8
 186+ 2403 20 04        		jr nz, joy4
 187+ 2405 3A 06 32     		ld a, (kUp)
 188+ 2408 C9           		ret
 189+ 2409 FE 10        joy4		cp 16
 190+ 240B 20 0A        		jr nz, joy5
 191+ 240D 3A 0C 32     		ld a, (kEnter)
 192+ 2410 C9           		ret
 193+ 2411              joy6		;
 194+ 2411              		; disable joystick, xor a : ret
 195+ 2411              		;
 196+ 2411 21 AF C9     		ld hl, $c9af
 197+ 2414 22 D0 23     		ld (readJoy), hl
 198+ 2417              joy5		;
 199+ 2417              		; no key pressed
 200+ 2417              		;
 201+ 2417 AF           		xor a
 202+ 2418 C9           		ret
 203+ 2419
 204+ 2419              ; -----------------------------------------------------------------------------
 205+ 2419              ; Waits 26*(hl-1)+27 T states
 206+ 2419              ;
 207+ 2419              ; 3,55 Mhz => T state = 281,7 nseg
 208+ 2419              ; n = 0     => ~480 mseg
 209+ 2419              ; n = 32768 => ~240 mseg
 210+ 2419              ; n = 24576 => ~180 mseg
 211+ 2419              ; n = 16384 => ~120 mseg
 212+ 2419              ;
 213+ 2419              ; input:    -
 214+ 2419              ; output:   -
 215+ 2419              ; destroys: af,de
 216+ 2419              ; -----------------------------------------------------------------------------
 217+ 2419              ;
 218+ 2419              ;wait    ld      de, 8192
 219+ 2419              ;waitLp  dec     de
 220+ 2419              ;        ld      a, d
 221+ 2419              ;        or      e
 222+ 2419              ;        jr      nz, waitLp
 223+ 2419              ;        ret
 224+ 2419
 225+ 2419              ; -----------------------------------------------------------------------------
 226+ 2419              ; Waits ~ b * 20 mseg
 227+ 2419              ;
 228+ 2419              ; input:    -
 229+ 2419              ; output:   -
 230+ 2419              ; destroys: b
 231+ 2419              ; -----------------------------------------------------------------------------
 232+ 2419              ;
 233+ 2419 06 0C        wait		ld b, 12
 234+ 241B FB           waitL0		ei
 235+ 241C 76           		halt
 236+ 241D F3           		di
 237+ 241E 10 FB        		djnz waitL0
 238+ 2420 C9           		ret
 239+ 2421
 240+ 2421              ; -----------------------------------------------------------------------------
 241+ 2421              ; clear screen lines
 242+ 2421              ;
 243+ 2421              ; input:    a = attribute
 244+ 2421              ;           b = number of lines
 245+ 2421              ;           c = from line
 246+ 2421              ; output:   -
 247+ 2421              ; destroys: af,bc,de,hl,af'
 248+ 2421              ; -----------------------------------------------------------------------------
 249+ 2421              ;
 250+ 2421              ;    7  6  5  4  3  2  1  0
 251+ 2421              ;    F  B P2 P1 P0 I2 I1 I0
 252+ 2421              ;
 253+ 2421              ;    F sets the attribute FLASH mode
 254+ 2421              ;    B sets the attribute BRIGHTNESS mode
 255+ 2421              ;    P2 to P0 is the PAPER colour
 256+ 2421              ;    I2 to I0 is the INK colour
 257+ 2421              ;
 258+ 2421              ;    0 black
 259+ 2421              ;    1 blue
 260+ 2421              ;    2 red
 261+ 2421              ;    3 magenta
 262+ 2421              ;    4 green
 263+ 2421              ;    5 cyan
 264+ 2421              ;    6 yellow
 265+ 2421              ;    7 white
 266+ 2421              ;
 267+ 2421              ;             H                         L
 268+ 2421              ;  15 14 13 12 11 10  9  8    7  6  5  4  3  2  1  0
 269+ 2421              ;   0  1  0  1  1  0 Y7 Y6   Y5 Y4 Y3 X7 X6 X5 X4 X3    attr
 270+ 2421              ;   0  1  0 Y7 Y6 Y2 Y1 Y0   Y5 Y4 Y3 X7 X6 X5 X4 X3    bitmap
 271+ 2421              ;
 272+ 2421              ; input:
 273+ 2421              ;
 274+ 2421              ;  A = attr
 275+ 2421              ;  B = number of lines to clear
 276+ 2421              ;  C = start line
 277+ 2421              ;
 278+ 2421              ;      0 0 0 Y7 Y6 Y5 Y4 Y3   (0 to 23)
 279+ 2421              ;      0 0 0  0  0  0  0  0   (0)
 280+ 2421              ;      0 0 0  1  0  1  1  1   (23)
 281+ 2421              ;
 282+ 2421 08           clrScr		ex af, af'		; guardamos atributos
 283+ 2422              		;
 284+ 2422              		; attr
 285+ 2422              		;
 286+ 2422 79           		ld a, c			; Calculate Y7, Y6
 287+ 2423 0F           		rrca			; Shift to position
 288+ 2424 0F           		rrca
 289+ 2425 0F           		rrca
 290+ 2426 E6 03        		and %00000011		; Mask out unwanted bits
 291+ 2428 F6 58        		or %01011000		; Set attr address of screen
 292+ 242A 67           		ld h, a			; Store in H
 293+ 242B 57           		ld d, a
 294+ 242C 79           		ld a, c
 295+ 242D 0F           		rrca			; Shift to position
 296+ 242E 0F           		rrca
 297+ 242F 0F           		rrca
 298+ 2430 E6 E0        		and %11100000		; Calculate Y5, Y4, Y3
 299+ 2432 6F           		ld l, a			; Store in L
 300+ 2433 5F           		ld e, a
 301+ 2434 1C           		inc e
 302+ 2435              		;
 303+ 2435 08           		ex af, af'		; recuperamos atributos
 304+ 2436 C5           		push bc			; guardamos BC
 305+ 2437              		;
 306+ 2437 77           		ld (hl), a
 307+ 2438 01 1F 00     		ld bc, 32-1
 308+ 243B ED B0        		ldir
 309+ 243D              		;
 310+ 243D C1           		pop bc			; recuperamos BC
 311+ 243E 08           		ex af, af'		; guardamos atributos
 312+ 243F              		;
 313+ 243F              		; bitmap
 314+ 243F              		;
 315+ 243F 79           		ld a, c			; Calculate Y7, Y6
 316+ 2440 E6 18        		and %00011000		; Mask out unwanted bits
 317+ 2442 F6 40        		or %01000000		; Set base address of screen
 318+ 2444 67           		ld h, a			; Store in H
 319+ 2445 57           		ld d, a
 320+ 2446 79           		ld a, c
 321+ 2447 0F           		rrca			; Shift to position
 322+ 2448 0F           		rrca
 323+ 2449 0F           		rrca
 324+ 244A E6 E0        		and %11100000		; Calculate Y5, Y4, Y3
 325+ 244C 6F           		ld l, a			; Store in L
 326+ 244D 5F           		ld e, a
 327+ 244E 1C           		inc e
 328+ 244F              		;
 329+ 244F C5           		push bc			; guardamos BC
 330+ 2450              		;
 331+ 2450 AF           		xor a
 332+ 2451 06 08        		ld b, 8			; B pixel rows to clear
 333+ 2453 E5           clScrL0		push hl
 334+ 2454 D5           		push de
 335+ 2455 C5           		push bc
 336+ 2456 77           		ld (hl), a
 337+ 2457 01 1F 00     		ld bc, 32-1
 338+ 245A ED B0        		ldir
 339+ 245C C1           		pop bc
 340+ 245D D1           		pop de
 341+ 245E E1           		pop hl
 342+ 245F 24           		inc h
 343+ 2460 14           		inc d
 344+ 2461 10 F0        		djnz clScrL0
 345+ 2463              		;
 346+ 2463 08           		ex af, af'		; recuperamos atributos
 347+ 2464 C1           		pop bc			; recuperamos BC
 348+ 2465              		;
 349+ 2465 0C           		inc c
 350+ 2466 10 B9        		djnz clrScr
 351+ 2468              		;
 352+ 2468 C9           		ret
 353+ 2469
 354+ 2469              ; -----------------------------------------------------------------------------
 355+ 2469              ; Converts an unsigned int to an 6 char ASCII string
 356+ 2469              ; Skip '0' on the left
 357+ 2469              ;
 358+ 2469              ; input:    hl = unigned int to convert
 359+ 2469              ;           de = pointer to ASCII string
 360+ 2469              ; output:   c:hl = 6 digits BCD number
 361+ 2469              ;           de = pointer to end of string
 362+ 2469              ; destroys: af,bc,de,hl
 363+ 2469              ; -----------------------------------------------------------------------------
 364+ 2469 D5           _utoa		push de
 365+ 246A 01 00 10     		ld bc, 16*256+0		; handle 16 bits, one bit per iteration
 366+ 246D 11 00 00     		ld de, 0
 367+ 2470              cvtLoop
 368+ 2470 29           		add hl, hl
 369+ 2471 7B           		ld a, e
 370+ 2472 8F           		adc a, a
 371+ 2473 27           		daa
 372+ 2474 5F           		ld e, a
 373+ 2475 7A           		ld a, d
 374+ 2476 8F           		adc a, a
 375+ 2477 27           		daa
 376+ 2478 57           		ld d, a
 377+ 2479 79           		ld a, c
 378+ 247A 8F           		adc a, a
 379+ 247B 27           		daa
 380+ 247C 4F           		ld c, a
 381+ 247D 10 F1        		djnz cvtLoop
 382+ 247F EB           		ex de, hl		; C:HL = numero BCD de 6 digitos
 383+ 2480
 384+ 2480              bcd2hex
 385+ 2480 D1           		pop de
 386+ 2481              		//ld de, utoaBuf	//
 387+ 2481 D5           		push de
 388+ 2482              		//
 389+ 2482 79           		ld a, c			// skip left zeroes
 390+ 2483 E6 F0        		and $f0
 391+ 2485 20 16        		jr nz, _1_
 392+ 2487 79           		ld a, c
 393+ 2488 E6 0F        		and $0f
 394+ 248A 20 15        		jr nz, _2_
 395+ 248C 7C           		ld a, h
 396+ 248D E6 F0        		and $f0
 397+ 248F 20 14        		jr nz, _3_
 398+ 2491 7C           		ld a, h
 399+ 2492 E6 0F        		and $0f
 400+ 2494 20 13        		jr nz, _4_
 401+ 2496 7D           		ld a, l
 402+ 2497 E6 F0        		and $f0
 403+ 2499 20 12        		jr nz, _5_
 404+ 249B 18 13        		jr _6_
 405+ 249D
 406+ 249D CD B8 24     _1_		call cvtUpperNibble
 407+ 24A0 79           		ld a, c
 408+ 24A1 CD BC 24     _2_		call cvtLowerNibble
 409+ 24A4 7C           		ld a, h
 410+ 24A5 CD B8 24     _3_		call cvtUpperNibble
 411+ 24A8 7C           		ld a, h
 412+ 24A9 CD BC 24     _4_		call cvtLowerNibble
 413+ 24AC 7D           		ld a, l
 414+ 24AD CD B8 24     _5_		call cvtUpperNibble
 415+ 24B0 7D           _6_		ld a, l
 416+ 24B1 CD BC 24     		call cvtLowerNibble
 417+ 24B4 AF           		xor a
 418+ 24B5 12           		ld (de), a
 419+ 24B6 E1           		pop hl
 420+ 24B7              		//jr prtDec		//
 421+ 24B7 C9           		ret
 422+ 24B8
 423+ 24B8              cvtUpperNibble
 424+ 24B8 1F           		rra			; move upper nibble into lower nibble
 425+ 24B9 1F           		rra
 426+ 24BA 1F           		rra
 427+ 24BB 1F           		rra
 428+ 24BC              cvtLowerNibble
 429+ 24BC E6 0F        		and $0F			; isolate lower nibble
 430+ 24BE F6 30        		or %00110000		; convert to ASCII
 431+ 24C0 12           		ld (de), a
 432+ 24C1 13           		inc de
 433+ 24C2 C9           		ret
 434+ 24C3
 435+ 24C3 11 7F 31     utoa		ld de, utoaBuf
 436+ 24C6 CD 69 24     		call _utoa
 437+ 24C9              		//jr prStr
 438+ 24C9
 439+ 24C9              ; -----------------------------------------------------------------------------
 440+ 24C9              ; Print a asciiz string at cursor position
 441+ 24C9              ; Updates cursor coordinates
 442+ 24C9              ;
 443+ 24C9              ; input:    hl = pointer to asciiz string
 444+ 24C9              ; output:   hl = pointer to end of string
 445+ 24C9              ; destroys: af,bc,de,hl,af'
 446+ 24C9              ; -----------------------------------------------------------------------------
 447+ 24C9 7E           prStr		ld a, (hl)
 448+ 24CA 47           		ld b, a
 449+ 24CB 3A 7A 31     		ld a, (flgAT)
 450+ 24CE A7           		and a
 451+ 24CF 78           		ld a, b
 452+ 24D0 20 02        		jr nz, notChk
 453+ 24D2 B7           		or a
 454+ 24D3 C8           		ret z
 455+ 24D4 E5           notChk		push hl
 456+ 24D5 CD DC 24     		call prChr
 457+ 24D8 E1           		pop hl
 458+ 24D9 23           		inc hl
 459+ 24DA 18 ED        		jr prStr
 460+ 24DC
 461+ 24DC              ; -----------------------------------------------------------------------------
 462+ 24DC              ; Print a character at cursor
 463+ 24DC              ; Updates cursor coordinates
 464+ 24DC              ;
 465+ 24DC              ; The source code for 64 column printing was originally provided by Andrew Owen
 466+ 24DC              ; in a thread on WoSF.
 467+ 24DC              ;
 468+ 24DC              ; Based on code by Tony Samuels from Your Spectrum issue 13, April 1985.
 469+ 24DC              ; A channel wrapper for the 64-column display driver.
 470+ 24DC              ;
 471+ 24DC              ; input:    a = char to print
 472+ 24DC              ; output:   -
 473+ 24DC              ; destroys: af,bc,de,hl,af'
 474+ 24DC              ; -----------------------------------------------------------------------------
 475+ 24DC
 476+ 24DC 47           prChr		ld b,a			; save character
 477+ 24DD 3A 7A 31     		ld a,(flgAT)		; value of AT flag
 478+ 24E0 A7           		and a			; test against zero
 479+ 24E1 20 0B        		jr nz,getrow		; jump if not
 480+ 24E3 78           		ld a,b			; restore character
 481+ 24E4
 482+ 24E4 FE 16        atchk		cp $16			; test for AT
 483+ 24E6 20 29        		jr nz,crchk		; if not test for CR
 484+ 24E8 3E FF        		ld a,$ff		; set the AT flag
 485+ 24EA 32 7A 31     		ld (flgAT),a		; next character will be row
 486+ 24ED C9           		ret			; return
 487+ 24EE
 488+ 24EE FE FE        getrow		cp $fe			; test AT flag
 489+ 24F0 28 0D        		jr z,getcol		; jump if setting col
 490+ 24F2 78           		ld a,b			; restore character
 491+ 24F3 FE 18        		cp $18			; greater or equal than 24?
 492+ 24F5 30 15        		jr nc,err_b		; error if so
 493+ 24F7
 494+ 24F7 32 7B 31     		ld (row),a		; store it in row
 495+ 24FA 21 7A 31     		ld hl,flgAT		; AT flag
 496+ 24FD 35           		dec (hl)		; indicates next character is col
 497+ 24FE C9           		ret			; return
 498+ 24FF
 499+ 24FF 78           getcol		ld a,b			; restore character
 500+ 2500 FE 40        		cp $40			; greater or equal than 64?
 501+ 2502 30 08        		jr nc,err_b		; error if so
 502+ 2504 32 7C 31     		ld (col),a		; store it in col
 503+ 2507 AF           		xor a			; set a to zero
 504+ 2508 32 7A 31     		ld (flgAT),a		; store in AT flag
 505+ 250B C9           		ret			; return
 506+ 250C
 507+ 250C AF           err_b		xor a			; set a to zero
 508+ 250D 32 7A 31     		ld (flgAT),a		; clear AT flag
 509+ 2510              		;rst	08h		;
 510+ 2510              		;defb	$0a		; ERROR, PENSAR QUE HACER AQUI
 511+ 2510 C9           		ret
 512+ 2511
 513+ 2511 FE 0D        crchk		cp $0d			; check for return
 514+ 2513 28 15        		jr z,do_cr		; to carriage return if so
 515+ 2515              		;cp      $84             ; greater or equal than 132?
 516+ 2515 FE 80        		cp $80			; greater or equal than 128?
 517+ 2517 30 04        		jr nc,prErr		;
 518+ 2519 FE 20        		cp $20			; greater or equal than 32?
 519+ 251B 30 02        		jr nc,prOk		;
 520+ 251D              prErr		;ld      a,$80
 521+ 251D 3E 3F        		ld a, '?'
 522+ 251F CD 3D 25     prOk		call pr_64		; print it
 523+ 2522
 524+ 2522 21 7C 31     		ld hl,col		; increment
 525+ 2525 34           		inc (hl)		; the column
 526+ 2526 7E           		ld a,(hl)		;
 527+ 2527
 528+ 2527 FE 40        		cp $40			; column 64?
 529+ 2529 C0           		ret nz			;
 530+ 252A
 531+ 252A AF           do_cr		xor a			; set A to zero
 532+ 252B 32 7C 31     		ld (col),a		; reset column
 533+ 252E 3A 7B 31     		ld a,(row)		; get the row
 534+ 2531 3C           		inc a			; increment it
 535+ 2532 FE 18        		cp $18			; row 24?
 536+ 2534 28 04        		jr z,wrap		;
 537+ 2536
 538+ 2536 32 7B 31     zend		ld (row),a		; write it back
 539+ 2539 C9           		ret
 540+ 253A
 541+ 253A AF           wrap		xor a			;
 542+ 253B 18 F9        		jr zend			;
 543+ 253D
 544+ 253D              ; ------------------------
 545+ 253D              ; 64 COLUMN DISPLAY DRIVER
 546+ 253D              ; ------------------------
 547+ 253D
 548+ 253D B7           pr_64		or a			; clear C flag
 549+ 253E 1F           		rra			; divide by two with remainder in carry flag
 550+ 253F
 551+ 253F 26 00        		ld h,$00		; clear H
 552+ 2541 6F           		ld l,a			; CHAR to low byte of HL
 553+ 2542
 554+ 2542 08           		ex af,af'		; save the carry flag
 555+ 2543
 556+ 2543 E5           		push hl			;
 557+ 2544 D1           		pop de			;
 558+ 2545 29           		add hl,hl		; multiply
 559+ 2546 19           		add hl,de		; by
 560+ 2547 29           		add hl,hl		; seven
 561+ 2548 19           		add hl,de		; character map in FONT
 562+ 2549 11 36 2F     		ld de,dbTbFont-32*7/2	; offset to FONT
 563+ 254C 19           		add hl,de		; HL holds address of first byte of
 564+ 254D E5           		push hl			; save font address
 565+ 254E
 566+ 254E              ; convert the row to the base screen address
 567+ 254E
 568+ 254E 3A 7B 31     		ld a,(row)		; get the row
 569+ 2551 47           		ld b,a			; save it
 570+ 2552 E6 18        		and $18			; mask off bit 3-4
 571+ 2554 57           		ld d,a			; store high byte of offset in D
 572+ 2555 78           		ld a,b			; retrieve it
 573+ 2556 E6 07        		and $07			; mask off bit 0-2
 574+ 2558 07           		rlca			; shift
 575+ 2559 07           		rlca			; five
 576+ 255A 07           		rlca			; bits
 577+ 255B 07           		rlca			; to the
 578+ 255C 07           		rlca			; left
 579+ 255D 5F           		ld e,a			; store low byte of offset in E
 580+ 255E
 581+ 255E              ; add the column
 582+ 255E
 583+ 255E 3A 7C 31     		ld a,(col)		; get the column
 584+ 2561 1F           		rra			; divide by two with remainder in carry flag
 585+ 2562 F5           		push af			; store the carry flag
 586+ 2563
 587+ 2563 26 40        		ld h,$40		; base location
 588+ 2565 6F           		ld l,a			; plus column offset
 589+ 2566
 590+ 2566 19           		add hl,de		; add the offset
 591+ 2567
 592+ 2567 EB           		ex de,hl		; put the result back in DE
 593+ 2568
 594+ 2568 AF           		xor a			; the upper bits of char are always 0
 595+ 2569 12           		ld (de),a		; set to 0 and reduce font from 8x4 to
 596+ 256A 14           		inc d			; 7x4
 597+ 256B
 598+ 256B              ; HL now points to the location of the first byte of char data in FONT_1
 599+ 256B              ; DE points to the first screen byte in SCREEN_1
 600+ 256B              ; C holds the offset to the routine
 601+ 256B
 602+ 256B F1           		pop af			; restore column carry flag
 603+ 256C E1           		pop hl			; restore the font address
 604+ 256D
 605+ 256D 30 05        		jr nc,odd_col		; jump if odd column
 606+ 256F
 607+ 256F              even_col
 608+ 256F 08           		ex af,af'		; restore char position carry flag
 609+ 2570 38 07        		jr c,l_on_l		; left char on left col
 610+ 2572 18 3C        		jr r_on_l		; right char on left col
 611+ 2574
 612+ 2574              odd_col
 613+ 2574 08           		ex af,af'		; restore char position carry flag
 614+ 2575 30 13        		jr nc,r_on_r		; right char on right col
 615+ 2577 18 22        		jr l_on_r		; left char on right col
 616+ 2579
 617+ 2579              ; -------------------------------
 618+ 2579              ; WRITE A CHARACTER TO THE SCREEN
 619+ 2579              ; -------------------------------
 620+ 2579              ;
 621+ 2579              ; There are four separate routines
 622+ 2579
 623+ 2579              ; HL points to the first byte of a character in FONT
 624+ 2579              ; DE points to the first byte of the screen address
 625+ 2579
 626+ 2579              ; left nibble on left hand side
 627+ 2579
 628+ 2579 0E 07        l_on_l		ld c,$07		; 7 bytes to write
 629+ 257B 1A           ll_lp		ld a,(de)		; read byte at destination
 630+ 257C E6 F0        		and $f0			; mask area used by new character
 631+ 257E 47           		ld b,a			; store in b
 632+ 257F 7E           		ld a,(hl)		; get byte of font
 633+ 2580 E6 0F        		and $0f			; mask off unused half
 634+ 2582 B0           		or b			; combine with background
 635+ 2583 12           		ld (de),a		; write it back
 636+ 2584 14           		inc d			; point to next screen location
 637+ 2585 23           		inc hl			; point to next font data
 638+ 2586 0D           		dec c			; adjust counter
 639+ 2587 20 F2        		jr nz,ll_lp		; loop 7 times
 640+ 2589 C9           		ret			; done
 641+ 258A
 642+ 258A              ; right nibble on right hand side
 643+ 258A
 644+ 258A 0E 07        r_on_r		ld c,$07		; 7 bytes to write
 645+ 258C 1A           rr_lp		ld a,(de)		; read byte at destination
 646+ 258D E6 0F        		and $0f			; mask area used by new character
 647+ 258F 47           		ld b,a			; store in b
 648+ 2590 7E           		ld a,(hl)		; get byte of font
 649+ 2591 E6 F0        		and $f0			; mask off unused half
 650+ 2593 B0           		or b			; combine with background
 651+ 2594 12           		ld (de),a		; write it back
 652+ 2595 14           		inc d			; point to next screen location
 653+ 2596 23           		inc hl			; point to next font data
 654+ 2597 0D           		dec c			; adjust counter
 655+ 2598 20 F2        		jr nz,rr_lp		; loop 7 times
 656+ 259A C9           		ret			; done
 657+ 259B
 658+ 259B              ; left nibble on right hand side
 659+ 259B
 660+ 259B 0E 07        l_on_r		ld c,$07		; 7 bytes to write
 661+ 259D 1A           lr_lp		ld a,(de)		; read byte at destination
 662+ 259E E6 0F        		and $0f			; mask area used by new character
 663+ 25A0 47           		ld b,a			; store in b
 664+ 25A1 7E           		ld a,(hl)		; get byte of font
 665+ 25A2 0F           		rrca			; shift right
 666+ 25A3 0F           		rrca			; four bits
 667+ 25A4 0F           		rrca			; leaving 7-4
 668+ 25A5 0F           		rrca			; empty
 669+ 25A6 E6 F0        		and $f0			;
 670+ 25A8 B0           		or b			; combine with background
 671+ 25A9 12           		ld (de),a		; write it back
 672+ 25AA 14           		inc d			; point to next screen location
 673+ 25AB 23           		inc hl			; point to next font data
 674+ 25AC 0D           		dec c			; adjust counter
 675+ 25AD 20 EE        		jr nz,lr_lp		; loop 7 times
 676+ 25AF C9           		ret			; done
 677+ 25B0
 678+ 25B0              ; right nibble on left hand side
 679+ 25B0
 680+ 25B0 0E 07        r_on_l		ld c,$07		; 7 bytes to write
 681+ 25B2 1A           rl_lp		ld a,(de)		; read byte at destination
 682+ 25B3 E6 F0        		and $f0			; mask area used by new character
 683+ 25B5 47           		ld b,a			; store in b
 684+ 25B6 7E           		ld a,(hl)		; get byte of font
 685+ 25B7 07           		rlca			; shift left
 686+ 25B8 07           		rlca			; four bits
 687+ 25B9 07           		rlca			; leaving 3-0
 688+ 25BA 07           		rlca			; empty
 689+ 25BB E6 0F        		and $0f			;
 690+ 25BD B0           		or b			; combine with background
 691+ 25BE 12           		ld (de),a		; write it back
 692+ 25BF 14           		inc d			; point to next screen location
 693+ 25C0 23           		inc hl			; point to next font data
 694+ 25C1 0D           		dec c			; adjust counter
 695+ 25C2 20 EE        		jr nz,rl_lp		; loop 7 times
 696+ 25C4 C9           		ret			; done
 697+ 25C5
# file closed: sharedfunctions.asm
 128  25C5              		include "functions.asm"
# file opened: functions.asm
   1+ 25C5              ;==============================================================================
   2+ 25C5              ; Project: NMI.zdsp
   3+ 25C5              ; File: functions.asm
   4+ 25C5              ; Date: 29/08/2017 13:25:58
   5+ 25C5              ;
   6+ 25C5              ; Created with zDevStudio - Z80 Development Studio.
   7+ 25C5              ;
   8+ 25C5              ;==============================================================================
   9+ 25C5
  10+ 25C5 ~            /* ----------------------------------------------------------------------------
  11+ 25C5 ~            	-----
  12+ 25C5 ~            	NOTES
  13+ 25C5 ~            	-----
  14+ 25C5 ~            	725 754		rst $30 DB $0a/$0b
  15+ 25C5 ~            	2650		rst $08 DB F_OPEN 	check if file exists
  16+ 25C5 ~            	1038 2766	rst $08 DB M_GETSETDRV	check if drive is valid
  17+ 25C5 ~            	2016 2023 2027	rst $08			load old NMI handler
  18+ 25C5 ~
  19+ 25C5 ~            ---------------------------------------------------------------------------- */
  20+ 25C5
  21+ 25C5              ;==============================================================================
  22+ 25C5              ; COMMON FUNCTIONS
  23+ 25C5              ;==============================================================================
  24+ 25C5
  25+ 25C5              ; -------------------
  26+ 25C5              ; save screen to disk
  27+ 25C5              ; -------------------
  28+ 25C5              ;
  29+ 25C5 3A 89 35     saveScreen	ld a, (savRAM)
  30+ 25C8 B7           		or a
  31+ 25C9 20 09        		jr nz, SavetoFile
  32+ 25CB
  33+ 25CB 21 00 40     		ld hl, 16384
  34+ 25CE 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  35+ 25D1 F7           		rst $30
  36+ 25D2 0A           		db $0a
  37+ 25D3 D0           		ret nc
  38+ 25D4
  39+ 25D4 21 10 35     SavetoFile	ld hl, dbFnBackupFile	; asciiz string containing path and/or filename
  40+ 25D7 06 0E        		ld b, FA_CREATE_AL|FA_WRITE
  41+ 25D9              					; create if not exists, else open and truncate
  42+ 25D9              					; write access
  43+ 25D9 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  44+ 25DB CD 6D 22     		call fOpen1
  45+ 25DE
  46+ 25DE 21 00 40     		ld hl, 16384		; source
  47+ 25E1 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  48+ 25E4 CD 7F 22     		call fWrite
  49+ 25E7
  50+ 25E7 CD 93 22     		call fClose
  51+ 25EA
  52+ 25EA C9           		ret
  53+ 25EB
  54+ 25EB              ; ------------------------
  55+ 25EB              ; restore screen from disk
  56+ 25EB              ; ------------------------
  57+ 25EB              ;
  58+ 25EB 3A 89 35     restoreScreen	ld a, (savRAM)
  59+ 25EE B7           		or a
  60+ 25EF 20 09        		jr nz, toFile
  61+ 25F1
  62+ 25F1 11 00 40     		ld de, 16384
  63+ 25F4 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  64+ 25F7 F7           		rst $30
  65+ 25F8 0B           		db $0b
  66+ 25F9 C9           		ret
  67+ 25FA
  68+ 25FA 21 10 35     toFile		ld hl, dbFnBackupFile	; asciiz string containg path and/or filename
  69+ 25FD 06 01        		ld b, FA_OPEN_EX|FA_READ
  70+ 25FF              					; open if exists, else error
  71+ 25FF              					; read access
  72+ 25FF 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  73+ 2601 CD 6D 22     		call fOpen1
  74+ 2604
  75+ 2604 21 00 40     		ld hl, 16384		; dest
  76+ 2607 01 00 1C     		ld bc, 7*1024		; 6144+768 ; max size 7*1024
  77+ 260A CD 76 22     		call fRead
  78+ 260D
  79+ 260D
  80+ 260D CD 93 22     		call fClose
  81+ 2610
  82+ 2610 C9           		ret
  83+ 2611
  84+ 2611              ; -----------------------
  85+ 2611              ; delete screen from disk
  86+ 2611              ; -----------------------
  87+ 2611              ;
  88+ 2611 3A 89 35     deleteScreen	ld a, (savRAM)
  89+ 2614 B7           		or a
  90+ 2615 C8           		ret z
  91+ 2616
  92+ 2616 21 10 35     		ld hl, dbFnBackupFile	; null-terminated string containg path and/or filename
  93+ 2619 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  94+ 261B CD D8 22     		call fUnlink1
  95+ 261E C9           		ret
  96+ 261F
  97+ 261F              ; -------------------------------------
  98+ 261F              ; converts drive number to 'hd0' format
  99+ 261F              ; -------------------------------------
 100+ 261F F5           convDrv		push af
 101+ 2620 E6 F8        		and %11111000
 102+ 2622 0F           		rrca
 103+ 2623 0F           		rrca
 104+ 2624 0F           		rrca
 105+ 2625 C6 60        		add a, 'a'-1
 106+ 2627 77           		ld (hl), a
 107+ 2628 23           		inc hl
 108+ 2629 23           		inc hl
 109+ 262A F1           		pop af
 110+ 262B E6 07        		and %00000111
 111+ 262D C6 30        		add a, '0'
 112+ 262F 77           		ld (hl), a
 113+ 2630 C9           		ret
 114+ 2631
 115+ 2631              ; -----------------------------
 116+ 2631              ; get current working directory
 117+ 2631              ; -----------------------------
 118+ 2631              ;
 119+ 2631              getCWD		;
 120+ 2631              		; get current drive
 121+ 2631              		;
 122+ 2631 CD 05 23     		call fGetSetDrv1	; get current drive
 123+ 2634
 124+ 2634              		;
 125+ 2634              		; pretty printer for drive
 126+ 2634              		;
 127+ 2634 21 01 34     		ld hl, drvName
 128+ 2637 CD 1F 26     		call convDrv
 129+ 263A
 130+ 263A              		;
 131+ 263A              		; get CWD
 132+ 263A              		;
 133+ 263A 21 6B 37     		ld hl, dbStrPathName
 134+ 263D CD E6 22     		call fGetCWD
 135+ 2640
 136+ 2640              		;
 137+ 2640              		; pretty printer for CWD
 138+ 2640              		;
 139+ 2640 AF           		xor a
 140+ 2641 32 83 35     		ld (flgROOT), a		; reset some flags
 141+ 2644 01 80 00     		ld bc, 128
 142+ 2647 21 6C 37     		ld hl, dbStrPathName+1	; skip initial '/'
 143+ 264A ED B1        		cpir			; search end of string
 144+ 264C 3E 80        		ld a, 128
 145+ 264E 91           		sub c			; calculates string length
 146+ 264F FE 02        		cp 2			; greater or equal than 2 cols -> greater than 1 cols
 147+ 2651 30 03        		jr nc, notRoot		; if less than 1 -> root directory
 148+ 2653 32 83 35     		ld (flgROOT), a
 149+ 2656
 150+ 2656 FE 3A        notRoot		cp 58			; 64 minus 2 (margins) minus 5 ('hd0:/') plus 2 (cpir) = 59 cols
 151+ 2658 38 02        		jr c, itsOk		; less than 59 cols -> less or equal than 58 cols
 152+ 265A
 153+ 265A 3E 3A        		ld a, 58		; crop string to 58 cols
 154+ 265C
 155+ 265C B7           itsOk		or a			; clear CF
 156+ 265D 16 00        		ld d, 0
 157+ 265F 5F           		ld e, a
 158+ 2660 ED 52        		sbc hl, de		; set hl to the beginning of string
 159+ 2662
 160+ 2662 FE 3A        		cp 58
 161+ 2664 20 12        		jr nz, noCrop
 162+ 2666 36 2E        		ld (hl), '.'
 163+ 2668 23           		inc hl
 164+ 2669 36 2E        		ld (hl), '.'
 165+ 266B 23           		inc hl
 166+ 266C 36 2E        		ld (hl), '.'
 167+ 266E 2B           		dec hl
 168+ 266F 2B           		dec hl			; set hl to the beginning of string
 169+ 2670              		;
 170+ 2670              		; crop string
 171+ 2670              		;
 172+ 2670 11 6C 37     		ld de, dbStrPathName+1
 173+ 2673 06 00        		ld b, 0
 174+ 2675 4F           		ld c, a
 175+ 2676 ED B0        		ldir
 176+ 2678
 177+ 2678 3C           noCrop		inc a
 178+ 2679 32 2D 37     		ld (strLen), a
 179+ 267C C9           		ret
 180+ 267D
 181+ 267D              ; --------------------------------------
 182+ 267D              ; copy drive and CWD to top message area
 183+ 267D              ; --------------------------------------
 184+ 267D              ;
 185+ 267D 21 01 34     copyCWD		ld hl, drvName
 186+ 2680 11 5B 32     		ld de, msgDrv
 187+ 2683 01 04 00     		ld bc, 4
 188+ 2686 ED B0        		ldir
 189+ 2688 21 6B 37     		ld hl, dbStrPathName
 190+ 268B 3A 2D 37     		ld a, (strLen)
 191+ 268E 06 00        		ld b, 0
 192+ 2690 4F           		ld c, a
 193+ 2691 ED B0        		ldir
 194+ 2693              		;
 195+ 2693 C9           		ret
 196+ 2694
 197+ 2694              ; ------------------------------------------
 198+ 2694              ; compare old working directory with current
 199+ 2694              ; ------------------------------------------
 200+ 2694              ;
 201+ 2694 21 01 34     testCWD		ld hl, drvName
 202+ 2697 11 5B 32     		ld de, msgDrv
 203+ 269A 06 04        		ld b, 4
 204+ 269C 1A           testCWD1	ld a, (de)
 205+ 269D 13           		inc de
 206+ 269E ED A1        		cpi
 207+ 26A0 C0           		ret nz			; ZF=0 (NZ) -> not the same
 208+ 26A1 10 F9        		djnz testCWD1
 209+ 26A3              		; si llega aqui es que son iguales, no hace falta comprobar que B sea cero
 210+ 26A3 21 6B 37     		ld hl, dbStrPathName
 211+ 26A6 11 5F 32     		ld de, msgPath
 212+ 26A9 3A 2D 37     		ld a, (strLen)
 213+ 26AC 47           		ld b, a
 214+ 26AD 1A           testCWD2	ld a, (de)
 215+ 26AE 13           		inc de
 216+ 26AF ED A1        		cpi
 217+ 26B1 C0           		ret nz			; ZF=0 (NZ) -> not the same
 218+ 26B2 10 F9        		djnz testCWD2
 219+ 26B4              		; si llega aqui es que son iguales, el flag Z est activado del CPI
 220+ 26B4 C9           		ret
 221+ 26B5
 222+ 26B5              ; ----------------------------------------------
 223+ 26B5              ; skip '.' dir entry and saves dir entry pointer
 224+ 26B5              ; ----------------------------------------------
 225+ 26B5              ;
 226+ 26B5 CD 9C 22     skipDotSavePtr	call fOpenDir
 227+ 26B8
 228+ 26B8              		;
 229+ 26B8              		; ignore '.' entry
 230+ 26B8              		;
 231+ 26B8 CD AC 22     		call fReadDir
 232+ 26BB DA 78 27     		jp c, prError
 233+ 26BE              		;
 234+ 26BE 3A 8A 31     		ld a, (bDName)
 235+ 26C1 FE 2E        		cp '.'
 236+ 26C3 20 06        		jr nz,label1
 237+ 26C5 3A 8B 31     		ld a, (bDName+1)
 238+ 26C8 B7           		or a
 239+ 26C9 28 03        		jr z,label2
 240+ 26CB
 241+ 26CB              label1		;
 242+ 26CB              		; rebobina directorio
 243+ 26CB              		;
 244+ 26CB CD C7 22     		call fRewindDir
 245+ 26CE
 246+ 26CE              label2		;
 247+ 26CE              		; guarda puntero al primer elemento
 248+ 26CE              		;
 249+ 26CE CD BE 22     		call fTellDir
 250+ 26D1              		IFDEF _POINTER4BYTES
 251+ 26D1 ~            		  ld (pCurDir), bc
 252+ 26D1 ~            		  ld (pCurDir+2), de
 253+ 26D1              		ELSE
 254+ 26D1 79           		  ld a, c
 255+ 26D2 32 B6 35     		  ld (pCurDir), a
 256+ 26D5 ED 53 B7 35  		  ld (pCurDir+1), de
 257+ 26D9              		ENDIF
 258+ 26D9
 259+ 26D9 CD 93 22     		call fClose
 260+ 26DC
 261+ 26DC C9           		ret
 262+ 26DD
 263+ 26DD              ; ----------------------------
 264+ 26DD              ; pretty printer for file size
 265+ 26DD              ; ----------------------------
 266+ 26DD              ;
 267+ 26DD AF           prtSize		xor a			;
 268+ 26DE 32 FB 37     		ld (prefixCnt), a	// e a cero es suficiente
 269+ 26E1 21 8A 31     		ld hl, bDName		;
 270+ 26E4 01 0D 00     		ld bc, 8+1+3+1		;
 271+ 26E7 ED B1        		cpir			; search end of string
 272+ 26E9 23           		inc hl
 273+ 26EA 23           		inc hl
 274+ 26EB 23           		inc hl
 275+ 26EC 23           		inc hl			; add 4 to hl, hl points to dword DSize
 276+ 26ED 22 F7 37     		ld (pDSizeL), hl
 277+ 26F0 23           		inc hl
 278+ 26F1 23           		inc hl
 279+ 26F2 22 F9 37     		ld (pDSizeH), hl
 280+ 26F5
 281+ 26F5 06 03        		ld b, 3
 282+ 26F7 2A F9 37     normL4		ld hl, (pDSizeH)
 283+ 26FA 7E           		ld a, (hl)
 284+ 26FB 23           		inc hl
 285+ 26FC B6           		or (hl)
 286+ 26FD 20 09        		jr nz, normL5		// SizeH not zero
 287+ 26FF 2A F7 37     		ld hl, (pDSizeL)
 288+ 2702 23           		inc hl
 289+ 2703 7E           		ld a, (hl)
 290+ 2704 FE 28        		cp 40
 291+ 2706 38 23        		jr c, normL6		// SizeL >= 40*256=10240 (10K)
 292+ 2708
 293+ 2708 16 00        normL5		ld d, 0
 294+ 270A 58           		ld e, b
 295+ 270B 06 0A        div1024		ld b, 10
 296+ 270D 2A F9 37     divL0		ld hl, (pDSizeH)
 297+ 2710 23           		inc hl
 298+ 2711 CB 3E        		srl (hl)
 299+ 2713 08           		ex af, af'
 300+ 2714 48           		ld c, b
 301+ 2715 06 03        		ld b, 3
 302+ 2717 2B           divL1		dec hl
 303+ 2718 CB 3E        		srl (hl)
 304+ 271A 08           		ex af, af'
 305+ 271B 30 04        		jr nc, divL2
 306+ 271D 3E 80        		ld a, %10000000		;
 307+ 271F 86           		add a, (hl)		; set bit 7 of (hl) if carry set
 308+ 2720 77           		ld (hl), a		;
 309+ 2721 10 F4        divL2		djnz divL1
 310+ 2723 41           		ld b, c
 311+ 2724 10 E7        		djnz divL0
 312+ 2726              		//ld (prefixCnt), de
 313+ 2726 7B           		ld a, e
 314+ 2727 32 FB 37     		ld (prefixCnt), a
 315+ 272A 43           		ld b, e
 316+ 272B 10 CA        normL6		djnz normL4
 317+ 272D
 318+ 272D 2A F7 37     		ld hl, (pDSizeL)
 319+ 2730 5E           		ld e, (hl)
 320+ 2731 23           		inc hl
 321+ 2732 56           		ld d, (hl)
 322+ 2733 EB           		ex de, hl
 323+ 2734 CD C3 24     		call utoa
 324+ 2737              		//ld de, (prefixCnt)
 325+ 2737 AF           		xor a
 326+ 2738 57           		ld d, a
 327+ 2739 3A FB 37     		ld a, (prefixCnt)
 328+ 273C 5F           		ld e, a
 329+ 273D 21 7E 35     		ld hl, prefix
 330+ 2740 19           		add hl, de
 331+ 2741 7E           		ld a, (hl)
 332+ 2742 CD DC 24     		call prChr
 333+ 2745 C9           		ret
 334+ 2746
 335+ 2746              ; --------------------------------------------------------------------
 336+ 2746              ; search first drive unit (system/boot) testing all ones from 1 to 255
 337+ 2746              ;---------------------------------------------------------------------
 338+ 2746              ;
 339+ 2746 3E 01        findDrv		ld a, 1
 340+ 2748 B7           Otro		or a
 341+ 2749 C8           		ret z			; end reached, not found drive unit
 342+ 274A FE 24        		cp SYS_DRIVE
 343+ 274C 28 09        		jr z, Nuevo		; skip system/boot drive
 344+ 274E FE 2A        		cp CUR_DRIVE
 345+ 2750 28 05        		jr z, Nuevo		; skip default drive
 346+ 2752 47           		ld b, a
 347+ 2753 CF           		rst $08
 348+ 2754 89           		db M_GETSETDRV
 349+ 2755 78           		ld a, b
 350+ 2756 D0           		ret nc			; if CF=0 find first drive unit
 351+ 2757 3C           Nuevo		inc a
 352+ 2758 18 EE        		jr Otro
 353+ 275A
 354+ 275A              ; -----------------------
 355+ 275A              ; read configuration file
 356+ 275A              ; -----------------------
 357+ 275A              ;
 358+ 275A 21 22 35     readCnf		ld hl, dbFnConfigFile	; asciiz string containg path and/or filename
 359+ 275D 06 01        		ld b, FA_OPEN_EX|FA_READ
 360+ 275F              					; open if exists, else error
 361+ 275F              					; read access
 362+ 275F 3E 24        		ld a, SYS_DRIVE		; system/boot drive
 363+ 2761 CD 6D 22     		call fOpen1
 364+ 2764
 365+ 2764 21 04 38     		ld hl, bufConf		; dest
 366+ 2767 01 08 00     		ld bc, 8		; size
 367+ 276A CD 76 22     		call fRead
 368+ 276D
 369+ 276D CD 93 22     		call fClose
 370+ 2770
 371+ 2770 C9           		ret
 372+ 2771
 373+ 2771 ~            		/*
 374+ 2771 ~            ; ------------------------
 375+ 2771 ~            ; write configuration file
 376+ 2771 ~            ; ------------------------
 377+ 2771 ~            ;
 378+ 2771 ~            writeCnf	ld hl, dbFnConfigFile	; asciiz string containg path and/or filename
 379+ 2771 ~            		ld b, FA_OPEN_AL|FA_WRITE
 380+ 2771 ~            					; open if exists, if not create
 381+ 2771 ~            					; write access
 382+ 2771 ~            		ld a, SYS_DRIVE		; system/boot drive
 383+ 2771 ~            		call fOpen1
 384+ 2771 ~
 385+ 2771 ~            		ld hl, bufConf		; dest
 386+ 2771 ~            		ld bc, 8		; size
 387+ 2771 ~            		call fWrite
 388+ 2771 ~
 389+ 2771 ~            		call fClose
 390+ 2771 ~
 391+ 2771 ~            		ret
 392+ 2771 ~            		*/
 393+ 2771
 394+ 2771              ; -----------------------------------------------------------------------------
 395+ 2771              ; Error handler
 396+ 2771              ; -----------------------------------------------------------------------------
 397+ 2771              ;
 398+ 2771 F5           closeFilePrErr	push af
 399+ 2772 3A 79 31     		ld a, (fhandle)		;
 400+ 2775 CF           		rst $08			;
 401+ 2776 9B           		db F_CLOSE		; close file
 402+ 2777 F1           		pop af
 403+ 2778
 404+ 2778 F5           prError		push af
 405+ 2779              		;ld      bc, 24*256+0    ; 24 lines from line 0
 406+ 2779              		;ld      a, COL_MID      ; color
 407+ 2779              		;call    clrScr
 408+ 2779 01 0B 03     		ld bc, 3*256+11
 409+ 277C 3E 57        		ld a, COL_ERR
 410+ 277E CD 21 24     		call clrScr
 411+ 2781 21 47 32     		ld hl, msgErr
 412+ 2784 CD C9 24     		call prStr
 413+ 2787 F1           		pop af
 414+ 2788
 415+ 2788 26 00        		ld h, 0			; esxDOS err
 416+ 278A 6F           		ld l, a
 417+ 278B CD C3 24     		call utoa
 418+ 278E CD 51 23     		call waitKey
 419+ 2791
 420+ 2791 ED 7B 84 35  		ld sp, (savedSP)
 421+ 2795
 422+ 2795 C3 0B 20     		jp page5.mainL1
 423+ 2798
# file closed: functions.asm
 129  2798              		include "actions.asm"
# file opened: actions.asm
   1+ 2798              ;==============================================================================
   2+ 2798              ; Project: NMI.zdsp
   3+ 2798              ; File: actions.asm
   4+ 2798              ; Date: 03/11/2022 21:31:17
   5+ 2798              ;
   6+ 2798              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2798              ;
   8+ 2798              ;==============================================================================
   9+ 2798
  10+ 2798              ;==============================================================================
  11+ 2798              ; ACTIONS
  12+ 2798              ;==============================================================================
  13+ 2798
  14+ 2798              ; =============================================================================
  15+ 2798              ; startup --- revisado
  16+ 2798              ; =============================================================================
  17+ 2798              ;
  18+ 2798 3A 27 37     startup.start	ld a, (ldInit)		;
  19+ 279B B7           		or a			;
  20+ 279C CA 01 28     		jp z, skipInit		; first time we call NMI navigator
  21+ 279F
  22+ 279F AF           doInit		xor a
  23+ 27A0 32 27 37     		ld (ldInit), a
  24+ 27A3
  25+ 27A3 3A 8A 35     		ld a, (esxDOSv)
  26+ 27A6 FE 35        		cp '5'
  27+ 27A8 28 09        		jr z, ver085
  28+ 27AA FE 37        		cp '7'
  29+ 27AC 28 0A        		jr z, ver087
  30+ 27AE              		;
  31+ 27AE              		; version is 0.8.6 or 0.8.8 or 0.8.9
  32+ 27AE              		;
  33+ 27AE 21 A8 00     ver086_8	ld hl, $00a8
  34+ 27B1 18 08        		jr copyVersion
  35+ 27B3              		;
  36+ 27B3              		; version is 0.8.5
  37+ 27B3              		;
  38+ 27B3 21 B8 00     ver085		ld hl, $00b8
  39+ 27B6 18 03        		jr copyVersion
  40+ 27B8              		;
  41+ 27B8              		; version is 0.8.7
  42+ 27B8              		;
  43+ 27B8 21 A7 00     ver087		ld hl, $00a7
  44+ 27BB              		;
  45+ 27BB 11 B6 32     copyVersion	ld de, msgVer
  46+ 27BE 01 0D 00     		ld bc, 13
  47+ 27C1 ED B0        		ldir
  48+ 27C3
  49+ 27C3 3A 88 35     		ld a, (speccyRAM)
  50+ 27C6 FE 00        		cp 0
  51+ 27C8 20 08        		jr nz, noes16k
  52+ 27CA 21 FC 34     		ld hl, msg16k
  53+ 27CD 01 03 00     		ld bc, 3
  54+ 27D0 18 12        		jr copyRAM
  55+ 27D2 FE 01        noes16k		cp 1
  56+ 27D4 20 08        		jr nz, noes48k
  57+ 27D6 21 FF 34     		ld hl, msg48k
  58+ 27D9 01 03 00     		ld bc, 3
  59+ 27DC 18 06        		jr copyRAM
  60+ 27DE 21 02 35     noes48k		ld hl, msg128k
  61+ 27E1 01 04 00     		ld bc, 4
  62+ 27E4 11 AF 32     copyRAM		ld de, msgRAM1
  63+ 27E7 ED B0        		ldir
  64+ 27E9
  65+ 27E9 2A 86 35     		ld hl, (divRAM)		; hl = 8 kB pages found
  66+ 27EC CB 25        		sla l			;
  67+ 27EE CB 14        		rl h			;
  68+ 27F0 CB 25        		sla l			;
  69+ 27F2 CB 14        		rl h			;
  70+ 27F4 CB 25        		sla l			;
  71+ 27F6 CB 14        		rl h			; hl = hl * 8 = kB RAM found
  72+ 27F8
  73+ 27F8 11 C4 32     		ld de, msgRAM2
  74+ 27FB CD 69 24     		call _utoa
  75+ 27FE 3E 4B        		ld a, 'K'
  76+ 2800 12           		ld (de), a
  77+ 2801
  78+ 2801 3A 28 37     skipInit	ld a, (ldConf)
  79+ 2804 B7           		or a
  80+ 2805 28 7B        		jr z, skipLoadConfig
  81+ 2807 AF           		xor a
  82+ 2808 32 28 37     		ld (ldConf), a
  83+ 280B
  84+ 280B CD 5A 27     		call readCnf	; read config file
  85+ 280E
  86+ 280E 3A 05 38     		ld a, (cfLeft)
  87+ 2811 32 00 32     		ld (kLeft), a
  88+ 2814 3A 06 38     		ld a, (cfRight)
  89+ 2817 32 09 32     		ld (kRight), a
  90+ 281A 3A 08 38     		ld a, (cfUp)
  91+ 281D 32 06 32     		ld (kUp), a
  92+ 2820 3A 07 38     		ld a, (cfDown)
  93+ 2823 32 03 32     		ld (kDown), a
  94+ 2826 3A 09 38     		ld a, (cfEnter)
  95+ 2829 32 0C 32     		ld (kEnter), a
  96+ 282C 3A 04 38     		ld a, (cfPopUp)
  97+ 282F 32 2A 37     		ld (flgPopUp), a
  98+ 2832 3A 0A 38     		ld a, (cfOut)
  99+ 2835 32 2B 37     		ld (flgOut), a
 100+ 2838 3A 0B 38     		ld a, (cfHidden)
 101+ 283B 32 2C 37     		ld (flgHidden), a
 102+ 283E
 103+ 283E 3A 2A 37     		ld a, (flgPopUp)
 104+ 2841 B7           		or a
 105+ 2842 28 3E        		jr z, skipLoadConfig
 106+ 2844
 107+ 2844 01 00 18     		ld bc, 24*256+0
 108+ 2847 3E 00        		ld a, 0
 109+ 2849 CD 21 24     		call clrScr
 110+ 284C
 111+ 284C 21 D8 34     		ld hl, msg0001
 112+ 284F CD C9 24     		call prStr
 113+ 2852
 114+ 2852              		;
 115+ 2852              		; popup window
 116+ 2852              		;
 117+ 2852 06 38        		ld b, 56
 118+ 2854 0E 47        		ld c, BRIGHT+BLACK*8+WHITE
 119+ 2856 AF           		xor a
 120+ 2857 F5           waitE		push af
 121+ 2858 C5           		push bc
 122+ 2859 81           		add a, c
 123+ 285A 01 0B 03     		ld bc, 3*256+11
 124+ 285D CD D1 28     		call clrAttr
 125+ 2860 C1           		pop bc
 126+ 2861 3A 03 38     		ld a, (flagT)
 127+ 2864 B7           		or a
 128+ 2865 28 05        		jr z, wait3
 129+ 2867 F1           		pop af
 130+ 2868 D6 08        		sub 8
 131+ 286A 18 03        		jr wait2
 132+ 286C F1           wait3		pop af
 133+ 286D C6 08        		add a, 8
 134+ 286F B7           wait2		or a
 135+ 2870 20 05        		jr nz, wait0
 136+ 2872 32 03 38     		ld (flagT), a
 137+ 2875 18 07        		jr wait1
 138+ 2877 FE 38        wait0		cp 56
 139+ 2879 20 03        		jr nz, wait1
 140+ 287B 32 03 38     		ld (flagT), a
 141+ 287E FB           wait1		ei
 142+ 287F 76           		halt
 143+ 2880 10 D5        		djnz waitE
 144+ 2882
 145+ 2882 3A 2B 37     skipLoadConfig	ld a, (flgOut)
 146+ 2885 B7           		or a
 147+ 2886 28 03        		jr z, skipSetStdGr
 148+ 2888
 149+ 2888 AF           		xor a			;
 150+ 2889 D3 FF        		out ($ff), a		; set standard graphic zx mode on computers
 151+ 288B              					; Timex2048,Timex2068 and on SLAM
 152+ 288B              					; Thanks to Velesoft
 153+ 288B              skipSetStdGr		;
 154+ 288B              		;  Get CWD
 155+ 288B              		;
 156+ 288B CD 31 26     		call getCWD
 157+ 288E
 158+ 288E 3A 29 37     		ld a, (ldDir)		;
 159+ 2891 B7           		or a			;
 160+ 2892 20 05        		jr nz, doReload		; first time we call NMI navigator
 161+ 2894
 162+ 2894              		;
 163+ 2894              		; Compare old WD with CWD
 164+ 2894              		;
 165+ 2894 CD 94 26     		call testCWD
 166+ 2897 28 13        		jr z, skipReload	; current working directory not changed
 167+ 2899              					; preserves previous navigation page and line
 168+ 2899
 169+ 2899 AF           doReload	xor a
 170+ 289A 32 29 37     		ld (ldDir), a
 171+ 289D              		;
 172+ 289D              		; Init navigator variables
 173+ 289D              		;
 174+ 289D 21 00 00     		ld hl, 0
 175+ 28A0 22 AC 35     		ld (curLn), hl
 176+ 28A3 22 B0 35     		ld (Xof),hl
 177+ 28A6 22 B4 35     		ld (ofY), hl
 178+ 28A9              		;
 179+ 28A9              		; skip '.' dir entry and saves dir entry pointer
 180+ 28A9              		;
 181+ 28A9 CD B5 26     		call skipDotSavePtr
 182+ 28AC
 183+ 28AC              skipReload	;
 184+ 28AC              		; Copy CWD msg
 185+ 28AC              		;
 186+ 28AC CD 7D 26     		call copyCWD
 187+ 28AF              		;
 188+ 28AF              		; Copy lock status msg
 189+ 28AF              		;
 190+ 28AF 3A 88 35     		ld a, (speccyRAM)
 191+ 28B2 FE 02        		cp 2
 192+ 28B4 20 17        		jr nz, notToastrack
 193+ 28B6
 194+ 28B6 21 06 35     		ld hl, msgUnlocked	; UNLOCKED
 195+ 28B9 01 08 00     		ld bc, 8
 196+ 28BC 3A 82 35     		ld a, (flgLOCK)
 197+ 28BF B7           		or a
 198+ 28C0 20 06        		jr nz, isUnlocked
 199+ 28C2 21 08 35     		ld hl, msgUnlocked+2	; LOCKED
 200+ 28C5 01 08 00     		ld bc, 8
 201+ 28C8
 202+ 28C8 11 A6 32     isUnlocked	ld de, msgLock
 203+ 28CB ED B0        		ldir
 204+ 28CD
 205+ 28CD AF           notToastrack	xor a			;
 206+ 28CE D3 FE        		out ($fe), a		; black border
 207+ 28D0
 208+ 28D0              		//jp mainL2		; reprint all (top, mid, bottom and cursor)
 209+ 28D0 C9           		ret
 210+ 28D1
 211+ 28D1              ;--------
 212+ 28D1              ; clrAttr
 213+ 28D1              ;--------
 214+ 28D1              ;
 215+ 28D1 08           clrAttr		ex af, af'		; guardamos atributos
 216+ 28D2              		;
 217+ 28D2              		; attr
 218+ 28D2              		;
 219+ 28D2 79           		ld a, c			; Calculate Y7, Y6
 220+ 28D3 0F           		rrca			; Shift to position
 221+ 28D4 0F           		rrca
 222+ 28D5 0F           		rrca
 223+ 28D6 E6 03        		and %00000011		; Mask out unwanted bits
 224+ 28D8 F6 58        		or %01011000		; Set attr address of screen
 225+ 28DA 67           		ld h, a			; Store in H
 226+ 28DB 57           		ld d, a
 227+ 28DC 79           		ld a, c
 228+ 28DD 0F           		rrca			; Shift to position
 229+ 28DE 0F           		rrca
 230+ 28DF 0F           		rrca
 231+ 28E0 E6 E0        		and %11100000		; Calculate Y5, Y4, Y3
 232+ 28E2 6F           		ld l, a			; Store in L
 233+ 28E3 5F           		ld e, a
 234+ 28E4 1C           		inc e
 235+ 28E5              		;
 236+ 28E5 08           		ex af, af'		; recuperamos atributos
 237+ 28E6 C5           		push bc			; guardamos BC
 238+ 28E7              		;
 239+ 28E7 77           		ld (hl), a
 240+ 28E8 01 1F 00     		ld bc, 32-1
 241+ 28EB ED B0        		ldir
 242+ 28ED              		;
 243+ 28ED C1           		pop bc			; recuperamos BC
 244+ 28EE              		;
 245+ 28EE 0C           		inc c
 246+ 28EF 10 E0        		djnz clrAttr
 247+ 28F1              		;
 248+ 28F1 C9           		ret
 249+ 28F2
 250+ 28F2              ; =============================================================================
 251+ 28F2              ; 'ENTER' do action over cursor --- revisado
 252+ 28F2              ; =============================================================================
 253+ 28F2              ;
 254+ 28F2 01 17 01     doAct.start	ld bc, 1*256+23		; 1 line from line 23
 255+ 28F5 3E 38        		ld a, COL_BOT		; color
 256+ 28F7 CD 21 24     		call clrScr
 257+ 28FA              		;
 258+ 28FA 3A 89 31     		ld a, (bDAttr)
 259+ 28FD E6 10        		and A_DIR		; check if is dir
 260+ 28FF 28 14        		jr z, doAct.isFile
 261+ 2901
 262+ 2901 21 96 33     doAct.isDir	ld hl, msgDir
 263+ 2904 CD C9 24     		call prStr		; LOADING DIRECTORY...
 264+ 2907              		;
 265+ 2907 21 8A 31     		ld hl, bDName
 266+ 290A CD DE 22     		call fChDir
 267+ 290D              		;
 268+ 290D 3E FF        		ld a, $ff
 269+ 290F 32 29 37     		ld (ldDir), a
 270+ 2912              		;
 271+ 2912 C3 0B 20     		jp mainL1		; reload dir and reprint all
 272+ 2915
 273+ 2915 21 AE 33     doAct.isFile	ld hl, msgFile
 274+ 2918 CD C9 24     		call prStr		; LOADING FILE...
 275+ 291B              		;
 276+ 291B 21 8A 31     		ld hl, bDName		;
 277+ 291E 11 6B 37     		ld de, dbStrPathName	;
 278+ 2921 01 0D 00     		ld bc, 8+1+3+1		;
 279+ 2924 ED B0        		ldir			; copy filename
 280+ 2926
 281+ 2926 11 19 32     doAct.exeAction1 ld de, dbdwTbExtAct
 282+ 2929
 283+ 2929 21 6B 37     doAct.exeAction	ld hl, dbStrPathName
 284+ 292C              		//ld bc, 8+1+3+1
 285+ 292C 01 8B 00     		ld bc, 127+8+1+3
 286+ 292F 3E 00        		ld a, 0
 287+ 2931 ED B1        		cpir
 288+ 2933              		//ld bc, 8+1+3+1
 289+ 2933 01 8B 00     		ld bc, 127+8+1+3
 290+ 2936 3E 2E        		ld a, '.'
 291+ 2938 ED B9        		cpdr
 292+ 293A              		//inc hl
 293+ 293A              		//inc hl
 294+ 293A
 295+ 293A              doAct.noDot	;jp nz, mainL5		; if no extension, skip
 296+ 293A              		;jp nz, viewSCR		; if no extension, treat as SCR
 297+ 293A              		;jp nz, viewHex		; if no extension, view with hexview
 298+ 293A C2 C4 29     		jp nz, loadBAS		; if no extension, load as BASIC
 299+ 293D
 300+ 293D 23           doAct.yesDot	inc hl
 301+ 293E 23           		inc hl
 302+ 293F EB           		ex de, hl
 303+ 2940
 304+ 2940 7E           doAct.compStr	ld a, (hl)
 305+ 2941 B7           		or a
 306+ 2942              		;jp z, mainL5		; all other extensions skipped
 307+ 2942              		;jr z, viewSCR		; all other extensions treated as SCR
 308+ 2942              		;jp z, loadBAS		; all other extensions loaded as BASIC
 309+ 2942 CA 99 29     		jp z, viewHex		; all other extensions viewed with hexview
 310+ 2945
 311+ 2945              		//call prStr
 312+ 2945              		//call waitKey
 313+ 2945              		//jp mainL2		; reprint all (top, mid, bottom and cursor)
 314+ 2945
 315+ 2945 D5           		push de
 316+ 2946 E5           		push hl
 317+ 2947 06 03        		ld b, 3
 318+ 2949 1A           doAct.strcmp	ld a, (de)
 319+ 294A BE           		cp (hl)
 320+ 294B 23           		inc hl
 321+ 294C 13           		inc de
 322+ 294D 28 0F        		jr z, doAct.otra
 323+ 294F
 324+ 294F 2B           		dec hl
 325+ 2950 D6 20        		sub 'a'-'A'		; insensitive comparation
 326+ 2952 BE           		cp (hl)
 327+ 2953 23           		inc hl
 328+ 2954 28 08        		jr z, doAct.otra
 329+ 2956
 330+ 2956 E1           		pop hl
 331+ 2957 D1           		pop de
 332+ 2958 01 05 00     		ld bc, 5
 333+ 295B 09           		add hl, bc
 334+ 295C 18 E2        		jr doAct.compStr
 335+ 295E
 336+ 295E 10 E9        doAct.otra	djnz doAct.strcmp
 337+ 2960
 338+ 2960              		;
 339+ 2960              		; extension found!
 340+ 2960              		;
 341+ 2960 E1           		pop hl
 342+ 2961 D1           		pop de
 343+ 2962 01 03 00     		ld bc, 3
 344+ 2965 09           		add hl, bc
 345+ 2966
 346+ 2966 5E           		ld e, (hl)
 347+ 2967 23           		inc hl
 348+ 2968 56           		ld d, (hl)
 349+ 2969 EB           		ex de, hl
 350+ 296A
 351+ 296A E9           		jp (hl)
 352+ 296B
 353+ 296B              ; *****************************************************************************
 354+ 296B
 355+ 296B              ; -----------
 356+ 296B              ; view screen
 357+ 296B              ; -----------
 358+ 296B              ;
 359+ 296B 21 6B 37     viewSCR		ld hl, dbStrPathName	; asciiz string containg path and/or filename
 360+ 296E 06 01        		ld b, FA_OPEN_EX|FA_READ
 361+ 2970              					; open if exists, else error
 362+ 2970              					; read access
 363+ 2970 CD 6B 22     		call fOpen
 364+ 2973
 365+ 2973 21 00 40     readSCR		ld hl, 16384		; dest
 366+ 2976 01 00 1B     		ld bc, 6144+768		; size  ; 7*1024
 367+ 2979 CD 76 22     		call fRead
 368+ 297C
 369+ 297C CD 93 22     		call fClose
 370+ 297F
 371+ 297F CD 51 23     		call waitKey
 372+ 2982
 373+ 2982 C3 12 20     		jp page5.mainL2		; reprint all (top, mid, bottom and cursor)
 374+ 2985
 375+ 2985              ; -----------------------
 376+ 2985              ; view screen of SNA file
 377+ 2985              ; -----------------------
 378+ 2985              ;
 379+ 2985 21 6B 37     viewSNA		ld hl, dbStrPathName	; asciiz string containg path and/or filename
 380+ 2988 06 01        		ld b, FA_OPEN_EX|FA_READ
 381+ 298A              					; open if exists, else error
 382+ 298A              					; read access
 383+ 298A CD 6B 22     		call fOpen
 384+ 298D
 385+ 298D 01 00 00     		ld bc, 0
 386+ 2990 11 1B 00     		ld de, 27
 387+ 2993 CD 88 22     		call fSeek		; skip SNA header
 388+ 2996
 389+ 2996 C3 73 29     		jp readSCR
 390+ 2999
 391+ 2999              ; -------
 392+ 2999              ; hexview
 393+ 2999              ; -------
 394+ 2999              ;
 395+ 2999              ; uses hexview dot command
 396+ 2999              ;
 397+ 2999 21 8A 31     viewHex		ld hl, bDName
 398+ 299C 11 55 37     		ld de, bDName3
 399+ 299F 01 0D 00     		ld bc, 13
 400+ 29A2 ED B0        		ldir
 401+ 29A4
 402+ 29A4 21 4D 37     		ld hl, dotCommHexview
 403+ 29A7 CD EE 22     		call fExecCMD	; Should not return
 404+ 29AA
 405+ 29AA C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 406+ 29AD
 407+ 29AD              ; -------------
 408+ 29AD              ; load sna, z80
 409+ 29AD              ; -------------
 410+ 29AD              ;
 411+ 29AD              ; uses snapload dot command
 412+ 29AD              ;
 413+ 29AD 21 62 37     loadSNA		ld hl, dotCommSnapload
 414+ 29B0 CD EE 22     		call fExecCMD	; Should not return
 415+ 29B3
 416+ 29B3 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 417+ 29B6
 418+ 29B6              ; --------
 419+ 29B6              ; load tap
 420+ 29B6              ; --------
 421+ 29B6              ;
 422+ 29B6 21 6B 37     loadTAP		ld hl, dbStrPathName
 423+ 29B9 CD 1C 23     		call fAttachTapeIn
 424+ 29BC 3E 00        		ld a, 0			; LOAD ""
 425+ 29BE CD FF 22     		call fAutoLoad	; Should not return
 426+ 29C1
 427+ 29C1 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 428+ 29C4
 429+ 29C4              ; --------
 430+ 29C4              ; load BAS
 431+ 29C4              ; --------
 432+ 29C4              ;
 433+ 29C4              loadBAS		;
 434+ 29C4              		; Falla con la version v086b51
 435+ 29C4              		;
 436+ 29C4 3E 2A        		ld a, CUR_DRIVE		; current drive
 437+ 29C6 21 6B 37     		ld hl, dbStrPathName
 438+ 29C9 CD FF 22     		call fAutoLoad	; Should not return
 439+ 29CC
 440+ 29CC C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 441+ 29CF
 442+ 29CF              ; =============================================================================
 443+ 29CF              ; 'T', 'SS'+'T', 'CS'+'T' start TR-DOS Emulator --- revisado (startTRDOS)
 444+ 29CF              ; =============================================================================
 445+ 29CF              ;
 446+ 29CF
 447+ 29CF              ; --------
 448+ 29CF              ; load TRD
 449+ 29CF              ; --------
 450+ 29CF              ;
 451+ 29CF              loadTRD		;
 452+ 29CF              		; attach TRD to drive A
 453+ 29CF              		;
 454+ 29CF 3E 60        		ld a, $60		; virtual unit A
 455+ 29D1 CD 0C 23     		call fEjectVDisk
 456+ 29D4
 457+ 29D4 21 6B 37     		ld hl, dbStrPathName
 458+ 29D7 3E 60        		ld a, $60		; virtual unit A
 459+ 29D9 CD 0F 23     		call fMountVDisk
 460+ 29DC
 461+ 29DC CD B9 23     startTRDOS	call ckMods
 462+ 29DF 3A 78 31     		ld a, (flagSS)
 463+ 29E2 B7           		or a
 464+ 29E3 20 16        		jr nz, ldTRD01		; z no SS pressed, nz SS pressed
 465+ 29E5 3A 77 31     		ld a, (flagCS)
 466+ 29E8 B7           		or a
 467+ 29E9 20 08        		jr nz, ldTRD02		; z no CS pressed, nz CS pressed
 468+ 29EB
 469+ 29EB              		; Enter
 470+ 29EB              		;
 471+ 29EB              		; Autoload from vdisk. If no boot, loads TR-DOS Navigator
 472+ 29EB              		;
 473+ 29EB 3E FD        		ld a, $fd		; Autoload from vdisk, if no boot, loads TR-DOS Navigator
 474+ 29ED CD FF 22     		call fAutoLoad		; Should not return
 475+ 29F0
 476+ 29F0 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 477+ 29F3
 478+ 29F3              ldTRD02		; CS+Enter
 479+ 29F3              		;
 480+ 29F3              		; Enter TR-DOS mode
 481+ 29F3              		;
 482+ 29F3 3E FC        		ld a, $fc		; Enter TR-DOS mode
 483+ 29F5 CD FF 22     		call fAutoLoad		; Should not return
 484+ 29F8
 485+ 29F8 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 486+ 29FB
 487+ 29FB              ; ----------
 488+ 29FB              ; load TR-DOS
 489+ 29FB              ; ----------
 490+ 29FB              ;
 491+ 29FB              ; 10 REM There must be a disk inserted in drive A
 492+ 29FB              ; 20 RANDOMIZE USR 15619: REM: LIST
 493+ 29FB              ; 30 CLEAR 31732
 494+ 29FB              ; 40 LOAD *"/SYS/TRDBOOT.BIN" CODE 31733
 495+ 29FB              ; 50 RANDOIMIZE USR 31733
 496+ 29FB              ;
 497+ 29FB              ldTRD01		; SS+Enter
 498+ 29FB              		;
 499+ 29FB              		; load TR-DOS Navigator
 500+ 29FB              		;
 501+ 29FB
 502+ 29FB 3E 24        		ld a, SYS_DRIVE		; current drive
 503+ 29FD 21 6C 35     		ld hl, trdBas
 504+ 2A00 CD FF 22     		call fAutoLoad	; Should not return
 505+ 2A03
 506+ 2A03 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 507+ 2A06
 508+ 2A06              ; --------
 509+ 2A06              ; load ROM
 510+ 2A06              ; --------
 511+ 2A06              ;
 512+ 2A06              ; 10 CLEAR 49151
 513+ 2A06              ; 20 LOAD *"FILE.ROM"CODE 49152
 514+ 2A06              ; 30 .ownrom
 515+ 2A06              ;
 516+ 2A06 21 6B 37     loadROM		ld hl, dbStrPathName	; asciiz string containg path and/or filename
 517+ 2A09 06 01        		ld b, FA_OPEN_EX|FA_READ
 518+ 2A0B              					; open if exists, else error
 519+ 2A0B              					; read access
 520+ 2A0B CD 6B 22     		call fOpen
 521+ 2A0E
 522+ 2A0E 21 00 C0     		ld hl, 49152		; dest
 523+ 2A11 01 00 40     		ld bc, 16384		; size
 524+ 2A14 CD 76 22     		call fRead
 525+ 2A17
 526+ 2A17 CD 93 22     		call fClose
 527+ 2A1A
 528+ 2A1A 21 2E 37     		ld hl, dotCommOwnrom
 529+ 2A1D CD EE 22     		call fExecCMD	; Should not return
 530+ 2A20
 531+ 2A20 C3 0B 20     		jp page5.mainL1		; reload dir and reprint all
 532+ 2A23
 533+ 2A23              ; =============================================================================
 534+ 2A23              ; 'A'-'D' attach TRD to virtual disk --- revisado
 535+ 2A23              ; =============================================================================
 536+ 2A23              ;
 537+ 2A23 AF           trd2drv.start0	xor a
 538+ 2A24 18 0A        		jr trd2drv.trd2drv
 539+ 2A26
 540+ 2A26 3E 01        trd2drv.start1	ld a, 1
 541+ 2A28 18 06        		jr trd2drv.trd2drv
 542+ 2A2A
 543+ 2A2A 3E 02        trd2drv.start2	ld a, 2
 544+ 2A2C 18 02        		jr trd2drv.trd2drv
 545+ 2A2E
 546+ 2A2E 3E 03        trd2drv.start3	ld a, 3
 547+ 2A30
 548+ 2A30 32 00 38     trd2drv.trd2drv	ld (dbDrive), a		; proccess args
 549+ 2A33 C6 41        		add a, 'A'
 550+ 2A35 32 C7 34     		ld (unitLet), a
 551+ 2A38
 552+ 2A38 3A 89 31     		ld a, (bDAttr)
 553+ 2A3B E6 10        		and A_DIR		; check if is dir
 554+ 2A3D 28 03        		jr z, trd2drv.isFile
 555+ 2A3F
 556+ 2A3F C3 26 20     trd2drv.isDir	jp mainL5		; reprint nothing
 557+ 2A42
 558+ 2A42 21 8A 31     trd2drv.isFile	ld hl, bDName
 559+ 2A45 01 0D 00     		ld bc, 8+1+3+1
 560+ 2A48 3E 00        		ld a, 0
 561+ 2A4A ED B1        		cpir
 562+ 2A4C 01 0D 00     		ld bc, 8+1+3+1
 563+ 2A4F 3E 2E        		ld a, '.'
 564+ 2A51 ED B9        		cpdr
 565+ 2A53 23           		inc hl
 566+ 2A54 23           		inc hl
 567+ 2A55
 568+ 2A55 C2 26 20     trd2drv.noDot	jp nz, mainL5		; reprint nothing
 569+ 2A58
 570+ 2A58 22 01 38     trd2drv.yesDot	ld (dwPtrExt), hl
 571+ 2A5B 11 32 32     		ld de, extTRD
 572+ 2A5E EB           		ex de, hl
 573+ 2A5F 06 03        		ld b, 3
 574+ 2A61 1A           trd2drv.strcmp	ld a, (de)
 575+ 2A62 BE           		cp (hl)
 576+ 2A63 23           		inc hl
 577+ 2A64 13           		inc de
 578+ 2A65 20 04        		jr nz, trd2drv.chkSCL
 579+ 2A67 10 F8        		djnz trd2drv.strcmp
 580+ 2A69 18 13        		jr trd2drv.attTRD
 581+ 2A6B
 582+ 2A6B 21 37 32     trd2drv.chkSCL	ld hl, extSCL
 583+ 2A6E ED 5B 01 38  		ld de, (dwPtrExt)
 584+ 2A72 EB           		ex de, hl
 585+ 2A73 06 03        		ld b, 3
 586+ 2A75 1A           trd2drv.strcmp2	ld a, (de)
 587+ 2A76 BE           		cp (hl)
 588+ 2A77 23           		inc hl
 589+ 2A78 13           		inc de
 590+ 2A79 C2 26 20     		jp nz, mainL5		; not TRD or SCL, reprint nothing
 591+ 2A7C 10 F7        		djnz trd2drv.strcmp2
 592+ 2A7E
 593+ 2A7E 3A 00 38     trd2drv.attTRD	ld a, (dbDrive)
 594+ 2A81 87           		add a, a
 595+ 2A82 87           		add a, a
 596+ 2A83 87           		add a, a
 597+ 2A84 F6 60        		or $60
 598+ 2A86 CD 0C 23     		call fEjectVDisk
 599+ 2A89
 600+ 2A89 21 8A 31     		ld hl, bDName		//bDName2
 601+ 2A8C 3A 00 38     		ld a, (dbDrive)
 602+ 2A8F 87           		add a, a
 603+ 2A90 87           		add a, a
 604+ 2A91 87           		add a, a
 605+ 2A92 F6 60        		or $60
 606+ 2A94 CD 0F 23     		call fMountVDisk
 607+ 2A97
 608+ 2A97 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
 609+ 2A9A 3E 38        		ld a, COL_BOT		; color
 610+ 2A9C CD 21 24     		call clrScr
 611+ 2A9F 21 AF 34     		ld hl, msgOk
 612+ 2AA2 CD C9 24     		call prStr
 613+ 2AA5 CD 51 23     		call waitKey
 614+ 2AA8
 615+ 2AA8 C3 20 20     trd2drv.retMnt	jp mainL4		; reprint bottom and cursor
 616+ 2AAB
 617+ 2AAB              ; =============================================================================
 618+ 2AAB              ; 'E','DEL' delete file/dir  --- revisado
 619+ 2AAB              ; =============================================================================
 620+ 2AAB              ;
 621+ 2AAB 01 17 01     delFile.start	ld bc, 1*256+23		; 1 line from line 23
 622+ 2AAE 3E 38        		ld a, COL_BOT		; color
 623+ 2AB0 CD 21 24     		call clrScr
 624+ 2AB3 21 F3 32     		ld hl, msgOkDel
 625+ 2AB6 CD C9 24     		call prStr
 626+ 2AB9              		;
 627+ 2AB9              		; confirm delete
 628+ 2AB9              		;
 629+ 2AB9 CD 51 23     		call waitKey
 630+ 2ABC FE 59        		cp 'Y'
 631+ 2ABE C2 20 20     		jp nz, mainL4		; reprint bottom and cursor
 632+ 2AC1              		;
 633+ 2AC1 21 05 33     		ld hl, msgDel
 634+ 2AC4 CD C9 24     		call prStr
 635+ 2AC7
 636+ 2AC7 21 8A 31     		ld hl, bDName
 637+ 2ACA 11 40 37     		ld de, bDName2
 638+ 2ACD 01 0D 00     		ld bc, 13
 639+ 2AD0 ED B0        		ldir
 640+ 2AD2
 641+ 2AD2 21 39 37     		ld hl, dotCommRm
 642+ 2AD5 CD EE 22     		call fExecCMD
 643+ 2AD8
 644+ 2AD8 C3 0B 20     		jp mainL1		; reload dir and reprint all
 645+ 2ADB
 646+ 2ADB              ; =============================================================================
 647+ 2ADB              ; 'SS'+'F' fast-ramp config --- revisado
 648+ 2ADB              ; =============================================================================
 649+ 2ADB              ;
 650+ 2ADB 3A 89 31     fastcfg.start	ld a, (bDAttr)
 651+ 2ADE E6 10        	        and A_DIR		; check if is dir
 652+ 2AE0 28 03                	jr z, fastcfg.isFile
 653+ 2AE2
 654+ 2AE2 C3 26 20     fastcfg.isDir  	jp mainL5		; reprint nothing
 655+ 2AE5
 656+ 2AE5 01 17 01     fastcfg.isFile  ld bc, 1*256+23   	; 1 line from line 23
 657+ 2AE8 3E 38                	ld a, COL_BOT     	; color
 658+ 2AEA CD 21 24             	call clrScr
 659+ 2AED
 660+ 2AED 21 E1 32             	ld hl, msgSaveFC
 661+ 2AF0 CD C9 24             	call prStr
 662+ 2AF3
 663+ 2AF3 21 33 35             	ld hl, dbFnFastFile	; asciiz string containg path and/or filename
 664+ 2AF6 06 0E                	ld b, FA_CREATE_AL|FA_WRITE
 665+ 2AF8                                              	; create if not exists, else open and truncate
 666+ 2AF8                                              	; read access
 667+ 2AF8 3E 24                	ld a, SYS_DRIVE		; system/boot drive
 668+ 2AFA CD 6D 22             	call fOpen1
 669+ 2AFD
 670+ 2AFD CD 05 23     fastcfg.getCDrv	call fGetSetDrv1	; get current drive
 671+ 2B00 21 01 34             	ld hl, drvName
 672+ 2B03 CD 1F 26             	call convDrv
 673+ 2B06 21 01 34             	ld hl, drvName		; dest
 674+ 2B09 01 04 00             	ld bc, 4
 675+ 2B0C CD 7F 22             	call fWrite
 676+ 2B0F
 677+ 2B0F 21 6B 37     fastcfg.getCWD 	ld hl, dbStrPathName
 678+ 2B12 CD E6 22             	call fGetCWD
 679+ 2B15
 680+ 2B15 21 6B 37             	ld hl, dbStrPathName
 681+ 2B18 AF                   	xor a
 682+ 2B19 01 80 00             	ld bc, 128
 683+ 2B1C ED B1                	cpir
 684+ 2B1E 3E 7F                	ld a, 127
 685+ 2B20 91                   	sub c
 686+ 2B21 4F                   	ld c, a
 687+ 2B22 21 6B 37             	ld hl, dbStrPathName	; dest
 688+ 2B25 CD 7F 22             	call fWrite
 689+ 2B28
 690+ 2B28 21 8A 31             	ld hl, bDName
 691+ 2B2B AF                   	xor a
 692+ 2B2C 01 0D 00             	ld bc, 8+1+3+1
 693+ 2B2F ED B1                	cpir
 694+ 2B31 3E 0C                	ld a, 8+1+3+1-1
 695+ 2B33 91                   	sub c
 696+ 2B34 4F                   	ld c, a
 697+ 2B35 21 8A 31             	ld hl, bDName		; dest
 698+ 2B38 CD 7F 22             	call fWrite
 699+ 2B3B
 700+ 2B3B CD 93 22             	call fClose
 701+ 2B3E
 702+ 2B3E C3 0B 20     		jp mainL1		; reload dir and reprint all
 703+ 2B41
 704+ 2B41              ; =============================================================================
 705+ 2B41              ; 'F' fast-ramp load --- revisado
 706+ 2B41              ; =============================================================================
 707+ 2B41              ;
 708+ 2B41 01 17 01     fastLoad.start	ld bc, 1*256+23		; 1 line from line 23
 709+ 2B44 3E 38        		ld a, COL_BOT		; color
 710+ 2B46 CD 21 24     		call clrScr
 711+ 2B49 21 AE 33     		ld hl, msgFile
 712+ 2B4C CD C9 24     		call prStr		; LOADING FILE...
 713+ 2B4F
 714+ 2B4F 21 33 35     		ld hl, dbFnFastFile	; asciiz string containg path and/or filename
 715+ 2B52 06 01        		ld b, FA_OPEN_EX|FA_READ
 716+ 2B54              					; open if exists, else error
 717+ 2B54              					; read access
 718+ 2B54 3E 24        		ld a, SYS_DRIVE		; system/boot drive
 719+ 2B56 CD 6D 22     		call fOpen1
 720+ 2B59
 721+ 2B59 21 01 34     		ld hl, drvName		; dest
 722+ 2B5C 01 04 00     		ld bc, 4		; size
 723+ 2B5F CD 76 22     		call fRead
 724+ 2B62
 725+ 2B62 21 6B 37     		ld hl, dbStrPathName	; dest
 726+ 2B65 01 8B 00     		ld bc, 127+8+1+3	; size
 727+ 2B68 CD 76 22     		call fRead
 728+ 2B6B
 729+ 2B6B AF           		xor a
 730+ 2B6C 77           		ld (hl), a		; null terminate string
 731+ 2B6D
 732+ 2B6D CD 93 22     		call fClose
 733+ 2B70
 734+ 2B70 3A 01 34     fastLoad.chgDrv	ld a, (drvName)
 735+ 2B73 D6 60        		sub 'a'-1
 736+ 2B75 E6 1F        		and %00011111
 737+ 2B77 07           		rlca
 738+ 2B78 07           		rlca
 739+ 2B79 07           		rlca
 740+ 2B7A 47           		ld b, a
 741+ 2B7B 3A 03 34     		ld a, (drvName+2)
 742+ 2B7E E6 07        		and %00000111
 743+ 2B80 B0           		or b
 744+ 2B81 CD 06 23     		call fGetSetDrv		; change drive
 745+ 2B84
 746+ 2B84 CD 05 23     fastLoad.updDrv	call fGetSetDrv1	; get current drive
 747+ 2B87
 748+ 2B87 21 01 34     		ld hl, drvName
 749+ 2B8A CD 1F 26     		call convDrv
 750+ 2B8D
 751+ 2B8D              		//ld de, dbdwTbExtAct
 752+ 2B8D              		//jp doAct.exeAction
 753+ 2B8D C3 26 29     		jp doAct.exeAction1
 754+ 2B90
 755+ 2B90              ; =============================================================================
 756+ 2B90              ; 'G' debug --- revisado
 757+ 2B90              ; =============================================================================
 758+ 2B90              ;
 759+ 2B90 01 17 01     debug.start	ld bc, 1*256+23		; 1 line from line 23
 760+ 2B93 3E 38        		ld a, COL_BOT		; color
 761+ 2B95 CD 21 24     		call clrScr
 762+ 2B98 21 1A 33     		ld hl, msgStat
 763+ 2B9B CD C9 24     		call prStr
 764+ 2B9E
 765+ 2B9E 21 35 37     		ld hl, dotCommMon
 766+ 2BA1 CD EE 22     		call fExecCMD	; (should not return)
 767+ 2BA4
 768+ 2BA4 C3 0B 20     		jp mainL1		; reload dir and reprint all
 769+ 2BA7
 770+ 2BA7              ; =============================================================================
 771+ 2BA7              ; 'H' help --- revisado, view_SCR tiene un ret, viewSCR un jp mainL2. REMODELAR?
 772+ 2BA7              ; =============================================================================
 773+ 2BA7              ;
 774+ 2BA7 31 00 5C     help.start	ld sp, NMI_STACK		; necessary to use MACROS
 775+ 2BAA              		JUMPPG 6, page6.help
 775+ 2BAA             >
 775+ 2BAA             >		//ld	hl, .RunPgL1
 775+ 2BAA             >		//push	hl
 775+ 2BAA             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 775+ 2BAA             >		//push	hl
 775+ 2BAA 21 F2 20    >		ld	hl, page6.help
 775+ 2BAD E5          >		push	hl
 775+ 2BAE 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 775+ 2BB1 E5          >		push	hl
 775+ 2BB2 3E 06       >		ld	a, 6
 775+ 2BB4 C9          >		ret
 775+ 2BB5             >//.RunPgL1
 776+ 2BB5
 777+ 2BB5              ; =============================================================================
 778+ 2BB5              ; 'I',''SS'+'I' tapein --- revisado
 779+ 2BB5              ; =============================================================================
 780+ 2BB5              ;
 781+ 2BB5 CD B9 23     tapein.start	call ckMods
 782+ 2BB8 3A 78 31     		ld a, (flagSS)
 783+ 2BBB B7           		or a
 784+ 2BBC 28 17        		jr z, tapein.attach	; z no SS pressed, nz SS pressed
 785+ 2BBE
 786+ 2BBE CD 26 23     tapein.detach	call fDetachTapeIn
 787+ 2BC1
 788+ 2BC1 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
 789+ 2BC4 3E 38        		ld a, COL_BOT		; color
 790+ 2BC6 CD 21 24     		call clrScr
 791+ 2BC9 21 31 34     		ld hl, msgDetIn
 792+ 2BCC CD C9 24     		call prStr
 793+ 2BCF CD 51 23     		call waitKey
 794+ 2BD2
 795+ 2BD2 C3 20 20     		jp mainL4		; reprint bottom and cursor
 796+ 2BD5
 797+ 2BD5 3A 89 31     tapein.attach	ld a, (bDAttr)
 798+ 2BD8 E6 10        		and A_DIR		; check if is dir
 799+ 2BDA 28 03        		jr z, tapein.isFile
 800+ 2BDC
 801+ 2BDC C3 26 20     tapein.isDir	jp mainL5		; reprint nothing
 802+ 2BDF
 803+ 2BDF 21 8A 31     tapein.isFile	ld hl, bDName
 804+ 2BE2 CD 1C 23     		call fAttachTapeIn
 805+ 2BE5
 806+ 2BE5 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
 807+ 2BE8 3E 38        		ld a, COL_BOT		; color
 808+ 2BEA CD 21 24     		call clrScr
 809+ 2BED 21 09 34     		ld hl, msgAttIn
 810+ 2BF0 CD C9 24     		call prStr
 811+ 2BF3 CD 51 23     		call waitKey
 812+ 2BF6
 813+ 2BF6 C3 20 20     		jp mainL4		; reprint bottom and cursor
 814+ 2BF9
 815+ 2BF9              ; =============================================================================
 816+ 2BF9              ; 'J' load old NMI handler --- revisado
 817+ 2BF9              ; =============================================================================
 818+ 2BF9              ;
 819+ 2BF9 CD EB 25     loadOld.start	call restoreScreen
 820+ 2BFC CD 11 26     		call deleteScreen
 821+ 2BFF
 822+ 2BFF 2A 8B 35     		ld hl, (NMIbuf_org)
 823+ 2C02 22 69 2C     		ld (copyHL), hl
 824+ 2C05 2A 84 35     		ld hl, (savedSP)
 825+ 2C08 22 6B 2C     		ld (copySP), hl
 826+ 2C0B
 827+ 2C0B 3A 8A 35     		ld a, (esxDOSv)
 828+ 2C0E 32 62 2C     		ld (fnv), a
 829+ 2C11
 830+ 2C11 21 1F 2C     		ld hl, loader
 831+ 2C14 11 00 5B     		ld de, BACKED_UP_RAM	; $5b00
 832+ 2C17 01 4E 00     		ld bc, loaderEnd-loader
 833+ 2C1A ED B0        		ldir
 834+ 2C1C
 835+ 2C1C C3 00 5B     		jp BACKED_UP_RAM	; $5b00
 836+ 2C1F
 837+ 2C1F              		; No permite DISP anidados
 838+ 2C1F
 839+ 2C1F              fn_reloc	EQU BACKED_UP_RAM+fn-loader
 840+ 2C1F              fh_reloc	EQU BACKED_UP_RAM+fh-loader
 841+ 2C1F              hl_reloc	EQU BACKED_UP_RAM+copyHL-loader
 842+ 2C1F              sp_reloc	EQU BACKED_UP_RAM+copySP-loader
 843+ 2C1F              loadOld_reloc	EQU BACKED_UP_RAM+loadOld-loader
 844+ 2C1F
 845+ 2C1F              loader		;
 846+ 2C1F              		; loader runs at address MEM_TEST $5b00
 847+ 2C1F              		;
 848+ 2C1F
 849+ 2C1F 31 00 5C     		ld sp, NMI_STACK	; $5c00
 850+ 2C22
 851+ 2C22              		//ld hl, loadOld_reloc	;
 852+ 2C22              		//push hl		;
 853+ 2C22              		//RETPG0		; return to page 0
 854+ 2C22              		JUMPPG 0, loadOld_reloc
 854+ 2C22             >
 854+ 2C22             >		//ld	hl, .RunPgL1
 854+ 2C22             >		//push	hl
 854+ 2C22             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 854+ 2C22             >		//push	hl
 854+ 2C22 21 0E 5B    >		ld	hl, loadOld_reloc
 854+ 2C25 E5          >		push	hl
 854+ 2C26 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 854+ 2C29 E5          >		push	hl
 854+ 2C2A 3E 00       >		ld	a, 0
 854+ 2C2C C9          >		ret
 854+ 2C2D             >//.RunPgL1
 855+ 2C2D
 856+ 2C2D              loadOld		//
 857+ 2C2D              		// these system calls should be as is, not change
 858+ 2C2D              		//
 859+ 2C2D 21 35 5B     		ld hl, fn_reloc		; asciiz string containg path and/or filename
 860+ 2C30 06 01        		ld b, FA_OPEN_EX|FA_READ; open if exists, else error
 861+ 2C32              					; read access
 862+ 2C32 3E 24        		ld a, SYS_DRIVE		; system drive
 863+ 2C34 CF           		rst $08			;
 864+ 2C35 9A           		db F_OPEN		; open file
 865+ 2C36 32 49 5B     		ld (fh_reloc), a	; file handle
 866+ 2C39
 867+ 2C39 21 00 2F     		ld hl, NMI_OVERLAY	; $2f00
 868+ 2C3C 01 00 0E     		ld bc, NMI_SIZE		; $0e00
 869+ 2C3F 3A 49 5B     		ld a, (fh_reloc)	; file handle
 870+ 2C42 CF           		rst $08			;
 871+ 2C43 9D           		db F_READ		; read buffer from file
 872+ 2C44
 873+ 2C44 3A 49 5B     		ld a, (fh_reloc)	; file handle
 874+ 2C47 CF           		rst $08			;
 875+ 2C48 9B           		db F_CLOSE		; close file
 876+ 2C49
 877+ 2C49 F3           		di
 878+ 2C4A ED 7B 4C 5B  		ld sp, (sp_reloc)
 879+ 2C4E 2A 4A 5B     		ld hl, (hl_reloc)
 880+ 2C51 C3 00 2F     		jp NMI_OVERLAY		; $2f00
 881+ 2C54
 882+ 2C54              ; ---------
 883+ 2C54              ; variables
 884+ 2C54              ; ---------
 885+ 2C54              ;
 886+ 2C54 2F 53 59 53  fn		DB '/SYS/NMI/OLD08'
 886+ 2C58 2F 4E 4D 49
 886+ 2C5C 2F 4F 4C 44
 886+ 2C60 30 38
 887+ 2C62 35 2E 53 59  fnv		DB '5.SYS',0
 887+ 2C66 53 00
 888+ 2C68 00           fh		DB 0
 889+ 2C69 00 00        copyHL		DW 0
 890+ 2C6B 00 00        copySP		DW 0
 891+ 2C6D
 892+ 2C6D              loaderEnd	EQU $
 893+ 2C6D
 894+ 2C6D              ; =============================================================================
 895+ 2C6D              ; 'K' configure navigation keys --- revisado
 896+ 2C6D              ; =============================================================================
 897+ 2C6D              ;
 898+ 2C6D 3E FF        config.start	ld a, $ff
 899+ 2C6F 32 28 37     		ld (ldConf), a			; force reload config
 900+ 2C72
 901+ 2C72 31 00 5C     		ld sp, NMI_STACK		; necessary to use MACROS
 902+ 2C75              		JUMPPG 6, page6.config
 902+ 2C75             >
 902+ 2C75             >		//ld	hl, .RunPgL1
 902+ 2C75             >		//push	hl
 902+ 2C75             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 902+ 2C75             >		//push	hl
 902+ 2C75 21 00 20    >		ld	hl, page6.config
 902+ 2C78 E5          >		push	hl
 902+ 2C79 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 902+ 2C7C E5          >		push	hl
 902+ 2C7D 3E 06       >		ld	a, 6
 902+ 2C7F C9          >		ret
 902+ 2C80             >//.RunPgL1
 903+ 2C80
 904+ 2C80              ; =============================================================================
 905+ 2C80              ; 'L' lock paging register --- revisado
 906+ 2C80              ; =============================================================================
 907+ 2C80              ;
 908+ 2C80
 909+ 2C80 ~            /* ----------------------------------------------------------------------------
 910+ 2C80 ~              The additional memory features of the 128K/+2 are controlled to by writes to
 911+ 2C80 ~              port 0x7ffd
 912+ 2C80 ~
 913+ 2C80 ~              Bits 0-2: RAM page (0-7) to map into memory at 0xc000.
 914+ 2C80 ~              Bit 3: Select normal (0) or shadow (1) screen to be displayed. The normal
 915+ 2C80 ~                     screen is in bank 5, whilst the shadow screen is in bank 7. Note that
 916+ 2C80 ~                     this does not affect the memory between 0x4000 and 0x7fff, which is
 917+ 2C80 ~                     always bank 5.
 918+ 2C80 ~              Bit 4: ROM select. ROM 0 is the 128k editor and menu system; ROM 1 contains
 919+ 2C80 ~                     48K BASIC.
 920+ 2C80 ~              Bit 5: If set, memory paging will be disabled and further output to this port
 921+ 2C80 ~                     will be ignored until the computer is reset.
 922+ 2C80 ~
 923+ 2C80 ~              Like -l option of SNAPload dot command
 924+ 2C80 ~            ---------------------------------------------------------------------------- */
 925+ 2C80
 926+ 2C80 3A 82 35     lock.start	ld a, (flgLOCK)
 927+ 2C83 B7           		or a
 928+ 2C84 CA 26 20     		jp z, mainL5		; reprint nothing
 929+ 2C87
 930+ 2C87 3A 88 35     		ld a, (speccyRAM)
 931+ 2C8A FE 02        		cp 2
 932+ 2C8C C2 26 20     		jp nz, mainL5		; reprint nothing
 933+ 2C8F AF           		xor a
 934+ 2C90 32 82 35     		ld (flgLOCK), a
 935+ 2C93
 936+ 2C93 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
 937+ 2C96 3E 38        		ld a, COL_BOT		; color
 938+ 2C98 CD 21 24     		call clrScr
 939+ 2C9B 21 31 33     		ld hl, msgLocking
 940+ 2C9E CD C9 24     		call prStr
 941+ 2CA1
 942+ 2CA1 3E 30        		ld a, %00110000		; paging register locked, ROM 1 selected
 943+ 2CA3 01 FD 7F     		ld bc, $7ffd
 944+ 2CA6 ED 79        		out (c), a
 945+ 2CA8
 946+ 2CA8 C3 0B 20     		jp mainL1		; reprint bottom and cursor
 947+ 2CAB
 948+ 2CAB              ; =============================================================================
 949+ 2CAB              ; 'N' rename file --- revisado
 950+ 2CAB              ; =============================================================================
 951+ 2CAB              ;
 952+ 2CAB 01 17 01     rename.start	ld bc, 1*256+23		; 1 line from line 23
 953+ 2CAE 3E 38        		ld a, COL_BOT		; color
 954+ 2CB0 CD 21 24     		call clrScr
 955+ 2CB3 21 63 33     		ld hl, msgNewN
 956+ 2CB6 CD C9 24     		call prStr
 957+ 2CB9              		;
 958+ 2CB9              		; enter new name
 959+ 2CB9              		;
 960+ 2CB9 06 0C        		ld b, 12
 961+ 2CBB 21 52 35     		ld hl, dbFnNewFileName
 962+ 2CBE C5           renL2		push bc
 963+ 2CBF E5           		push hl
 964+ 2CC0 CD 51 23     		call waitKey
 965+ 2CC3 E1           		pop hl
 966+ 2CC4 C1           		pop bc
 967+ 2CC5 FE 1C        		cp K_BREAK
 968+ 2CC7 CA 20 20     		jp z, mainL4		; BREAK, reprint bottom and cursor
 969+ 2CCA FE 0D        		cp K_ENTER
 970+ 2CCC 28 37        		jr z, renL3		; ENTER
 971+ 2CCE FE 0C        		cp K_DELETE
 972+ 2CD0 20 19        		jr nz, renL4		; DEL
 973+ 2CD2 78           		ld a, b
 974+ 2CD3 FE 0C        		cp 12
 975+ 2CD5 28 E7        		jr z, renL2
 976+ 2CD7 04           		inc b
 977+ 2CD8 2B           		dec hl
 978+ 2CD9 3A 7C 31     		ld a, (col)
 979+ 2CDC 3D           		dec a
 980+ 2CDD 32 7C 31     		ld (col), a
 981+ 2CE0 3E 20        		ld a, ' '		;
 982+ 2CE2 C5           		push bc			;
 983+ 2CE3 E5           		push hl			;
 984+ 2CE4 CD 3D 25     		call pr_64		;
 985+ 2CE7 E1           		pop hl			;
 986+ 2CE8 C1           		pop bc			; print a space at cursor position
 987+ 2CE9 18 D3        		jr renL2
 988+ 2CEB FE 80        renL4		cp $80			; SPECIAL KEYS
 989+ 2CED 30 CF        		jr nc, renL2
 990+ 2CEF FE 20        		cp ' '			; SPECIAL KEYS
 991+ 2CF1 38 CB        		jr c,  renL2
 992+ 2CF3              		;
 993+ 2CF3 4F           		ld c, a
 994+ 2CF4 78           		ld a, b
 995+ 2CF5 B7           		or a
 996+ 2CF6 79           		ld a, c
 997+ 2CF7 28 C5        		jr z, renL2
 998+ 2CF9              		;
 999+ 2CF9 77           		ld (hl), a
1000+ 2CFA 23           		inc hl
1001+ 2CFB              		;
1002+ 2CFB C5           		push bc
1003+ 2CFC E5           		push hl
1004+ 2CFD CD DC 24     		call prChr
1005+ 2D00 E1           		pop hl
1006+ 2D01 C1           		pop bc
1007+ 2D02              		;
1008+ 2D02 05           		dec b
1009+ 2D03 18 B9        		jr renL2
1010+ 2D05              		;
1011+ 2D05 AF           renL3		xor a
1012+ 2D06 77           		ld (hl), a		; null terminate name string
1013+ 2D07              		;
1014+ 2D07 21 8A 31     		ld hl, bDName		; asciiz string containg source path and/or filename
1015+ 2D0A 11 52 35     		ld de, dbFnNewFileName	; asciiz string containg target path and/or filename
1016+ 2D0D CD D0 22     		call fRename
1017+ 2D10
1018+ 2D10 C3 0B 20     		jp mainL1		; reload dir and reprint all
1019+ 2D13
1020+ 2D13              ; =============================================================================
1021+ 2D13              ; 'O','SS'+'O' tapeout --- revisado
1022+ 2D13              ; =============================================================================
1023+ 2D13              ;
1024+ 2D13 CD B9 23     tapeout.start	call ckMods
1025+ 2D16 3A 78 31     		ld a, (flagSS)
1026+ 2D19 B7           		or a
1027+ 2D1A 28 17        		jr z, tapeout.attach	; z no SS pressed, nz SS pressed
1028+ 2D1C
1029+ 2D1C CD 35 23     tapeout.detach	call fDetachTapeOut
1030+ 2D1F
1031+ 2D1F 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
1032+ 2D22 3E 38        		ld a, COL_BOT		; color
1033+ 2D24 CD 21 24     		call clrScr
1034+ 2D27 21 84 34     		ld hl, msgDetOut
1035+ 2D2A CD C9 24     		call prStr
1036+ 2D2D CD 51 23     		call waitKey
1037+ 2D30
1038+ 2D30 C3 20 20     		jp mainL4		; reprint bottom and cursor
1039+ 2D33
1040+ 2D33 3A 89 31     tapeout.attach	ld a, (bDAttr)
1041+ 2D36 E6 10        		and A_DIR		; check if is dir
1042+ 2D38 28 03        		jr z, tapeout.isFile
1043+ 2D3A
1044+ 2D3A C3 26 20     tapeout.isDir	jp mainL5		; reprint nothing
1045+ 2D3D
1046+ 2D3D 21 8A 31     tapeout.isFile	ld hl, bDName
1047+ 2D40 CD 2B 23     		call fAttachTapeOut
1048+ 2D43
1049+ 2D43 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
1050+ 2D46 3E 38        		ld a, COL_BOT		; color
1051+ 2D48 CD 21 24     		call clrScr
1052+ 2D4B 21 5B 34     		ld hl, msgAttOut
1053+ 2D4E CD C9 24     		call prStr
1054+ 2D51 CD 51 23     		call waitKey
1055+ 2D54
1056+ 2D54 C3 20 20     		jp mainL4		; reprint bottom and cursor
1057+ 2D57
1058+ 2D57              ; =============================================================================
1059+ 2D57              ; 'P' poke --- revisado
1060+ 2D57              ; =============================================================================
1061+ 2D57              ;
1062+ 2D57              ; try a FSM? at first it seems that it may need more code...
1063+ 2D57
1064+ 2D57 21 00 00     poke.start	ld hl, 0
1065+ 2D5A 22 FC 37     		ld (pokeAdd), hl
1066+ 2D5D 22 FE 37     		ld (pokeVal), hl
1067+ 2D60 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
1068+ 2D63 3E 38        		ld a, COL_BOT		; color
1069+ 2D65 CD 21 24     		call clrScr
1070+ 2D68 21 3F 33     		ld hl, msgPok1
1071+ 2D6B CD C9 24     		call prStr
1072+ 2D6E
1073+ 2D6E              		;
1074+ 2D6E              		; get poke
1075+ 2D6E              		;
1076+ 2D6E              		;
1077+ 2D6E              		; get address
1078+ 2D6E              		;
1079+ 2D6E 21 48 35     		ld hl, dbStrPokeValue
1080+ 2D71 06 05        		ld b, 5
1081+ 2D73 E5           pokeG0		push hl
1082+ 2D74 C5           		push bc
1083+ 2D75 CD 51 23     		call waitKey
1084+ 2D78 C1           		pop bc
1085+ 2D79 E1           		pop hl
1086+ 2D7A FE 1C        		cp K_BREAK		; BREAK
1087+ 2D7C CA 83 2E     		jp z, retPoke
1088+ 2D7F FE 2C        		cp ','
1089+ 2D81 28 34        		jr z, pokeG3		; ','
1090+ 2D83
1091+ 2D83 FE 0C        		cp K_DELETE
1092+ 2D85 20 16        		jr nz, pokeG2		; DEL
1093+ 2D87 78           		ld a, b
1094+ 2D88 FE 05        		cp 5
1095+ 2D8A 28 E7        		jr z, pokeG0
1096+ 2D8C 04           pokeG1		inc b
1097+ 2D8D 2B           		dec hl
1098+ 2D8E C5           		push bc
1099+ 2D8F E5           		push hl
1100+ 2D90 21 7C 31     		ld hl, col
1101+ 2D93 35           		dec (hl)
1102+ 2D94 3E 20        		ld a, ' '		;
1103+ 2D96 CD 3D 25     		call pr_64		; print a space at cursor position
1104+ 2D99 E1           		pop hl
1105+ 2D9A C1           		pop bc
1106+ 2D9B 18 D6        		jr pokeG0
1107+ 2D9D
1108+ 2D9D FE 30        pokeG2		cp '0'
1109+ 2D9F 38 D2        		jr c, pokeG0		;
1110+ 2DA1 FE 3A        		cp '9'+1		;
1111+ 2DA3 30 CE        		jr nc, pokeG0		; key between 0 and 9
1112+ 2DA5              		;
1113+ 2DA5 4F           		ld c, a
1114+ 2DA6 78           		ld a, b
1115+ 2DA7 B7           		or a
1116+ 2DA8 79           		ld a, c
1117+ 2DA9 28 C8        		jr z, pokeG0
1118+ 2DAB              		;
1119+ 2DAB 77           		ld (hl), a
1120+ 2DAC 23           		inc hl
1121+ 2DAD 05           		dec b
1122+ 2DAE              		;
1123+ 2DAE E5           		push hl
1124+ 2DAF C5           		push bc
1125+ 2DB0 CD DC 24     		call prChr
1126+ 2DB3 C1           		pop bc
1127+ 2DB4 E1           		pop hl
1128+ 2DB5              		;
1129+ 2DB5 18 BC        		jr pokeG0
1130+ 2DB7              		;
1131+ 2DB7 3E 2C        pokeG3		ld a, ','		;
1132+ 2DB9              		;                       ;
1133+ 2DB9 77           		ld (hl), a		;
1134+ 2DBA 23           		inc hl			; OPTIMIZAR
1135+ 2DBB              		;
1136+ 2DBB E5           		push hl
1137+ 2DBC CD DC 24     		call prChr
1138+ 2DBF E1           		pop hl
1139+ 2DC0              		;
1140+ 2DC0              		; get value
1141+ 2DC0              		;
1142+ 2DC0 06 03        		ld b, 3
1143+ 2DC2 E5           pokeG4		push hl
1144+ 2DC3 C5           		push bc
1145+ 2DC4 CD 51 23     		call waitKey
1146+ 2DC7 C1           		pop bc
1147+ 2DC8 E1           		pop hl
1148+ 2DC9 FE 1C        		cp K_BREAK		; BREAK
1149+ 2DCB CA 83 2E     		jp z, retPoke
1150+ 2DCE FE 0D        		cp K_ENTER
1151+ 2DD0 28 38        		jr z, pokeG7		; ENTER
1152+ 2DD2
1153+ 2DD2 FE 0C        		cp K_DELETE
1154+ 2DD4 20 1A        		jr nz, pokeG6		; DEL
1155+ 2DD6 78           		ld a, b
1156+ 2DD7 FE 03        		cp 3
1157+ 2DD9 20 04        		jr nz, pokeG5
1158+ 2DDB 06 FF        		ld b, $ff
1159+ 2DDD 18 AD        		jr pokeG1
1160+ 2DDF 04           pokeG5		inc b
1161+ 2DE0 2B           		dec hl
1162+ 2DE1 C5           		push bc
1163+ 2DE2 E5           		push hl
1164+ 2DE3 21 7C 31     		ld hl, col
1165+ 2DE6 35           		dec (hl)
1166+ 2DE7 3E 20        		ld a, ' '		;
1167+ 2DE9 CD 3D 25     		call pr_64		; print a space at cursor position
1168+ 2DEC E1           		pop hl
1169+ 2DED C1           		pop bc
1170+ 2DEE 18 D2        		jr pokeG4
1171+ 2DF0
1172+ 2DF0 FE 30        pokeG6		cp '0'
1173+ 2DF2 38 CE        		jr c, pokeG4		;
1174+ 2DF4 FE 3A        		cp '9'+1		;
1175+ 2DF6 30 CA        		jr nc, pokeG4		; key between 0 and 9
1176+ 2DF8              		;
1177+ 2DF8 4F           		ld c, a
1178+ 2DF9 78           		ld a, b
1179+ 2DFA B7           		or a
1180+ 2DFB 79           		ld a, c
1181+ 2DFC 28 C4        		jr z, pokeG4
1182+ 2DFE              		;
1183+ 2DFE 77           		ld (hl), a
1184+ 2DFF 23           		inc hl
1185+ 2E00 05           		dec b
1186+ 2E01              		;
1187+ 2E01 E5           		push hl
1188+ 2E02 C5           		push bc
1189+ 2E03 CD DC 24     		call prChr
1190+ 2E06 C1           		pop bc
1191+ 2E07 E1           		pop hl
1192+ 2E08              		;
1193+ 2E08 18 B8        		jr pokeG4
1194+ 2E0A
1195+ 2E0A AF           pokeG7		xor a
1196+ 2E0B 77           		ld (hl), a		; null terminate string
1197+ 2E0C
1198+ 2E0C              		;
1199+ 2E0C              		; convert
1200+ 2E0C              		;
1201+ 2E0C              		;
1202+ 2E0C              		; convert address
1203+ 2E0C              		;
1204+ 2E0C 21 48 35     		ld hl, dbStrPokeValue
1205+ 2E0F 7E           pokeC0		ld a, (hl)
1206+ 2E10 FE 2C        		cp ','
1207+ 2E12 28 17        		jr z, pokeC1
1208+ 2E14              		;
1209+ 2E14 E5           		push hl
1210+ 2E15 2A FC 37     		ld hl, (pokeAdd)
1211+ 2E18 29           		add hl, hl
1212+ 2E19 54           		ld d, h
1213+ 2E1A 5D           		ld e, l
1214+ 2E1B 29           		add hl, hl
1215+ 2E1C 29           		add hl, hl
1216+ 2E1D 19           		add hl, de
1217+ 2E1E D6 30        		sub '0'
1218+ 2E20 16 00        		ld d, 0
1219+ 2E22 5F           		ld e, a
1220+ 2E23 19           		add hl, de
1221+ 2E24 22 FC 37     		ld (pokeAdd), hl
1222+ 2E27 E1           		pop hl
1223+ 2E28              		;
1224+ 2E28 23           		inc hl
1225+ 2E29 18 E4        		jr pokeC0
1226+ 2E2B              		;
1227+ 2E2B 23           pokeC1		inc hl
1228+ 2E2C              		;
1229+ 2E2C              		; convert value
1230+ 2E2C              		;
1231+ 2E2C 7E           pokeC2		ld a, (hl)
1232+ 2E2D B7           		or a
1233+ 2E2E 28 17        		jr z, pokeC3		; NULL
1234+ 2E30              		;
1235+ 2E30 E5           		push hl
1236+ 2E31 2A FE 37     		ld hl, (pokeVal)
1237+ 2E34 29           		add hl, hl
1238+ 2E35 54           		ld d, h
1239+ 2E36 5D           		ld e, l
1240+ 2E37 29           		add hl, hl
1241+ 2E38 29           		add hl, hl
1242+ 2E39 19           		add hl, de
1243+ 2E3A D6 30        		sub '0'
1244+ 2E3C 16 00        		ld d, 0
1245+ 2E3E 5F           		ld e, a
1246+ 2E3F 19           		add hl, de
1247+ 2E40 22 FE 37     		ld (pokeVal), hl
1248+ 2E43 E1           		pop hl
1249+ 2E44              		;
1250+ 2E44 23           		inc hl
1251+ 2E45 18 E5        		jr pokeC2
1252+ 2E47              pokeC3		;
1253+ 2E47              		; confirm poke
1254+ 2E47              		;
1255+ 2E47 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
1256+ 2E4A 3E 38        		ld a, COL_BOT		; color
1257+ 2E4C CD 21 24     		call clrScr
1258+ 2E4F 21 49 33     		ld hl, msgPok2
1259+ 2E52 CD C9 24     		call prStr
1260+ 2E55 2A FC 37     		ld hl, (pokeAdd)
1261+ 2E58 CD C3 24     		call utoa
1262+ 2E5B 21 52 33     		ld hl, msgPok3
1263+ 2E5E CD C9 24     		call prStr
1264+ 2E61 2A FE 37     		ld hl, (pokeVal)
1265+ 2E64 26 00        		ld h, 0
1266+ 2E66 CD C3 24     		call utoa
1267+ 2E69 21 54 33     		ld hl, msgPok4
1268+ 2E6C CD C9 24     		call prStr
1269+ 2E6F              		;
1270+ 2E6F CD 51 23     		call waitKey
1271+ 2E72 FE 59        		cp 'Y'
1272+ 2E74 20 0D        		jr nz, retPoke
1273+ 2E76              		;
1274+ 2E76 CD EB 25     		call restoreScreen
1275+ 2E79              		;
1276+ 2E79 3A FE 37     		ld a, (pokeVal)
1277+ 2E7C 2A FC 37     		ld hl, (pokeAdd)
1278+ 2E7F 77           		ld (hl), a
1279+ 2E80              		;
1280+ 2E80 CD C5 25     		call saveScreen
1281+ 2E83              		;
1282+ 2E83 C3 12 20     retPoke		jp mainL2		; reprint all (top, mid, bottom and cursor)
1283+ 2E86
1284+ 2E86              ; =============================================================================
1285+ 2E86              ; 'R' reset --- revisado
1286+ 2E86              ; =============================================================================
1287+ 2E86              ;
1288+ 2E86              ; taken from NMI.sys of ub880d
1289+ 2E86
1290+ 2E86 01 17 01     reset.start	ld bc, 1*256+23		; 1 line from line 23
1291+ 2E89 3E 38        		ld a, COL_BOT		; color
1292+ 2E8B CD 21 24     		call clrScr
1293+ 2E8E 21 71 33     		ld hl, msgReseting
1294+ 2E91 CD C9 24     		call prStr
1295+ 2E94
1296+ 2E94 F3           		di
1297+ 2E95 ED 7B 84 35  		ld sp, (savedSP)
1298+ 2E99 3E FE        		ld a, $fe		; a = $fe reset
1299+ 2E9B CD FF 22     		call fAutoLoad	; (should not return)
1300+ 2E9E
1301+ 2E9E C3 0B 20     		jp mainL1		; reload dir and reprint all
1302+ 2EA1
1303+ 2EA1              ; =============================================================================
1304+ 2EA1              ; 'S' save snapshot --- revisado
1305+ 2EA1              ; =============================================================================
1306+ 2EA1              ;
1307+ 2EA1 01 17 01     savSNA.start	ld bc, 1*256+23		; 1 line from line 23
1308+ 2EA4 3E 38        		ld a, COL_BOT		; color
1309+ 2EA6 CD 21 24     		call clrScr
1310+ 2EA9 21 80 33     		ld hl, msgSave
1311+ 2EAC CD C9 24     		call prStr
1312+ 2EAF
1313+ 2EAF              		; check if file exists
1314+ 2EAF
1315+ 2EAF 21 5F 35     savSNA.fileExt	ld hl, dbFnSnapName	; asciiz string containg path and/or filename
1316+ 2EB2 06 01        		ld b, FA_OPEN_EX|FA_READ
1317+ 2EB4              					; Open if exists, else error
1318+ 2EB4              					; Read access
1319+ 2EB4 3E 2A        		ld a, CUR_DRIVE		; current drive
1320+ 2EB6 CF           		rst $08			;
1321+ 2EB7 9A           		db F_OPEN		; open file
1322+ 2EB8 38 15        		jr c, savSNA.saveL1	; file don't exists
1323+ 2EBA CD 93 22     		call fClose		; file exists
1324+ 2EBD              		;
1325+ 2EBD              		; increments file name
1326+ 2EBD              		;
1327+ 2EBD              		; e.g. SNAP0000.SNA -> SNAP0001.SNA and so on
1328+ 2EBD              		;
1329+ 2EBD 21 66 35     		ld hl, dbFnSnapName+7
1330+ 2EC0 06 04        		ld b, 4
1331+ 2EC2 7E           savSNA.saveL0	ld a, (hl)
1332+ 2EC3 3C           		inc a
1333+ 2EC4 77           		ld (hl), a
1334+ 2EC5 FE 3A        		cp '9'+1
1335+ 2EC7 20 E6        		jr nz, savSNA.fileExt
1336+ 2EC9 3E 30        		ld a, '0'
1337+ 2ECB 77           		ld (hl), a
1338+ 2ECC 2B           		dec hl
1339+ 2ECD 10 F3        		djnz savSNA.saveL0
1340+ 2ECF
1341+ 2ECF CD EB 25     savSNA.saveL1	call restoreScreen
1342+ 2ED2
1343+ 2ED2 21 5F 35     		ld hl, dbFnSnapName	; asciiz string containg path and/or filename
1344+ 2ED5 06 06        		ld b, FA_CREATE_NEW|FA_WRITE
1345+ 2ED7              					; create if not exists, if exists error
1346+ 2ED7              					; write access
1347+ 2ED7 CD 6B 22     		call fOpen
1348+ 2EDA
1349+ 2EDA              		; SNA 48k
1350+ 2EDA
1351+ 2EDA 21 8D 35     		ld hl, NMIbuf		; source
1352+ 2EDD 01 1B 00     		ld bc, 27		; size
1353+ 2EE0 CD 7F 22     		call fWrite
1354+ 2EE3
1355+ 2EE3 21 00 40     		ld hl, 16384		; source
1356+ 2EE6 01 00 C0     		ld bc, 49152		; size
1357+ 2EE9 CD 7F 22     		call fWrite
1358+ 2EEC
1359+ 2EEC 3A 88 35     		ld a, (speccyRAM)	; check if 128k machine
1360+ 2EEF FE 02        		cp 2
1361+ 2EF1 20 55        		jr nz, savSNA.saveL4
1362+ 2EF3
1363+ 2EF3              		; SNA 128k
1364+ 2EF3
1365+ 2EF3              ; Version       RAM SIZE        PC      RAM pg act      TR-DOS
1366+ 2EF3              ; 0.8.5         +30             +27     +29             +30
1367+ 2EF3              ; 0.8.6         +27             +28     +30             +31
1368+ 2EF3
1369+ 2EF3 21 8D 35     		ld hl, NMIbuf		; source
1370+ 2EF6 11 1B 00     		ld de, 27
1371+ 2EF9 3A 8A 35     		ld a, (esxDOSv)
1372+ 2EFC FE 35        		cp '5'
1373+ 2EFE 28 03        		jr z, savSNA.v085_L1
1374+ 2F00 11 1C 00     		ld de, 28
1375+ 2F03 19           savSNA.v085_L1	add hl, de
1376+ 2F04 01 04 00     		ld bc, 4		; size
1377+ 2F07 CD 7F 22     		call fWrite
1378+ 2F0A
1379+ 2F0A              		; Save RAM pages. Taken from NMI.sys of ub880d
1380+ 2F0A
1381+ 2F0A 21 8D 35     		ld hl, NMIbuf		; source
1382+ 2F0D 11 1D 00     		ld de, 29
1383+ 2F10 3A 8A 35     		ld a, (esxDOSv)
1384+ 2F13 FE 35        		cp '5'
1385+ 2F15 28 03        		jr z, savSNA.v085_L2
1386+ 2F17 11 1E 00     		ld de, 30
1387+ 2F1A 19           savSNA.v085_L2	add hl, de
1388+ 2F1B
1389+ 2F1B 7E           		ld a, (hl)		; NMI_BUFFER+30: RAM bank paged in @ $c000
1390+ 2F1C F5           		push af
1391+ 2F1D 01 FD 7F     		ld bc, $7FFD
1392+ 2F20 ED 79        		out (c), a
1393+ 2F22 06 10        		ld b, $10		; Select ROM 1, contains 48K BASIC
1394+ 2F24 B0           		or b
1395+ 2F25 4F           		ld c, a
1396+ 2F26 78           		ld a, b
1397+ 2F27 FE 12        savSNA.saveL2	cp $12			; discard RAM bank 2
1398+ 2F29 28 17        		jr z, savSNA.saveL3
1399+ 2F2B FE 15        		cp $15			; discard RAM bank 5
1400+ 2F2D 28 13        		jr z, savSNA.saveL3
1401+ 2F2F B9           		cp c			; discard RAM bank paged in @ $c000
1402+ 2F30 28 10        		jr z, savSNA.saveL3
1403+ 2F32 C5           		push bc
1404+ 2F33 01 FD 7F     		ld bc, $7FFD		; select RAM bank
1405+ 2F36 ED 79        		out (c), a		; page RAM bank
1406+ 2F38 21 00 C0     		ld hl, 49152
1407+ 2F3B 01 00 40     		ld bc, 16384
1408+ 2F3E CD 7F 22     		call fWrite		; OJO, hay 2 bytes en la pila
1409+ 2F41 C1           		pop bc
1410+ 2F42 04           savSNA.saveL3	inc b
1411+ 2F43 78           		ld a, b
1412+ 2F44 FE 18        		cp $18
1413+ 2F46 20 DF        		jr nz, savSNA.saveL2	; repeat for all RAM banks
1414+ 2F48
1415+ 2F48              		;
1416+ 2F48
1417+ 2F48 F1           savSNA.saveL4	pop af			;
1418+ 2F49 01 FD 7F     		ld bc, $7FFD		;
1419+ 2F4C ED 79        		out (c), a		; repage original bank
1420+ 2F4E
1421+ 2F4E CD 93 22     		call fClose
1422+ 2F51
1423+ 2F51 C3 0B 20     		jp mainL1		; reload dir and reprint all
1424+ 2F54
1425+ 2F54              ; =============================================================================
1426+ 2F54              ; 'U' change current drive (cycling) --- revisado
1427+ 2F54              ; =============================================================================
1428+ 2F54              ;
1429+ 2F54 CD 05 23     seldrv.start	call fGetSetDrv1	; get current drive
1430+ 2F57 3C           		inc a			; try to change to next drive
1431+ 2F58
1432+ 2F58 CF           		rst $08
1433+ 2F59 89           		db M_GETSETDRV
1434+ 2F5A D2 63 2F     		jp nc, seldrv.noErr	; if no error, print drive name and exit
1435+ 2F5D
1436+ 2F5D CD 46 27     		call findDrv
1437+ 2F60 CD 06 23     		call fGetSetDrv
1438+ 2F63
1439+ 2F63 21 01 34     seldrv.noErr	ld hl, drvName
1440+ 2F66 CD 1F 26     		call convDrv
1441+ 2F69
1442+ 2F69 01 17 01     		ld bc, 1*256+23		; 1 line from line 23
1443+ 2F6C 3E 38        		ld a, COL_BOT		; color
1444+ 2F6E CD 21 24     		call clrScr
1445+ 2F71 21 E9 33     		ld hl, msgOkSelDrv
1446+ 2F74 CD C9 24     		call prStr
1447+ 2F77 CD 51 23     		call waitKey
1448+ 2F7A
1449+ 2F7A C3 0B 20     		jp mainL1		; reload dir and reprint all
1450+ 2F7D
1451+ 2F7D              ; =============================================================================
1452+ 2F7D              ; 'V', 'SS'+'V' view screen SCR SNA --- revisado
1453+ 2F7D              ; =============================================================================
1454+ 2F7D              ;
1455+ 2F7D 3A 89 31     view.start	ld a, (bDAttr)
1456+ 2F80 E6 10        		and A_DIR		; check if is dir
1457+ 2F82 28 03        		jr z, view.isFile
1458+ 2F84
1459+ 2F84 C3 26 20     view.isDir	jp mainL5		; reprint nothing
1460+ 2F87
1461+ 2F87 01 17 01     view.isFile	ld bc, 1*256+23		; 1 line from line 23
1462+ 2F8A 3E 38        		ld a, COL_BOT		; color
1463+ 2F8C CD 21 24     		call clrScr
1464+ 2F8F 21 AE 33     		ld hl, msgFile
1465+ 2F92 CD C9 24     		call prStr		; LOADING FILE...
1466+ 2F95
1467+ 2F95 21 8A 31     		ld hl, bDName		;
1468+ 2F98 11 6B 37     		ld de, dbStrPathName	;
1469+ 2F9B 01 0D 00     		ld bc, 8+1+3+1		;
1470+ 2F9E ED B0        		ldir			; copy filename
1471+ 2FA0
1472+ 2FA0 11 3C 32     		ld de, dbdwTbExtView
1473+ 2FA3 C3 29 29     		jp doAct.exeAction
1474+ 2FA6
# file closed: actions.asm
 130  2FA6
 131  2FA6              		; -------------------------------------------------------------
 132  2FA6              		; DATA
 133  2FA6              		; -------------------------------------------------------------
 134  2FA6
 135  2FA6              		include "shareddata.asm"
# file opened: shareddata.asm
   1+ 2FA6              ;==============================================================================
   2+ 2FA6              ; Project: NMI.zdsp
   3+ 2FA6              ; File: shareddata.asm
   4+ 2FA6              ; Date: 03/11/2022 19:30:30
   5+ 2FA6              ;
   6+ 2FA6              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2FA6              ;
   8+ 2FA6              ;==============================================================================
   9+ 2FA6
  10+ 2FA6              ;==============================================================================
  11+ 2FA6              ; DATA
  12+ 2FA6              ;==============================================================================
  13+ 2FA6
  14+ 2FA6              ; -------------------
  15+ 2FA6              ; half width 4x7 font
  16+ 2FA6              ; -------------------
  17+ 2FA6              ;
  18+ 2FA6              ; 50 x 7 = 350 bytes
  19+ 2FA6              ;
  20+ 2FA6 02 02 02 02  dbTbFont	DB $02,$02,$02,$02,$00,$02,$00; SPACE !
  20+ 2FAA 00 02 00
  21+ 2FAD 52 57 02 02  		DB $52,$57,$02,$02,$07,$02,$00; " #
  21+ 2FB1 07 02 00
  22+ 2FB4 25 71 62 32  		DB $25,$71,$62,$32,$74,$25,$00; $ %
  22+ 2FB8 74 25 00
  23+ 2FBB 22 42 30 50  		DB $22,$42,$30,$50,$50,$30,$00; & '
  23+ 2FBF 50 30 00
  24+ 2FC2 14 22 41 41  		DB $14,$22,$41,$41,$41,$22,$14; ( )
  24+ 2FC6 41 22 14
  25+ 2FC9 20 70 22 57  		DB $20,$70,$22,$57,$02,$00,$00; * +
  25+ 2FCD 02 00 00
  26+ 2FD0 00 00 00 07  		DB $00,$00,$00,$07,$00,$20,$20; , -
  26+ 2FD4 00 20 20
  27+ 2FD7 01 01 02 02  		DB $01,$01,$02,$02,$04,$14,$00; . /
  27+ 2FDB 04 14 00
  28+ 2FDE 22 56 52 52  		DB $22,$56,$52,$52,$52,$27,$00; 0 1
  28+ 2FE2 52 27 00
  29+ 2FE5 27 51 12 21  		DB $27,$51,$12,$21,$45,$72,$00; 2 3
  29+ 2FE9 45 72 00
  30+ 2FEC 57 54 56 71  		DB $57,$54,$56,$71,$15,$12,$00; 4 5
  30+ 2FF0 15 12 00
  31+ 2FF3 17 21 61 52  		DB $17,$21,$61,$52,$52,$22,$00; 6 7
  31+ 2FF7 52 22 00
  32+ 2FFA 22 55 25 53  		DB $22,$55,$25,$53,$52,$24,$00; 8 9
  32+ 2FFE 52 24 00
  33+ 3001 00 00 22 00  		DB $00,$00,$22,$00,$00,$22,$02; : ;
  33+ 3005 00 22 02
  34+ 3008 00 10 27 40  		DB $00,$10,$27,$40,$27,$10,$00; < =
  34+ 300C 27 10 00
  35+ 300F 02 45 21 12  		DB $02,$45,$21,$12,$20,$42,$00; > ?
  35+ 3013 20 42 00
  36+ 3016 23 55 75 77  		DB $23,$55,$75,$77,$45,$35,$00; @ A
  36+ 301A 45 35 00
  37+ 301D 63 54 64 54  		DB $63,$54,$64,$54,$54,$63,$00; B C
  37+ 3021 54 63 00
  38+ 3024 67 54 56 54  		DB $67,$54,$56,$54,$54,$67,$00; D E
  38+ 3028 54 67 00
  39+ 302B 73 44 64 45  		DB $73,$44,$64,$45,$45,$43,$00; F G
  39+ 302F 45 43 00
  40+ 3032 57 52 72 52  		DB $57,$52,$72,$52,$52,$57,$00; H I
  40+ 3036 52 57 00
  41+ 3039 35 15 16 55  		DB $35,$15,$16,$55,$55,$25,$00; J K
  41+ 303D 55 25 00
  42+ 3040 45 47 45 45  		DB $45,$47,$45,$45,$45,$75,$00; L M
  42+ 3044 45 75 00
  43+ 3047 62 55 55 55  		DB $62,$55,$55,$55,$55,$52,$00; N O
  43+ 304B 55 52 00
  44+ 304E 62 55 55 65  		DB $62,$55,$55,$65,$45,$43,$00; P Q
  44+ 3052 45 43 00
  45+ 3055 63 54 52 61  		DB $63,$54,$52,$61,$55,$52,$00; R S
  45+ 3059 55 52 00
  46+ 305C 75 25 25 25  		DB $75,$25,$25,$25,$25,$22,$00; T U
  46+ 3060 25 22 00
  47+ 3063 55 55 55 55  		DB $55,$55,$55,$55,$27,$25,$00; V W
  47+ 3067 27 25 00
  48+ 306A 55 55 25 22  		DB $55,$55,$25,$22,$52,$52,$00; X Y
  48+ 306E 52 52 00
  49+ 3071 73 12 22 22  		DB $73,$12,$22,$22,$42,$72,$03; Z [
  49+ 3075 42 72 03
  50+ 3078 46 42 22 22  		DB $46,$42,$22,$22,$12,$12,$06; \ ]
  50+ 307C 12 12 06
  51+ 307F 20 50 00 00  		DB $20,$50,$00,$00,$00,$00,$0F; ^ _
  51+ 3083 00 00 0F
  52+ 3086 20 10 03 05  		DB $20,$10,$03,$05,$05,$03,$00; sterling_pound a
  52+ 308A 05 03 00
  53+ 308D 40 40 63 54  		DB $40,$40,$63,$54,$54,$63,$00; b c
  53+ 3091 54 63 00
  54+ 3094 10 10 32 55  		DB $10,$10,$32,$55,$56,$33,$00; d e
  54+ 3098 56 33 00
  55+ 309B 10 20 73 25  		DB $10,$20,$73,$25,$25,$43,$06; f g
  55+ 309F 25 43 06
  56+ 30A2 42 40 66 52  		DB $42,$40,$66,$52,$52,$57,$00; h i
  56+ 30A6 52 57 00
  57+ 30A9 14 04 35 16  		DB $14,$04,$35,$16,$15,$55,$20; j k
  57+ 30AD 15 55 20
  58+ 30B0 60 20 25 27  		DB $60,$20,$25,$27,$25,$75,$00; l m
  58+ 30B4 25 75 00
  59+ 30B7 00 00 62 55  		DB $00,$00,$62,$55,$55,$52,$00; n o
  59+ 30BB 55 52 00
  60+ 30BE 00 00 63 55  		DB $00,$00,$63,$55,$55,$63,$41; p q
  60+ 30C2 55 63 41
  61+ 30C5 00 00 53 66  		DB $00,$00,$53,$66,$43,$46,$00; r s
  61+ 30C9 43 46 00
  62+ 30CC 00 20 75 25  		DB $00,$20,$75,$25,$25,$12,$00; t u
  62+ 30D0 25 12 00
  63+ 30D3 00 00 55 55  		DB $00,$00,$55,$55,$27,$25,$00; v w
  63+ 30D7 27 25 00
  64+ 30DA 00 00 55 25  		DB $00,$00,$55,$25,$25,$53,$06; x y
  64+ 30DE 25 53 06
  65+ 30E1 01 02 72 34  		DB $01,$02,$72,$34,$62,$72,$01; z {
  65+ 30E5 62 72 01
  66+ 30E8 24 22 22 21  		DB $24,$22,$22,$21,$22,$22,$04; | }
  66+ 30EC 22 22 04
  67+ 30EF 56 A9 06 04  		DB $56,$A9,$06,$04,$06,$09,$06; ~ copyright
  67+ 30F3 06 09 06
  68+ 30F6
  69+ 30F6              		;DB      $50,$20,$60,$50,$70,$55,$70     ; [?] [..]      128, 129
  70+ 30F6
  71+ 30F6              ; ---------
  72+ 30F6              ; key table
  73+ 30F6              ; ---------
  74+ 30F6              ;
  75+ 30F6              ; (5 x 3 + 1) x 8 + 1 = 129 bytes
  76+ 30F6              ; (5 x 4 + 1) x 8 + 1 = 169 bytes
  77+ 30F6              ;
  78+ 30F6 F7           dbTbKeys	DB $f7
  79+ 30F7 35 34 33 32  		DB '5', '4', '3', '2', '1'		; NORMAL
  79+ 30FB 31
  80+ 30FC 25 24 23 40  		DB '%', '$', '#', '@', '!'		; SS
  80+ 3100 21
  81+ 3101 08 00 00 00  		DB K_LEFT, $00, $00, $00, K_EDIT	; CS -> ESTO SON MAYUSCULAS, ME EQUIVOQUE Y PUSE EXTENDED MODE (E)
  81+ 3105 07
  82+ 3106              		;DB      $00, $00, $00, $00, $00	; E+SS
  83+ 3106 EF           		DB $ef
  84+ 3107 36 37 38 39  		DB '6', '7', '8', '9', '0'
  84+ 310B 30
  85+ 310C 26 27 28 29  		DB '&', $27, '(', ')', '_'
  85+ 3110 5F
  86+ 3111 0A 0B 09 00  		DB K_DOWN, K_UP, K_RIGHT, $00, K_DELETE
  86+ 3115 0C
  87+ 3116              		;DB      $00, $00, $00, $00, $00
  88+ 3116 FB           		DB $fb
  89+ 3117 54 52 45 57  		DB 'T', 'R', 'E', 'W', 'Q'
  89+ 311B 51
  90+ 311C 3E 3C 00 00  		DB '>', '<', $00, $00, $00
  90+ 3120 00
  91+ 3121 D5 00 00 00  		DB K_MERGE, $00, $00, $00, $00
  91+ 3125 00
  92+ 3126              		;DB      $00, $00, $00, $00, $00
  93+ 3126 DF           		DB $df
  94+ 3127 59 55 49 4F  		DB 'Y', 'U', 'I', 'O', 'P'
  94+ 312B 50
  95+ 312C 00 00 AC 3B  		DB $00, $00, K_AT, ';', '"'
  95+ 3130 22
  96+ 3131 5B 5D 00 00  		DB '[', ']', $00, $00, $7f
  96+ 3135 7F
  97+ 3136              		;DB      $00, $00, $00, $00, $00
  98+ 3136 FD           		DB $fd
  99+ 3137 47 46 44 53  		DB 'G', 'F', 'D', 'S', 'A'
  99+ 313B 41
 100+ 313C 00 CC 00 00  		DB $00, K_TO, $00, $00, $00
 100+ 3140 00
 101+ 3141 7D 7B 5C 7C  		DB '}', '{', '\', '|', '~'
 101+ 3145 7E
 102+ 3146              		;DB      $00, $00, $00, $00, $00
 103+ 3146 BF           		DB $bf
 104+ 3147 48 4A 4B 4C  		DB 'H', 'J', 'K', 'L', K_ENTER
 104+ 314B 0D
 105+ 314C 5E 2D 2B 3D  		DB '^', '-', '+', '=', K_SS_ENTER
 105+ 3150 1D
 106+ 3151 00 00 00 00  		DB $00, $00, $00, $00, K_CS_ENTER
 106+ 3155 1E
 107+ 3156              		;DB      $00, $00, $00, $00, $00
 108+ 3156 FE           		DB $fe
 109+ 3157 56 43 58 5A  		DB 'V', 'C', 'X', 'Z', $00		; CS IGNORED
 109+ 315B 00
 110+ 315C 2F 3F 60 3A  		DB '/', '?', $60, ':', $00
 110+ 3160 00
 111+ 3161 00 00 00 00  		DB $00, $00, $00, $00, $00
 111+ 3165 00
 112+ 3166              		;DB      $00, $00, $00, $00, $00
 113+ 3166 7F           		DB $7f
 114+ 3167 42 4E 4D 00  		DB 'B', 'N', 'M', $00, ' '		; SS IGNORED
 114+ 316B 20
 115+ 316C 2A 2C 2E 00  		DB '*', ',', '.', $00, $00
 115+ 3170 00
 116+ 3171 00 00 00 00  		DB $00, $00, $00, $00, K_BREAK
 116+ 3175 1C
 117+ 3176              		;DB      $00, $00, $00, $00, $00
 118+ 3176 00           		DB 0
 119+ 3177
 120+ 3177              ; --------------
 121+ 3177              ; keyboard flags
 122+ 3177              ; --------------
 123+ 3177              ;
 124+ 3177 00           flagCS		DB 0					; CS pressed
 125+ 3178 00           flagSS		DB 0					; SS pressed
 126+ 3179
 127+ 3179              ; ---------------
 128+ 3179              ; other variables
 129+ 3179              ; ---------------
 130+ 3179              ;
 131+ 3179 00           fhandle		DB 0			; file handle of files/dir opened by NMI.sys
 132+ 317A
 133+ 317A 00           flgAT		DB 0			; AT flag
 134+ 317B 00           row		DB 0			; row
 135+ 317C 00           col		DB 0			; col
 136+ 317D
 137+ 317D 00           prevJoy		DB 0			; previous joystroke
 138+ 317E 00           prevKey		DB 0			; previous keystroke
 139+ 317F
 140+ 317F 00 00 00...  utoaBuf		DS 6+1			; buffer to utoa function
 141+ 3186
 142+ 3186              //
 143+ 3186              // VARIABLES USED BY API CALLS (PAGE 5)
 144+ 3186              //
 145+ 3186
 146+ 3186 2E 2E 00     dotDot		DB '..', 0		; used to open/change to current/upper dir (./..)
 147+ 3189
 148+ 3189              ; ----------------
 149+ 3189              ; dir entry buffer
 150+ 3189              ; ----------------
 151+ 3189              ;
 152+ 3189              ; <byte>    attributes (like MSDOS)
 153+ 3189              ; <asciiz>  file/dirname
 154+ 3189              ; <DWord>   date
 155+ 3189              ; <DWord>   filesize
 156+ 3189              ;
 157+ 3189              ; date and filesize are relatives to the end of file/dirname asciiz string
 158+ 3189              ;
 159+ 3189              bufDir					; dir entry buffer
 160+ 3189 00           bDAttr		DB 0
 161+ 318A 00 00 00...  bDName		DS 8+1+3+1+4+4, 0	; set to possible max size
 162+ 319F
 163+ 319F 00 00 00...  buffer		DS 13			; buffer lo load TRD
 164+ 31AC              					; 'Virtual Disk', 0
 165+ 31AC
# file closed: shareddata.asm
 136  31AC              		include "data.asm"
# file opened: data.asm
   1+ 31AC              ;==============================================================================
   2+ 31AC              ; Project: NMI.zDSp
   3+ 31AC              ; File: data.asm
   4+ 31AC              ; Date: 29/08/2017 13:29:18
   5+ 31AC              ;
   6+ 31AC              ; Created with zDevStudio - Z80 Development Studio.
   7+ 31AC              ;
   8+ 31AC              ;==============================================================================
   9+ 31AC
  10+ 31AC              ;==============================================================================
  11+ 31AC              ; DATA
  12+ 31AC              ;==============================================================================
  13+ 31AC
  14+ 31AC              ; -----------------------
  15+ 31AC              ; navigator actions table
  16+ 31AC              ; -----------------------
  17+ 31AC              ;
  18+ 31AC 41           dbdwTbActions	DB 'A'			; attach TRD to drive A
  19+ 31AD 23 2A        		DW trd2drv.start0
  20+ 31AF 42           		DB 'B'			; attach TRD to drive B
  21+ 31B0 26 2A        		DW trd2drv.start1
  22+ 31B2 43           		DB 'C'			; attach TRD to drive C
  23+ 31B3 2A 2A        		DW trd2drv.start2
  24+ 31B5 44           		DB 'D'			; attach TRD to drive D
  25+ 31B6 2E 2A        		DW trd2drv.start3
  26+ 31B8 45           		DB 'E'			; erase file
  27+ 31B9 AB 2A        		DW delFile.start
  28+ 31BB 0C           		DB K_DELETE		; CS+0 erase file
  29+ 31BC AB 2A        		DW delFile.start
  30+ 31BE 46           		DB 'F'			; fast-ramp load
  31+ 31BF 41 2B        		DW fastLoad.start
  32+ 31C1 CC           		DB K_TO			; SS+F fast-ramp config
  33+ 31C2 DB 2A        		DW fastcfg.start
  34+ 31C4 47           		DB 'G'			; load mon dot command
  35+ 31C5 90 2B        		DW debug.start
  36+ 31C7 48           		DB 'H'			; show help
  37+ 31C8 A7 2B        		DW help.start
  38+ 31CA 49           		DB 'I'			; attach TAP to tapein
  39+ 31CB B5 2B        		DW tapein.start
  40+ 31CD AC           		DB K_AT			; SS+I detach TAP from tapein
  41+ 31CE B5 2B        		DW tapein.start
  42+ 31D0 4A           		DB 'J'			; load old NMI handler
  43+ 31D1 F9 2B        		DW loadOld.start
  44+ 31D3 4B           		DB 'K'			; config navigation keys
  45+ 31D4 6D 2C        		DW config.start
  46+ 31D6 4C           		DB 'L'			; paging register lock, ROM 1 select
  47+ 31D7 80 2C        		DW lock.start
  48+ 31D9              		//DB 'M'		; load module
  49+ 31D9              		//DW loadmod
  50+ 31D9 4E           		DB 'N'			; rename file
  51+ 31DA AB 2C        		DW rename.start
  52+ 31DC 4F           		DB 'O'			; attach TAP to tapeout
  53+ 31DD 13 2D        		DW tapeout.start
  54+ 31DF 3B           		DB ';'			; SS+O detach TAP from tapeout
  55+ 31E0 13 2D        		DW tapeout.start
  56+ 31E2 50           		DB 'P'			; poke memory
  57+ 31E3 57 2D        		DW poke.start
  58+ 31E5 52           		DB 'R'			; reset
  59+ 31E6 86 2E        		DW reset.start
  60+ 31E8 53           		DB 'S'			; create snapshot
  61+ 31E9 A1 2E        		DW savSNA.start
  62+ 31EB 54           		DB 'T'			; autostart vdisk, if no boot, loads TR-DOS Navigator
  63+ 31EC DC 29        		DW startTRDOS
  64+ 31EE 3E           		DB '>'			; SS+T load TR-DOS Navigator
  65+ 31EF DC 29        		DW startTRDOS
  66+ 31F1 D5           		DB K_MERGE		; CS+T enter TR-DOS mode
  67+ 31F2 DC 29        		DW startTRDOS
  68+ 31F4 55           		DB 'U'			; change to next valid drive (cycling)
  69+ 31F5 54 2F        		DW seldrv.start
  70+ 31F7 56           		DB 'V'			; view screen
  71+ 31F8 7D 2F        		DW view.start
  72+ 31FA 2F           		DB '/'			; SS+V view with hexview
  73+ 31FB 99 29        		DW viewHex
  74+ 31FD 07           		DB K_EDIT		; CS+1 up dir
  75+ 31FE 53 20        		DW upDir
  76+ 3200 08           kLeft		DB K_LEFT		; CS+5 prev page
  77+ 3201 AE 20        		DW prevPg
  78+ 3203 0A           kDown		DB K_DOWN		; CS+6 line down
  79+ 3204 80 20        		DW nextLn
  80+ 3206 0B           kUp		DB K_UP			; CS+7 line up
  81+ 3207 63 20        		DW prevLn
  82+ 3209 09           kRight		DB K_RIGHT		; CS+8 next page
  83+ 320A F2 20        		DW nextPg
  84+ 320C 0D           kEnter		DB K_ENTER		; do action
  85+ 320D F2 28        		DW doAct.start
  86+ 320F 1D           		DB K_SS_ENTER		; SS+ENTER do action
  87+ 3210 F2 28        		DW doAct.start
  88+ 3212 1E           		DB K_CS_ENTER		; CS+ENTER do action
  89+ 3213 F2 28        		DW doAct.start
  90+ 3215 1C           		DB K_BREAK		; CS+SPACE exit navigator
  91+ 3216 42 20        		DW exitNMI
  92+ 3218 00           		DB 0
  93+ 3219
  94+ 3219              ; ------------------------------------------
  95+ 3219              ; ext actions table (do action and fastload)
  96+ 3219              ; ------------------------------------------
  97+ 3219              ;
  98+ 3219 53 4E 41     dbdwTbExtAct	DB 'SNA'
  99+ 321C AD 29        		DW loadSNA
 100+ 321E 54 41 50     		DB 'TAP'
 101+ 3221 B6 29        		DW loadTAP
 102+ 3223 5A 38 30     		DB 'Z80'
 103+ 3226 AD 29        		DW loadSNA
 104+ 3228 42 41 53     		DB 'BAS'
 105+ 322B C4 29        		DW loadBAS
 106+ 322D 52 4F 4D     		DB 'ROM'
 107+ 3230 06 2A        		DW loadROM
 108+ 3232 54 52 44     extTRD		DB 'TRD'
 109+ 3235 CF 29        		DW loadTRD
 110+ 3237 53 43 4C     extSCL		DB 'SCL'
 111+ 323A CF 29        		DW loadTRD	; All functions for TRD runs with SCL
 112+ 323C              		; ------
 113+ 323C              		; viewer
 114+ 323C              		; ------
 115+ 323C 53 43 52     dbdwTbExtView	DB 'SCR'
 116+ 323F 6B 29        		DW viewSCR
 117+ 3241 53 4E 41     		DB 'SNA'	; Are different actions, ENTER and fastload
 118+ 3244 85 29        		DW viewSNA	; use the first in extTbl and V use this one in extTblV
 119+ 3246 00           		DB 0
 120+ 3247
 121+ 3247              ; ==============================================================================
 122+ 3247              ; MESSAGES
 123+ 3247              ; ==============================================================================
 124+ 3247              ;
 125+ 3247 16 0C 18 45  msgErr		DB $16,12,32-8,'ESXDOS error ', 0
 125+ 324B 53 58 44 4F
 125+ 324F 53 20 65 72
 125+ 3253 72 6F 72 20
 125+ 3257 00
 126+ 3258
 127+ 3258 16 00 01     msgTop1		DB $16,0,1
 128+ 325B 20 64 20 3A  msgDrv		DB ' d :'
 129+ 325F 2F           msgPath		DB '/'
 130+ 3260 00 00 00...  		DS 62-5
 131+ 3299 00           		DB 0
 132+ 329A
 133+ 329A 16 17 01 5B  msgBot1		DB $16,23,1,'[',0
 133+ 329E 00
 134+ 329F 2F 00        msgBot3		DB '/',0
 135+ 32A1 5D 00        msgBot4		DB ']',0
 136+ 32A3 16 17 13     msgBot5		DB $16,23,19
 137+ 32A6 20 20 20 20  msgLock		DB '         '
 137+ 32AA 20 20 20 20
 137+ 32AE 20
 138+ 32AF 20 20 20 20  msgRAM1		DB '     '
 138+ 32B3 20
 139+ 32B4 7C 20        		DB '| '
 140+ 32B6 20 20 20 20  msgVer		DB '              '
 140+ 32BA 20 20 20 20
 140+ 32BE 20 20 20 20
 140+ 32C2 20 20
 141+ 32C4 20 20 20 20  msgRAM2		DB '     '
 141+ 32C8 20
 142+ 32C9 7C 20        		DB '| '
 143+ 32CB              		M_VERSION
 143+ 32CB             >		//db 'v0.0.20'
 143+ 32CB 76 2D 2E 2D >		db 'v-.-.--'
 143+ 32CF 2E 2D 2D    >
 144+ 32D2 00           		DB 0
 145+ 32D3
 146+ 32D3 16 01 00 00  msgMid1		DB $16,1,0,0
 147+ 32D7 3C 44 49 52  msgMid2		DB '<DIR>',0
 147+ 32DB 3E 00
 148+ 32DD 16 01 0D 00  msgMid4		DB $16,1,8+1+3+1,0
 149+ 32E1
 150+ 32E1              ; ***
 151+ 32E1
 152+ 32E1 16 17 01 53  msgSaveFC 	DB $16,23,1,'SAVING FILE...', 0
 152+ 32E5 41 56 49 4E
 152+ 32E9 47 20 46 49
 152+ 32ED 4C 45 2E 2E
 152+ 32F1 2E 00
 153+ 32F3
 154+ 32F3 16 17 01 44  msgOkDel	DB $16,23,1, 'DELETE (Y/N)? ',0
 154+ 32F7 45 4C 45 54
 154+ 32FB 45 20 28 59
 154+ 32FF 2F 4E 29 3F
 154+ 3303 20 00
 155+ 3305 16 17 01 44  msgDel		DB $16,23,1, 'DELETING FILES...',0
 155+ 3309 45 4C 45 54
 155+ 330D 49 4E 47 20
 155+ 3311 46 49 4C 45
 155+ 3315 53 2E 2E 2E
 155+ 3319 00
 156+ 331A
 157+ 331A 16 17 01 4C  msgStat		DB $16,23,1,'LOADING DEBUGGER...',0
 157+ 331E 4F 41 44 49
 157+ 3322 4E 47 20 44
 157+ 3326 45 42 55 47
 157+ 332A 47 45 52 2E
 157+ 332E 2E 2E 00
 158+ 3331
 159+ 3331 16 17 01 4C  msgLocking	DB $16,23,1,'LOCKING...',0
 159+ 3335 4F 43 4B 49
 159+ 3339 4E 47 2E 2E
 159+ 333D 2E 00
 160+ 333F
 161+ 333F 16 17 01 50  msgPok1		DB $16,23,1, 'POKE? ',0
 161+ 3343 4F 4B 45 3F
 161+ 3347 20 00
 162+ 3349 16 17 01 50  msgPok2		DB $16,23,1, 'POKE ',0
 162+ 334D 4F 4B 45 20
 162+ 3351 00
 163+ 3352 2C 00        msgPok3		DB ',',0
 164+ 3354 20 41 50 50  msgPok4		DB ' APPLY (Y/N)? ',0
 164+ 3358 4C 59 20 28
 164+ 335C 59 2F 4E 29
 164+ 3360 3F 20 00
 165+ 3363
 166+ 3363 16 17 01 4E  msgNewN		DB $16,23,1, 'NEW NAME? ',0
 166+ 3367 45 57 20 4E
 166+ 336B 41 4D 45 3F
 166+ 336F 20 00
 167+ 3371
 168+ 3371 16 17 01 52  msgReseting	DB $16,23,1,'RESETING...',0
 168+ 3375 45 53 45 54
 168+ 3379 49 4E 47 2E
 168+ 337D 2E 2E 00
 169+ 3380
 170+ 3380 16 17 01 53  msgSave		DB $16,23,1,'SAVING SNAPSHOT...',0
 170+ 3384 41 56 49 4E
 170+ 3388 47 20 53 4E
 170+ 338C 41 50 53 48
 170+ 3390 4F 54 2E 2E
 170+ 3394 2E 00
 171+ 3396
 172+ 3396 16 17 01 4C  msgDir		DB $16,23,1,'LOADING DIRECTORY...',0
 172+ 339A 4F 41 44 49
 172+ 339E 4E 47 20 44
 172+ 33A2 49 52 45 43
 172+ 33A6 54 4F 52 59
 172+ 33AA 2E 2E 2E 00
 173+ 33AE 16 17 01 4C  msgFile		DB $16,23,1,'LOADING FILE...',0
 173+ 33B2 4F 41 44 49
 173+ 33B6 4E 47 20 46
 173+ 33BA 49 4C 45 2E
 173+ 33BE 2E 2E 00
 174+ 33C1
 175+ 33C1 16 17 01 46  msgTypeErr	DB $16,23,1,'FILE TYPE NOT SUPPORTED, PRESS A KEY',0
 175+ 33C5 49 4C 45 20
 175+ 33C9 54 59 50 45
 175+ 33CD 20 4E 4F 54
 175+ 33D1 20 53 55 50
 175+ 33D5 50 4F 52 54
 175+ 33D9 45 44 2C 20
 175+ 33DD 50 52 45 53
 175+ 33E1 53 20 41 20
 175+ 33E5 4B 45 59 00
 176+ 33E9
 177+ 33E9
 178+ 33E9 16 17 01 53  msgOkSelDrv	DB $16,23,1,'SET DEFAULT DRIVE TO '
 178+ 33ED 45 54 20 44
 178+ 33F1 45 46 41 55
 178+ 33F5 4C 54 20 44
 178+ 33F9 52 49 56 45
 178+ 33FD 20 54 4F 20
 179+ 3401 20 64 20 3A  drvName		DB ' d :...',0
 179+ 3405 2E 2E 2E 00
 180+ 3409
 181+ 3409 16 17 01 54  msgAttIn	DB $16,23,1, 'TAP ATTACHED TO INPUT, PRESS ANY KEY',0
 181+ 340D 41 50 20 41
 181+ 3411 54 54 41 43
 181+ 3415 48 45 44 20
 181+ 3419 54 4F 20 49
 181+ 341D 4E 50 55 54
 181+ 3421 2C 20 50 52
 181+ 3425 45 53 53 20
 181+ 3429 41 4E 59 20
 181+ 342D 4B 45 59 00
 182+ 3431 16 17 01 54  msgDetIn	DB $16,23,1, 'TAP DETACHED FROM INPUT, PRESS ANY KEY',0
 182+ 3435 41 50 20 44
 182+ 3439 45 54 41 43
 182+ 343D 48 45 44 20
 182+ 3441 46 52 4F 4D
 182+ 3445 20 49 4E 50
 182+ 3449 55 54 2C 20
 182+ 344D 50 52 45 53
 182+ 3451 53 20 41 4E
 182+ 3455 59 20 4B 45
 182+ 3459 59 00
 183+ 345B
 184+ 345B 16 17 01 54  msgAttOut	DB $16,23,1, 'TAP ATTACHED TO OUTPUT, PRESS ANY KEY',0
 184+ 345F 41 50 20 41
 184+ 3463 54 54 41 43
 184+ 3467 48 45 44 20
 184+ 346B 54 4F 20 4F
 184+ 346F 55 54 50 55
 184+ 3473 54 2C 20 50
 184+ 3477 52 45 53 53
 184+ 347B 20 41 4E 59
 184+ 347F 20 4B 45 59
 184+ 3483 00
 185+ 3484 16 17 01 54  msgDetOut	DB $16,23,1, 'TAP DETACHED FROM OUTPUT, PRESS ANY KEY',0
 185+ 3488 41 50 20 44
 185+ 348C 45 54 41 43
 185+ 3490 48 45 44 20
 185+ 3494 46 52 4F 4D
 185+ 3498 20 4F 55 54
 185+ 349C 50 55 54 2C
 185+ 34A0 20 50 52 45
 185+ 34A4 53 53 20 41
 185+ 34A8 4E 59 20 4B
 185+ 34AC 45 59 00
 186+ 34AF
 187+ 34AF 16 17 01 54  msgOk		DB $16,23,1, 'TRD ATTACHED TO UNIT '
 187+ 34B3 52 44 20 41
 187+ 34B7 54 54 41 43
 187+ 34BB 48 45 44 20
 187+ 34BF 54 4F 20 55
 187+ 34C3 4E 49 54 20
 188+ 34C7 41 2C 20 50  unitLet		DB 'A, PRESS ANY KEY',0
 188+ 34CB 52 45 53 53
 188+ 34CF 20 41 4E 59
 188+ 34D3 20 4B 45 59
 188+ 34D7 00
 189+ 34D8
 190+ 34D8 16 0C 01 44  msg0001		DB $16,12,1,'DR SLUMP NMI NAVIGATOR'
 190+ 34DC 52 20 53 4C
 190+ 34E0 55 4D 50 20
 190+ 34E4 4E 4D 49 20
 190+ 34E8 4E 41 56 49
 190+ 34EC 47 41 54 4F
 190+ 34F0 52
 191+ 34F1 16 0C 38     msg0002		DB $16,12,56
 192+ 34F4              		M_VERSION
 192+ 34F4             >		//db 'v0.0.20'
 192+ 34F4 76 2D 2E 2D >		db 'v-.-.--'
 192+ 34F8 2E 2D 2D    >
 193+ 34FB 00           		DB 0
 194+ 34FC              //msg0003		DB $16,4,1,'DEFINE KEYS: '//,0
 195+ 34FC              //msg0004		DB $16,6,1,'KEY FOR UP? ',0
 196+ 34FC              //msg0005		DB $16,7,1,'KEY FOR DOWN? ',0
 197+ 34FC              //msg0006		DB $16,8,1,'KEY FOR LEFT? ',0
 198+ 34FC              //msg0007		DB $16,9,1,'KEY FOR RIGHT? ',0
 199+ 34FC              //msg0008		DB $16,10,1,'KEY FOR ENTER? ',0
 200+ 34FC              //msgHapp		DB $16,12,1,'HAPPY (Y/N)? ',0
 201+ 34FC
 202+ 34FC              ;==============================================================================
 203+ 34FC              ; ACTIONS DATA
 204+ 34FC              ;==============================================================================
 205+ 34FC
 206+ 34FC 31 36 4B     msg16k		DB '16K'
 207+ 34FF 34 38 4B     msg48k		DB '48K'
 208+ 3502 31 32 38 4B  msg128k		DB '128K'
 209+ 3506
 210+ 3506 55 4E 4C 4F  msgUnlocked	DB 'UNLOCKED  '
 210+ 350A 43 4B 45 44
 210+ 350E 20 20
 211+ 3510
 212+ 3510 2F 54 4D 50  dbFnBackupFile	DB '/TMP/_NMI_BAK.SCR', 0
 212+ 3514 2F 5F 4E 4D
 212+ 3518 49 5F 42 41
 212+ 351C 4B 2E 53 43
 212+ 3520 52 00
 213+ 3522
 214+ 3522 2F 53 59 53  dbFnConfigFile	DB '/SYS/NMI/NMI.CNF',0
 214+ 3526 2F 4E 4D 49
 214+ 352A 2F 4E 4D 49
 214+ 352E 2E 43 4E 46
 214+ 3532 00
 215+ 3533 2F 53 59 53  dbFnFastFile	DB '/SYS/NMI/FASTCFG.TXT',0
 215+ 3537 2F 4E 4D 49
 215+ 353B 2F 46 41 53
 215+ 353F 54 43 46 47
 215+ 3543 2E 54 58 54
 215+ 3547 00
 216+ 3548
 217+ 3548              //dbFnHelFile1	DB '/SYS/NMI/HELP1.SCR',0
 218+ 3548              //dbFnHelFile2	DB '/SYS/NMI/HELP2.SCR',0
 219+ 3548              //dbFnHelFile3	DB '/SYS/NMI/HELP3.SCR',0
 220+ 3548
 221+ 3548 31 32 33 34  dbStrPokeValue	DB '12345,123',0
 221+ 354C 35 2C 31 32
 221+ 3550 33 00
 222+ 3552
 223+ 3552 31 32 33 34  dbFnNewFileName	DB '12345678.123',0
 223+ 3556 35 36 37 38
 223+ 355A 2E 31 32 33
 223+ 355E 00
 224+ 355F 53 4E 41 50  dbFnSnapName	DB 'SNAP0000.SNA',0
 224+ 3563 30 30 30 30
 224+ 3567 2E 53 4E 41
 224+ 356B 00
 225+ 356C
 226+ 356C              //unavail	DB 'ABCDEFGHIJKLMNOPRSUV',K_DELETE,K_TO,K_EDIT
 227+ 356C              //		DB K_AT,';',K_SS_ENTER,K_CS_ENTER
 228+ 356C              //usedK		DB 0,0,0,0,0
 229+ 356C
 230+ 356C 2F 53 59 53  trdBas		DB '/SYS/NMI/TRDN.BAS', 0
 230+ 3570 2F 4E 4D 49
 230+ 3574 2F 54 52 44
 230+ 3578 4E 2E 42 41
 230+ 357C 53 00
 231+ 357E
 232+ 357E 20 47 4D 4B  prefix		DB ' GMK'		; prefixes for filesizes
 233+ 3582
 234+ 3582              ; ---------
 235+ 3582              ; key names
 236+ 3582              ; ---------
 237+ 3582              ;
 238+ 3582              //mDelete		DB 'DELETE',0
 239+ 3582              //mSpace		DB 'SPACE',0
 240+ 3582              //mEnter		DB 'ENTER',0
 241+ 3582              //mBreak		DB 'BREAK',0
 242+ 3582              //mLeft		DB 'LEFT',0
 243+ 3582              //mRight		DB 'RIGHT',0
 244+ 3582              //mUp		DB 'UP',0
 245+ 3582              //mDown		DB 'DOWN',0
 246+ 3582              //mEdit		DB 'EDIT',0
 247+ 3582              //mTo		DB 'SS+F',0
 248+ 3582              //mSSEnt		DB 'SS+ENTER',0
 249+ 3582              //mCSEnt		DB 'CS+ENTER',0
 250+ 3582              //mAt		DB 'SS+I',0
 251+ 3582
 252+ 3582              ; ---------------
 253+ 3582              ; other variables
 254+ 3582              ; ---------------
 255+ 3582              ;
 256+ 3582 FF           flgLOCK		DB $ff			; flag to signal LOCK 48k mode
 257+ 3583 00           flgROOT		DB 0			; flag to signal root dir reached
 258+ 3584
 259+ 3584              ;
 260+ 3584              ; Order must be the same as in loader.asm
 261+ 3584              ;-------------------
 262+ 3584 00 00        savedSP		DW 0			; SP register saved on NMI navigator entry
 263+ 3586 00 00        divRAM		DW 0			; number of 8k RAM pages found
 264+ 3588 00           speccyRAM	DB 0			; flag to signal 128k speccy
 265+ 3589 00           savRAM		DB 0			; flag to signal screen saved to RAM
 266+ 358A 00           esxDOSv		DB 0			; version of esxDOS
 267+ 358B 00 00        NMIbuf_org	DW 0			; necessary for load old NMI handler
 268+ 358D              ;-------------------
 269+ 358D 00 00 00...  NMIbuf		DS 31			; NMI buffer
 270+ 35AC
 271+ 35AC              ; ----------------------------------
 272+ 35AC              ; variables for NMI navigator paging
 273+ 35AC              ; ----------------------------------
 274+ 35AC              ;
 275+ 35AC 00 00        curLn		DW 0			; current selected line (cursor line)
 276+ 35AE FB 35        pCurPg		DW pPrvDir		; pointer to current page first dir entry
 277+ 35B0 00 00        Xof		DW 0			; current dir entry (cursor line)
 278+ 35B2 00 00        Xlim		DW 0			; current page max dir entry (line number)
 279+ 35B4 00 00        ofY		DW 0			; total dir entries
 280+ 35B6
 281+ 35B6              ; -----------------------------------
 282+ 35B6              ; pointers to dir entry, current page
 283+ 35B6              ; -----------------------------------
 284+ 35B6              ;
 285+ 35B6              ; there are 23 entries because I need an additional pointer to the first dir
 286+ 35B6              ; entry of the next page
 287+ 35B6              ;
 288+ 35B6              ; chaged pointers from 4 bytes to 3 bytes long, on this version of esxDOS works
 289+ 35B6              ;
 290+ 35B6              		IFDEF _POINTER4BYTES
 291+ 35B6 ~            pCurDir		DS 4*23,0
 292+ 35B6              		ELSE
 293+ 35B6 00 00 00...  pCurDir		DS 3*23,0
 294+ 35FB              		ENDIF
 295+ 35FB
 296+ 35FB              ; -------------------------------------
 297+ 35FB              ; pointers to dir entry, previous pages
 298+ 35FB              ; -------------------------------------
 299+ 35FB              ;
 300+ 35FB              		IFDEF _POINTER4BYTES
 301+ 35FB ~            pPrvDir		DS (MAXENTR/22)*4,0
 302+ 35FB              		ELSE
 303+ 35FB 00 00 00...  pPrvDir		DS (MAXENTR/22)*3,0
 304+ 3727              		ENDIF
 305+ 3727
 306+ 3727 FF           ldInit		DB $ff			; flag to signal do initialization
 307+ 3728 FF           ldConf		DB $ff			; flag to signal load config from file
 308+ 3729 FF           ldDir		DB $ff			; flag to signal load dir
 309+ 372A
 310+ 372A 00           flgPopUp	DB 0			; 0 not show popup
 311+ 372B 00           flgOut		DB 0			; 0 not set default graphic mode
 312+ 372C 00           flgHidden	DB 0			; 0 not show hidden
 313+ 372D
 314+ 372D 00           strLen		DB 0			; current working directory string length
 315+ 372E
 316+ 372E              ; ------------
 317+ 372E              ; dot commands
 318+ 372E              ; ------------
 319+ 372E              ;
 320+ 372E 4F 57 4E 52  dotCommOwnrom	DB 'OWNROM', 0
 320+ 3732 4F 4D 00
 321+ 3735
 322+ 3735 4D 4F 4E 00  dotCommMon	DB 'MON',0
 323+ 3739
 324+ 3739 52 4D 20 2D  dotCommRm	DB 'RM -fr '		; -fr must be in lower case
 324+ 373D 66 72 20
 325+ 3740 00 00 00...  bDName2		DS 8+1+3+1
 326+ 374D
 327+ 374D 48 45 58 56  dotCommHexview	DB 'HEXVIEW '
 327+ 3751 49 45 57 20
 328+ 3755 00 00 00...  bDName3		DS 8+1+3+1
 329+ 3762
 330+ 3762 53 4E 41 50  dotCommSnapload	DB 'SNAPLOAD '
 330+ 3766 4C 4F 41 44
 330+ 376A 20
 331+ 376B 00 00 00...  dbStrPathName	DS 127+8+1+3+1		; A continuacion de dotCommSnapload	UNIFICABLE COMO DS
 332+ 37F7
 333+ 37F7              endData
 334+ 37F7
 335+ 37F7              ; ----------------------------------
 336+ 37F7              ; not initialized temporal variables
 337+ 37F7              ; ----------------------------------
 338+ 37F7              ;
 339+ 37F7              		//ORG dbStrPathName
 340+ 37F7
 341+ 37F7 00 00        pDSizeL		DW 0			; pointer to filesize on dir entry buffer L
 342+ 37F9 00 00        pDSizeH		DW 0			; pointer to filesize on dir entry buffer H
 343+ 37FB 00           prefixCnt	DB 0			; counter for filesize prefix
 344+ 37FC 00 00        pokeAdd		DW 0			; poke address				UNIFICABLE COMO DS
 345+ 37FE 00 00        pokeVal		DW 0			; poke value				UNIFICABLE COMO DS
 346+ 3800
 347+ 3800              		//ORG dbStrPathName
 348+ 3800
 349+ 3800 00           dbDrive		DB 0			; virtual drive number			UNIFICABLE COMO DS
 350+ 3801 00 00        dwPtrExt	DW 0			; pointer to extension			UNIFICABLE COMO DS
 351+ 3803
 352+ 3803              		//ORG dbStrPathName
 353+ 3803
 354+ 3803 00           flagT		DB 0			; init popup window			UNIFICABLE COMO DS
 355+ 3804
 356+ 3804              bufConf					; config buffer				UNIFICABLE COMO DS
 357+ 3804 00           cfPopUp		DB 0
 358+ 3805 00           cfLeft		DB 0
 359+ 3806 00           cfRight		DB 0
 360+ 3807 00           cfDown		DB 0
 361+ 3808 00           cfUp		DB 0
 362+ 3809 00           cfEnter		DB 0
 363+ 380A 00           cfOut		DB 0
 364+ 380B 00           cfHidden	DB 0
 365+ 380C
 366+ 380C              ; ----------------------------------
 367+ 380C
 368+ 380C              		//ORG endData
 369+ 380C
# file closed: data.asm
 137  380C
 138  380C              		; -------------------------------------------------------------
 139  380C              		IF $ > PAGE_START+PAGE_LENGTH
 140  380C ~            		LUA
 141  380C ~            		sj.error("Page ".._c("DivXXXPg")..": Resulting code too long ("
 142  380C ~            		..(_c("$")-(_c("PAGE_START")+_c("PAGE_LENGTH"))).." bytes)")
 143  380C ~            		ENDLUA
 144  380C              		ENDIF
 145  380C              		; -------------------------------------------------------------
 146  380C
 147  380C              		ENDMODULE
 148  380C
 149  380C              pg5end		ENT
 150  498E
 151  498E              ;==============================================================================
 152  498E              ; AUX - PAGE 6
 153  498E              ;==============================================================================
 154  498E
 155  498E              		UNDEFINE DivXXXPg
 156  498E              		DEFINE DivXXXPg 6
 157  498E              		DISP PAGE_START
 158  2000
 159  2000              offsetPg6	EQU $$$-NMI_OVERLAY	; offset relative to start of file
 160  2000              					; used to load page 6
 161  2000
 162  2000              pg6start	MODULE page6
 163  2000
 164  2000              		INCLUDE "page6code.asm"
# file opened: page6code.asm
   1+ 2000              ;==============================================================================
   2+ 2000              ; Project: NMI.zdsp
   3+ 2000              ; File: page6code.asm
   4+ 2000              ; Date: 03/11/2022 18:32:13
   5+ 2000              ;
   6+ 2000              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2000              ;
   8+ 2000              ;==============================================================================
   9+ 2000
  10+ 2000              ;==============================================================================
  11+ 2000              ; AUX - divXXX page 6
  12+ 2000              ;==============================================================================
  13+ 2000
  14+ 2000              ; =============================================================================
  15+ 2000              ; 'K' configure navigation keys --- revisado
  16+ 2000              ; =============================================================================
  17+ 2000              ;
  18+ 2000 01 00 03     config		ld bc, 3*256+0
  19+ 2003 3E 4F        		ld a, COL_CUR
  20+ 2005 CD C7 22     		call clrScr
  21+ 2008
  22+ 2008 01 03 15     		ld bc, 21*256+3
  23+ 200B 3E 07        		ld a, COL_MID
  24+ 200D CD C7 22     		call clrScr
  25+ 2010
  26+ 2010 CD 6B 24     		call readCnf
  27+ 2013
  28+ 2013 AF           		xor a
  29+ 2014 32 7E 2C     		ld (usedK), a
  30+ 2017 32 7F 2C     		ld (usedK+1), a
  31+ 201A 32 80 2C     		ld (usedK+2), a
  32+ 201D 32 81 2C     		ld (usedK+3), a
  33+ 2020 32 82 2C     		ld (usedK+4), a
  34+ 2023
  35+ 2023 21 36 27     		ld hl, msg0001
  36+ 2026 CD 6F 23     		call prStr
  37+ 2029
  38+ 2029 21 5A 27     		ld hl, msg0003
  39+ 202C CD 6F 23     		call prStr
  40+ 202F
  41+ 202F              		//ld hl, msg0004
  42+ 202F              		//call prStr
  43+ 202F CD DA 20     		call chkKey
  44+ 2032 32 D4 2C     		ld (cfUp), a
  45+ 2035 CD 99 24     		call prKeyName
  46+ 2038
  47+ 2038 21 7A 27     		ld hl, msg0005
  48+ 203B CD 6F 23     		call prStr
  49+ 203E CD DA 20     		call chkKey
  50+ 2041 32 D3 2C     		ld (cfDown), a
  51+ 2044 CD 99 24     		call prKeyName
  52+ 2047
  53+ 2047 21 8C 27     		ld hl, msg0006
  54+ 204A CD 6F 23     		call prStr
  55+ 204D CD DA 20     		call chkKey
  56+ 2050 32 D1 2C     		ld (cfLeft), a
  57+ 2053 CD 99 24     		call prKeyName
  58+ 2056
  59+ 2056 21 9E 27     		ld hl, msg0007
  60+ 2059 CD 6F 23     		call prStr
  61+ 205C CD DA 20     		call chkKey
  62+ 205F 32 D2 2C     		ld (cfRight), a
  63+ 2062 CD 99 24     		call prKeyName
  64+ 2065
  65+ 2065 21 B1 27     		ld hl, msg0008
  66+ 2068 CD 6F 23     		call prStr
  67+ 206B CD DA 20     		call chkKey
  68+ 206E 32 D5 2C     		ld (cfEnter), a
  69+ 2071 CD 99 24     		call prKeyName
  70+ 2074
  71+ 2074 21 C4 27     		ld hl, msg0009
  72+ 2077 CD 6F 23     		call prStr
  73+ 207A CD F7 21     		call waitKey
  74+ 207D F5           		push af
  75+ 207E CD 82 23     		call prChr
  76+ 2081 F1           		pop af
  77+ 2082 FE 59        		cp 'Y'
  78+ 2084 3E 00        		ld a, 0
  79+ 2086 C2 8A 20     		jp nz, configL1
  80+ 2089 3D           		dec a
  81+ 208A 32 D0 2C     configL1	ld (cfPopUp), a
  82+ 208D
  83+ 208D 21 E7 27     		ld hl, msg0010
  84+ 2090 CD 6F 23     		call prStr
  85+ 2093 CD F7 21     		call waitKey
  86+ 2096 F5           		push af
  87+ 2097 CD 82 23     		call prChr
  88+ 209A F1           		pop af
  89+ 209B FE 59        		cp 'Y'
  90+ 209D 3E 00        		ld a, 0
  91+ 209F C2 A3 20     		jp nz, configL2
  92+ 20A2 3D           		dec a
  93+ 20A3 32 D6 2C     configL2	ld (cfOut), a
  94+ 20A6
  95+ 20A6 21 11 28     		ld hl, msg0011
  96+ 20A9 CD 6F 23     		call prStr
  97+ 20AC CD F7 21     		call waitKey
  98+ 20AF F5           		push af
  99+ 20B0 CD 82 23     		call prChr
 100+ 20B3 F1           		pop af
 101+ 20B4 FE 59        		cp 'Y'
 102+ 20B6 3E 00        		ld a, $0
 103+ 20B8 C2 BC 20     		jp nz, configL3
 104+ 20BB 3D           		dec a
 105+ 20BC 32 D7 2C     configL3	ld (cfHidden), a
 106+ 20BF
 107+ 20BF 21 37 28     		ld hl, msgHapp
 108+ 20C2 CD 6F 23     		call prStr
 109+ 20C5 CD BF 22     		call wait
 110+ 20C8 CD F7 21     		call waitKey
 111+ 20CB F5           		push af
 112+ 20CC CD 82 23     		call prChr
 113+ 20CF F1           		pop af
 114+ 20D0 FE 59        		cp 'Y'
 115+ 20D2 C2 00 20     		jp nz, config
 116+ 20D5
 117+ 20D5 CD 82 24     		call writeCnf
 118+ 20D8
 119+ 20D8              exit		//ld sp, NMI_STACK	; necessary to use PAGING MACROS
 120+ 20D8              		//JUMPPG 5, page5.mainL1	; return to NMI navigator on page 5
 121+ 20D8 18 29        		jr helpEnd
 122+ 20DA
 123+ 20DA              ; ---------------------------------
 124+ 20DA              ; check not available and used keys
 125+ 20DA              ; ---------------------------------
 126+ 20DA              ;
 127+ 20DA CD F7 21     chkKey		call waitKey
 128+ 20DD FE 1C        		cp K_BREAK
 129+ 20DF 28 F7        		jr z, exit
 130+ 20E1 47           		ld b, a
 131+ 20E2 21 63 2C     		ld hl, unavail
 132+ 20E5 7E           chkKey1		ld a, (hl)
 133+ 20E6 B7           		or a
 134+ 20E7 28 06        		jr z, chkKey2		; end of used keys table
 135+ 20E9 B8           		cp b
 136+ 20EA 28 EE        		jr z, chkKey		; key already used
 137+ 20EC 23           		inc hl
 138+ 20ED 18 F6        		jr chkKey1		; test next used key
 139+ 20EF 70           chkKey2		ld (hl), b		; save key as used
 140+ 20F0 78           		ld a, b
 141+ 20F1 C9           		ret
 142+ 20F2
 143+ 20F2              ; =============================================================================
 144+ 20F2              ; 'H' help --- revisado, view_SCR tiene un ret, viewSCR un jp mainL2. REMODELAR?
 145+ 20F2              ; =============================================================================
 146+ 20F2              ;
 147+ 20F2 01 00 18     help		ld bc, 24*256+0
 148+ 20F5 3E 07        		ld a, COL_MID
 149+ 20F7 CD C7 22     		call clrScr
 150+ 20FA
 151+ 20FA 21 48 28     		ld hl, msgHelp
 152+ 20FD CD 6F 23     		call prStr
 153+ 2100 CD F7 21     		call waitKey
 154+ 2103
 155+ 2103 31 00 5C     helpEnd		ld sp, NMI_STACK	; necessary to use PAGING MACROS
 156+ 2106              		JUMPPG 5, page5.mainL1	; return to NMI navigator on page 5
 156+ 2106             >
 156+ 2106             >		//ld	hl, .RunPgL1
 156+ 2106             >		//push	hl
 156+ 2106             >		//ld	hl, $0dea		; ld a, 0; out ($e3), a; ld a, b; ret; switch to page 0
 156+ 2106             >		//push	hl
 156+ 2106 21 0B 20    >		ld	hl, page5.mainL1
 156+ 2109 E5          >		push	hl
 156+ 210A 21 E5 05    >		ld	hl, $05e5		; out ($e3), a; ret; switch to page a
 156+ 210D E5          >		push	hl
 156+ 210E 3E 05       >		ld	a, 5
 156+ 2110 C9          >		ret
 156+ 2111             >//.RunPgL1
 157+ 2111
 158+ 2111 ~            		/*
 159+ 2111 ~            helpL1		ld hl, dbFnHelFile1
 160+ 2111 ~            		call view_SCR
 161+ 2111 ~            		cp K_UP
 162+ 2111 ~            		jr z, helpL1
 163+ 2111 ~            		cp K_DOWN
 164+ 2111 ~            		jr z, helpL2
 165+ 2111 ~            		cp K_BREAK
 166+ 2111 ~            		jr z, helpEnd
 167+ 2111 ~
 168+ 2111 ~            helpL2		ld hl, dbFnHelFile2
 169+ 2111 ~            		call view_SCR
 170+ 2111 ~            		cp K_UP
 171+ 2111 ~            		jr z, helpL1
 172+ 2111 ~            		cp K_DOWN
 173+ 2111 ~            		jr z, helpL3
 174+ 2111 ~            		cp K_BREAK
 175+ 2111 ~            		jr z, helpEnd
 176+ 2111 ~
 177+ 2111 ~            helpL3		ld hl, dbFnHelFile3
 178+ 2111 ~            		call view_SCR
 179+ 2111 ~            		cp K_UP
 180+ 2111 ~            		jr z, helpL2
 181+ 2111 ~            		cp K_DOWN
 182+ 2111 ~            		jr z, helpEnd
 183+ 2111 ~            		cp K_BREAK
 184+ 2111 ~            		jr z, helpEnd
 185+ 2111 ~
 186+ 2111 ~            helpEnd		ld sp, NMI_STACK	; necessary to use PAGING MACROS
 187+ 2111 ~            		JUMPPG 5, page5.mainL1	; return to NMI navigator on page 5
 188+ 2111 ~
 189+ 2111 ~            ; -----------
 190+ 2111 ~            ; view screen
 191+ 2111 ~            ; -----------
 192+ 2111 ~            ;
 193+ 2111 ~            view_SCR	ld b, FA_OPEN_EX|FA_READ
 194+ 2111 ~            		ld a, SYS_DRIVE
 195+ 2111 ~            		call fOpen1
 196+ 2111 ~            		ld hl, 16384
 197+ 2111 ~            		ld bc, 6144+768
 198+ 2111 ~            		call fRead
 199+ 2111 ~            		call fClose
 200+ 2111 ~
 201+ 2111 ~            		call waitKey
 202+ 2111 ~
 203+ 2111 ~            		ret
 204+ 2111 ~            		*/
 205+ 2111
# file closed: page6code.asm
 165  2111
 166  2111              		; -------------------------------------------------------------
 167  2111              		; FUNCTIONS
 168  2111              		; -------------------------------------------------------------
 169  2111
 170  2111              		include "api.asm"
# file opened: api.asm
   1+ 2111              ;==============================================================================
   2+ 2111              ; Project: NMI.zdsp
   3+ 2111              ; File: api.asm
   4+ 2111              ; Date: 03/11/2022 20:41:05
   5+ 2111              ;
   6+ 2111              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2111              ;
   8+ 2111              ;==============================================================================
   9+ 2111
  10+ 2111              ; =============================================================================
  11+ 2111              ; API calls and error handler
  12+ 2111              ; =============================================================================
  13+ 2111
  14+ 2111              ; -----------------------------------------------------------------------------
  15+ 2111              ; API calls
  16+ 2111              ; -----------------------------------------------------------------------------
  17+ 2111              ;
  18+ 2111 3E 2A        fOpen		ld a, CUR_DRIVE		; current drive
  19+ 2113 CF           fOpen1		rst $08			; screen is saved allways in SYS_DRIVE
  20+ 2114 9A           		db F_OPEN		; open file
  21+ 2115 DA 03 25     		jp c, prError
  22+ 2118 32 F2 26     		ld (fhandle), a		; file handle
  23+ 211B C9           		ret
  24+ 211C
  25+ 211C 3A F2 26     fRead		ld a, (fhandle)		; file handle
  26+ 211F CF           		rst $08			;
  27+ 2120 9D           		db F_READ		; read buffer from file
  28+ 2121 DA FC 24     		jp c, closeFilePrErr
  29+ 2124 C9           		ret
  30+ 2125
  31+ 2125 3A F2 26     fWrite		ld a, (fhandle)		; file handle
  32+ 2128 CF           		rst $08			;
  33+ 2129 9E           		db F_WRITE		; write buffer to file
  34+ 212A DA FC 24     		jp c, closeFilePrErr
  35+ 212D C9           		ret
  36+ 212E
  37+ 212E 3A F2 26     fSeek		ld a, (fhandle)		; file handle
  38+ 2131 2E 00        		ld l, 0			; 0 from start of file
  39+ 2133              					; 1 fwd from current pos
  40+ 2133              					; 2 bak from current pos
  41+ 2133 CF           		rst $08
  42+ 2134 9F           		db F_SEEK
  43+ 2135 DA FC 24     		jp c, closeFilePrErr	; QUE SE HACE CON ESTO !!!
  44+ 2138 C9           		ret
  45+ 2139
  46+ 2139 3A F2 26     fClose		ld a, (fhandle)		; file handle
  47+ 213C CF           		rst $08			;
  48+ 213D 9B           		db F_CLOSE		; close file
  49+ 213E DA 03 25     		jp c, prError
  50+ 2141 C9           		ret
  51+ 2142
  52+ 2142              		;
  53+ 2142
  54+ 2142 3E 2A        fOpenDir	ld a, CUR_DRIVE		; current drive
  55+ 2144 06 00        		ld b, 0
  56+ 2146 21 00 27     		ld hl, dotDot+1		; '.'   ; cwdBuf is valid too
  57+ 2149 CF           		rst $08
  58+ 214A A3           		db F_OPENDIR
  59+ 214B DA 03 25     		jp c, prError
  60+ 214E 32 F2 26     		ld (fhandle), a
  61+ 2151 C9           		ret
  62+ 2152
  63+ 2152 21 02 27     fReadDir	ld hl, bufDir
  64+ 2155 3A F2 26     		ld a, (fhandle)		; file handle
  65+ 2158 CF           		rst $08			;
  66+ 2159 A4           		db F_READDIR		; read directory entry to buffer
  67+ 215A              		;jp c, closeFilePrErr
  68+ 215A C9           		ret			; error check is done in caller function
  69+ 215B              					; to detect end of directory
  70+ 215B
  71+ 215B 3A F2 26     fSeekDir	ld a, (fhandle)		; file handle
  72+ 215E CF           		rst $08			;
  73+ 215F A6           		db F_SEEKDIR		; set offset of directory
  74+ 2160 DA FC 24     		jp c, closeFilePrErr
  75+ 2163 C9           		ret
  76+ 2164
  77+ 2164 3A F2 26     fTellDir	ld a, (fhandle)		; file handle
  78+ 2167 CF           		rst $08			;
  79+ 2168 A5           		db F_TELLDIR		; get offset of directory
  80+ 2169 DA FC 24     		jp c, closeFilePrErr
  81+ 216C C9           		ret
  82+ 216D
  83+ 216D 3A F2 26     fRewindDir	ld a, (fhandle)
  84+ 2170 CF           		rst $08
  85+ 2171 A7           		db F_REWINDDIR
  86+ 2172 DA FC 24     		jp c, closeFilePrErr
  87+ 2175 C9           		ret
  88+ 2176
  89+ 2176 3E 2A        fRename		ld a, CUR_DRIVE		; current drive
  90+ 2178 CF           		rst $08
  91+ 2179 B0           		db F_RENAME
  92+ 217A DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
  93+ 217D C9           		ret
  94+ 217E
  95+ 217E              //fUnlink	ld a, CUR_DRIVE		; current drive
  96+ 217E              fUnlink1	; screen is saved allways in SYS_DRIVE
  97+ 217E CF           		rst $08
  98+ 217F AD           		db F_UNLINK		; open file
  99+ 2180 DA 03 25     		jp c, prError
 100+ 2183 C9           		ret
 101+ 2184
 102+ 2184 3E 2A        fChDir		ld a, CUR_DRIVE		; current drive
 103+ 2186 CF           		rst $08			;
 104+ 2187 A9           		db F_CHDIR		; change directory
 105+ 2188 DA 03 25     		jp c, prError
 106+ 218B C9           		ret
 107+ 218C
 108+ 218C 3E 2A        fGetCWD		ld a, CUR_DRIVE		; current drive
 109+ 218E CF           		rst $08
 110+ 218F A8           		db F_GETCWD		; get current working directory
 111+ 2190 DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
 112+ 2193 C9           		ret
 113+ 2194
 114+ 2194              fExecCMD	//
 115+ 2194              		//
 116+ 2194              		//
 117+ 2194 11 00 5B     		ld de, BACKED_UP_RAM	// $5b00
 118+ 2197 01 80 00     		ld bc, 128		// Para poder llamar desde la pagina 5
 119+ 219A ED B0        		ldir			//
 120+ 219C 21 00 5B     		ld hl, BACKED_UP_RAM	// $5b00
 121+ 219F CF           		rst $08
 122+ 21A0 8F           		db M_EXECCMD
 123+ 21A1 DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
 124+ 21A4 C9           		ret
 125+ 21A5
 126+ 21A5              fAutoLoad	; a = $00	LOAD "" (usually tapein)
 127+ 21A5              		; a > $00	HL = asciiz to file name, autoload from disk
 128+ 21A5              		; a = $fe	reset
 129+ 21A5              		; a = $fd	autoload from vdisk. If no boot, loads TR-DOS Navigator
 130+ 21A5              		; a = $fc	enter TR-DOS mode
 131+ 21A5 CF           		rst $08
 132+ 21A6 90           		db M_AUTOLOAD
 133+ 21A7 DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
 134+ 21AA C9           		ret
 135+ 21AB
 136+ 21AB AF           fGetSetDrv1	xor a			; a = 0 get current drive
 137+ 21AC CF           fGetSetDrv	rst $08
 138+ 21AD 89           		DB M_GETSETDRV
 139+ 21AE DA 03 25     		jp c, prError
 140+ 21B1 C9           		ret
 141+ 21B2
 142+ 21B2              fEjectVDisk	; a = drive 0, 1, 2, 3
 143+ 21B2              		; add a, a
 144+ 21B2              		; add a, a
 145+ 21B2              		; add a, a
 146+ 21B2              		; or $60
 147+ 21B2              		; a = virtual drive $60 (A), $68 (B), $70 (C), $78 (D)
 148+ 21B2 CF           		rst $08
 149+ 21B3 85           		db $85			; EJECT VDISK
 150+ 21B4              		;jr c, prError		; error if no disk attached, ignore it
 151+ 21B4 C9           		ret
 152+ 21B5
 153+ 21B5              fMountVDisk	; hl = pointer to asciiz TRD o SCL disk image
 154+ 21B5              		; a = virtual drive $60 (A), $68 (B), $70 (C), $78 (D)
 155+ 21B5 11 18 27     		ld de, buffer		; BUFFER: returns 'Virtual Disk', 0
 156+ 21B8 06 00        		ld b, 0
 157+ 21BA 0E 2A        		ld c, CUR_DRIVE		; current drive
 158+ 21BC CF           		rst $08
 159+ 21BD 80           		db DISK_STATUS		; MOUNT VDISK   ; $80
 160+ 21BE DA 03 25     		jp c, prError
 161+ 21C1 C9           		ret
 162+ 21C2
 163+ 21C2 06 00        fAttachTapeIn	ld b, 0			; in_open
 164+ 21C4              					; Attaches .tap file
 165+ 21C4              					; A=drive
 166+ 21C4              					; HL=Pointer to null-terminated string containg path and/or filename
 167+ 21C4 3E 2A        		ld a, CUR_DRIVE		; current drive
 168+ 21C6 CF           		rst $08
 169+ 21C7 8B           		db M_TAPEIN
 170+ 21C8 DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
 171+ 21CB C9           		ret
 172+ 21CC
 173+ 21CC 06 01        fDetachTapeIn	ld b, 1			; in_close
 174+ 21CE              					; No args, just closes and detaches .tap file
 175+ 21CE CF           		rst $08
 176+ 21CF 8B           		db M_TAPEIN
 177+ 21D0              		;jr c, prError		; error if no file attached, ignore it
 178+ 21D0 C9           		ret
 179+ 21D1
 180+ 21D1 06 00        fAttachTapeOut	ld b, 0			; out_open
 181+ 21D3              					; Creates/opens .tap file for appending
 182+ 21D3              					; A=drive
 183+ 21D3              					; HL=Pointer to null-terminated string containg path and/or filename
 184+ 21D3 3E 2A        		ld a, CUR_DRIVE		; current drive
 185+ 21D5 CF           		rst $08
 186+ 21D6 8C           		db M_TAPEOUT
 187+ 21D7 DA 03 25     		jp c, prError		; QUE SE HACE CON ESTO !!!
 188+ 21DA C9           		ret
 189+ 21DB
 190+ 21DB 06 01        fDetachTapeOut	ld b, 1			; out_close
 191+ 21DD              					; No args, just closes and detaches .tap file
 192+ 21DD CF           		rst $08
 193+ 21DE 8C           		db M_TAPEOUT
 194+ 21DF              		;jr c, prError		; error if no file attached, ignore it
 195+ 21DF C9           		ret
 196+ 21E0
# file closed: api.asm
 171  21E0              		include "sharedfunctions.asm"
# file opened: sharedfunctions.asm
   1+ 21E0              ;==============================================================================
   2+ 21E0              ; Project: NMI.zdsp
   3+ 21E0              ; File: sharedfunctions.asm
   4+ 21E0              ; Date: 03/11/2022 19:30:44
   5+ 21E0              ;
   6+ 21E0              ; Created with zDevStudio - Z80 Development Studio.
   7+ 21E0              ;
   8+ 21E0              ;==============================================================================
   9+ 21E0
  10+ 21E0              ;==============================================================================
  11+ 21E0              ; SPEAKER, KEYBOARD AND SCREEN FUNCTIONS
  12+ 21E0              ;==============================================================================
  13+ 21E0
  14+ 21E0              ; -----------------------------------------------------------------------------
  15+ 21E0              ; beep
  16+ 21E0              ;
  17+ 21E0              ; input:    -
  18+ 21E0              ; output:   -
  19+ 21E0              ; destroys: a, b
  20+ 21E0              ; -----------------------------------------------------------------------------
  21+ 21E0              ;
  22+ 21E0 06 02        beep		ld b, 2
  23+ 21E2 C5           beep01		push bc
  24+ 21E3 3E 10        		ld a, %00010000
  25+ 21E5 D3 FE        		out (0xfe), a
  26+ 21E7 06 1E        		ld b, 30
  27+ 21E9 10 FE        beep02		djnz beep02
  28+ 21EB 3E 00        		ld a, %00000000
  29+ 21ED D3 FE        		out (0xfe), a
  30+ 21EF 06 1E        		ld b, 30
  31+ 21F1 10 FE        beep03		djnz beep03
  32+ 21F3 C1           		pop bc
  33+ 21F4 10 EC        		djnz beep01
  34+ 21F6 C9           		ret
  35+ 21F7
  36+ 21F7              ; -----------------------------------------------------------------------------
  37+ 21F7              ; wait for key or mouse
  38+ 21F7              ;
  39+ 21F7              ; input:    -
  40+ 21F7              ; output:   a - key pressed
  41+ 21F7              ; destroys: af,bc,de,hl
  42+ 21F7              ; -----------------------------------------------------------------------------
  43+ 21F7              ;
  44+ 21F7 3A F6 26     waitKey		ld a, (prevJoy)
  45+ 21FA 06 06        		ld b, 6
  46+ 21FC 4F           _L1		ld c, a
  47+ 21FD C5           		push bc
  48+ 21FE CD 76 22     		call readJoy		; read joystick
  49+ 2201 C1           		pop bc
  50+ 2202 32 F6 26     		ld (prevJoy), a
  51+ 2205 B7           		or a
  52+ 2206 28 05        		jr z, _L2		; no joystroke
  53+ 2208 B9           		cp c
  54+ 2209 C0           		ret nz			; previous joystroke != actual joystroke
  55+ 220A 10 F0        		djnz _L1
  56+ 220C C9           		ret
  57+ 220D 3A F7 26     _L2		ld a, (prevKey)
  58+ 2210 06 06        		ld b, 6
  59+ 2212 4F           _L3		ld c, a
  60+ 2213 C5           		push bc
  61+ 2214 CD 23 22     		call readKey		; read keyboard
  62+ 2217 C1           		pop bc
  63+ 2218 32 F7 26     		ld (prevKey), a
  64+ 221B B7           		or a
  65+ 221C 28 D9        		jr z, waitKey		; no keystroke
  66+ 221E B9           		cp c
  67+ 221F C0           		ret nz			; previous keystroke != actual keystroke
  68+ 2220 10 F0        		djnz _L3
  69+ 2222 C9           		ret
  70+ 2223
  71+ 2223              ; -----------------------------------------------------------------------------
  72+ 2223              ; Read key
  73+ 2223              ;
  74+ 2223              ; input:    -
  75+ 2223              ; output:   a - key pressed, 0 if none
  76+ 2223              ; destroys: af,bc,de,hl
  77+ 2223              ; -----------------------------------------------------------------------------
  78+ 2223              ;
  79+ 2223 FB           readKey		ei
  80+ 2224 76           		halt
  81+ 2225 F3           		di
  82+ 2226 CD 5F 22     		call ckMods		; checks CAPS SHIFT and SYMBOL SHIFT
  83+ 2229              		;
  84+ 2229 21 6F 26     		ld hl, dbTbKeys
  85+ 222C 7E           nextRow		ld a, (hl)
  86+ 222D B7           		or a
  87+ 222E C8           		ret z
  88+ 222F 23           		inc hl
  89+ 2230 06 10        		ld b, %00010000		; b <- col to test
  90+ 2232 DB FE        		in a, ($fe)
  91+ 2234 2F           		cpl
  92+ 2235 4F           		ld c, a
  93+ 2236 79           nextCol		ld a, c
  94+ 2237 A0           		and b
  95+ 2238 20 0B        		jr nz, pressed
  96+ 223A 23           ignCol		inc hl			; no key pressed
  97+ 223B CB 18        		rr b
  98+ 223D 30 F7        		jr nc, nextCol		; next col to test
  99+ 223F              		;
 100+ 223F 11 0A 00     		ld de, 10		;15
 101+ 2242 19           		add hl, de
 102+ 2243 18 E7        		jr nextRow		; next half-row
 103+ 2245
 104+ 2245 7E           pressed		ld a, (hl)		; key pressed
 105+ 2246 B7           		or a
 106+ 2247 28 F1        		jr z, ignCol		; if CS o SS, ignore it
 107+ 2249              		;
 108+ 2249              		; Check modifiers
 109+ 2249              		;
 110+ 2249 46           		ld b, (hl)
 111+ 224A              		;
 112+ 224A 11 05 00     		ld de, 5
 113+ 224D 19           		add hl, de
 114+ 224E 3A F1 26     		ld a, (flagSS)		; SS pressed
 115+ 2251 B7           		or a
 116+ 2252 28 01        		jr z, paso1
 117+ 2254 46           		ld b, (hl)
 118+ 2255 19           paso1		add hl, de
 119+ 2256 3A F0 26     		ld a, (flagCS)		; CS pressed
 120+ 2259 B7           		or a
 121+ 225A 28 01        		jr z, paso2
 122+ 225C 46           		ld b, (hl)
 123+ 225D 78           paso2		ld a, b
 124+ 225E              		;
 125+ 225E C9           		ret
 126+ 225F
 127+ 225F              ; ----------------------------------
 128+ 225F              ; checks CAPS SHIFT and SYMBOL SHIFT
 129+ 225F              ; ----------------------------------
 130+ 225F              ;
 131+ 225F 3E FE        ckMods		ld a, $fe
 132+ 2261 DB FE        		in a, ($fe)
 133+ 2263 06 01        		ld b, %00000001
 134+ 2265 2F           		cpl
 135+ 2266 A0           		and b
 136+ 2267 32 F0 26     		ld (flagCS), a
 137+ 226A
 138+ 226A 3E 7F        		ld a, $7f
 139+ 226C DB FE        		in a, ($fe)
 140+ 226E 06 02        		ld b, %00000010
 141+ 2270 2F           		cpl
 142+ 2271 A0           		and b
 143+ 2272 32 F1 26     		ld (flagSS), a
 144+ 2275
 145+ 2275 C9           		ret
 146+ 2276
 147+ 2276              ; -----------------------------------------------------------------------------
 148+ 2276              ; Read joystick - based on Velesoft suggestions
 149+ 2276              ;
 150+ 2276              ; input:    -
 151+ 2276              ; output:   a - key pressed, 0 if none
 152+ 2276              ; destroys: af,bc,hl
 153+ 2276              ; -----------------------------------------------------------------------------
 154+ 2276              ;
 155+ 2276 FB           readJoy		ei
 156+ 2277 76           		halt
 157+ 2278 F3           		di
 158+ 2279 01 1F 00     		ld bc, $1f		; 31
 159+ 227C ED 78        		in a, (c)
 160+ 227E E6 1F        		and 31			; %00011111
 161+ 2280 47           		ld b, a
 162+ 2281 E6 03        		and 3			; %00000011
 163+ 2283 FE 03        		cp 3
 164+ 2285 28 30        		jr z, joy6		; detected incorrect state right+left
 165+ 2287 78           		ld a, b
 166+ 2288 E6 0C        		and 12			; %00001100
 167+ 228A FE 0C        		cp 12
 168+ 228C 28 29        		jr z, joy6		; detected incorrect state up+down
 169+ 228E 78           		ld a, b
 170+ 228F              		;
 171+ 228F              		; check directions and fire button
 172+ 228F              		;
 173+ 228F FE 01        		cp 1
 174+ 2291 20 04        		jr nz, joy1
 175+ 2293 3A DB 2C     		ld a, (kRight)
 176+ 2296 C9           		ret
 177+ 2297 FE 02        joy1		cp 2
 178+ 2299 20 04        		jr nz, joy2
 179+ 229B 3A D8 2C     		ld a, (kLeft)
 180+ 229E C9           		ret
 181+ 229F FE 04        joy2		cp 4
 182+ 22A1 20 04        		jr nz, joy3
 183+ 22A3 3A D9 2C     		ld a, (kDown)
 184+ 22A6 C9           		ret
 185+ 22A7 FE 08        joy3		cp 8
 186+ 22A9 20 04        		jr nz, joy4
 187+ 22AB 3A DA 2C     		ld a, (kUp)
 188+ 22AE C9           		ret
 189+ 22AF FE 10        joy4		cp 16
 190+ 22B1 20 0A        		jr nz, joy5
 191+ 22B3 3A DC 2C     		ld a, (kEnter)
 192+ 22B6 C9           		ret
 193+ 22B7              joy6		;
 194+ 22B7              		; disable joystick, xor a : ret
 195+ 22B7              		;
 196+ 22B7 21 AF C9     		ld hl, $c9af
 197+ 22BA 22 76 22     		ld (readJoy), hl
 198+ 22BD              joy5		;
 199+ 22BD              		; no key pressed
 200+ 22BD              		;
 201+ 22BD AF           		xor a
 202+ 22BE C9           		ret
 203+ 22BF
 204+ 22BF              ; -----------------------------------------------------------------------------
 205+ 22BF              ; Waits 26*(hl-1)+27 T states
 206+ 22BF              ;
 207+ 22BF              ; 3,55 Mhz => T state = 281,7 nseg
 208+ 22BF              ; n = 0     => ~480 mseg
 209+ 22BF              ; n = 32768 => ~240 mseg
 210+ 22BF              ; n = 24576 => ~180 mseg
 211+ 22BF              ; n = 16384 => ~120 mseg
 212+ 22BF              ;
 213+ 22BF              ; input:    -
 214+ 22BF              ; output:   -
 215+ 22BF              ; destroys: af,de
 216+ 22BF              ; -----------------------------------------------------------------------------
 217+ 22BF              ;
 218+ 22BF              ;wait    ld      de, 8192
 219+ 22BF              ;waitLp  dec     de
 220+ 22BF              ;        ld      a, d
 221+ 22BF              ;        or      e
 222+ 22BF              ;        jr      nz, waitLp
 223+ 22BF              ;        ret
 224+ 22BF
 225+ 22BF              ; -----------------------------------------------------------------------------
 226+ 22BF              ; Waits ~ b * 20 mseg
 227+ 22BF              ;
 228+ 22BF              ; input:    -
 229+ 22BF              ; output:   -
 230+ 22BF              ; destroys: b
 231+ 22BF              ; -----------------------------------------------------------------------------
 232+ 22BF              ;
 233+ 22BF 06 0C        wait		ld b, 12
 234+ 22C1 FB           waitL0		ei
 235+ 22C2 76           		halt
 236+ 22C3 F3           		di
 237+ 22C4 10 FB        		djnz waitL0
 238+ 22C6 C9           		ret
 239+ 22C7
 240+ 22C7              ; -----------------------------------------------------------------------------
 241+ 22C7              ; clear screen lines
 242+ 22C7              ;
 243+ 22C7              ; input:    a = attribute
 244+ 22C7              ;           b = number of lines
 245+ 22C7              ;           c = from line
 246+ 22C7              ; output:   -
 247+ 22C7              ; destroys: af,bc,de,hl,af'
 248+ 22C7              ; -----------------------------------------------------------------------------
 249+ 22C7              ;
 250+ 22C7              ;    7  6  5  4  3  2  1  0
 251+ 22C7              ;    F  B P2 P1 P0 I2 I1 I0
 252+ 22C7              ;
 253+ 22C7              ;    F sets the attribute FLASH mode
 254+ 22C7              ;    B sets the attribute BRIGHTNESS mode
 255+ 22C7              ;    P2 to P0 is the PAPER colour
 256+ 22C7              ;    I2 to I0 is the INK colour
 257+ 22C7              ;
 258+ 22C7              ;    0 black
 259+ 22C7              ;    1 blue
 260+ 22C7              ;    2 red
 261+ 22C7              ;    3 magenta
 262+ 22C7              ;    4 green
 263+ 22C7              ;    5 cyan
 264+ 22C7              ;    6 yellow
 265+ 22C7              ;    7 white
 266+ 22C7              ;
 267+ 22C7              ;             H                         L
 268+ 22C7              ;  15 14 13 12 11 10  9  8    7  6  5  4  3  2  1  0
 269+ 22C7              ;   0  1  0  1  1  0 Y7 Y6   Y5 Y4 Y3 X7 X6 X5 X4 X3    attr
 270+ 22C7              ;   0  1  0 Y7 Y6 Y2 Y1 Y0   Y5 Y4 Y3 X7 X6 X5 X4 X3    bitmap
 271+ 22C7              ;
 272+ 22C7              ; input:
 273+ 22C7              ;
 274+ 22C7              ;  A = attr
 275+ 22C7              ;  B = number of lines to clear
 276+ 22C7              ;  C = start line
 277+ 22C7              ;
 278+ 22C7              ;      0 0 0 Y7 Y6 Y5 Y4 Y3   (0 to 23)
 279+ 22C7              ;      0 0 0  0  0  0  0  0   (0)
 280+ 22C7              ;      0 0 0  1  0  1  1  1   (23)
 281+ 22C7              ;
 282+ 22C7 08           clrScr		ex af, af'		; guardamos atributos
 283+ 22C8              		;
 284+ 22C8              		; attr
 285+ 22C8              		;
 286+ 22C8 79           		ld a, c			; Calculate Y7, Y6
 287+ 22C9 0F           		rrca			; Shift to position
 288+ 22CA 0F           		rrca
 289+ 22CB 0F           		rrca
 290+ 22CC E6 03        		and %00000011		; Mask out unwanted bits
 291+ 22CE F6 58        		or %01011000		; Set attr address of screen
 292+ 22D0 67           		ld h, a			; Store in H
 293+ 22D1 57           		ld d, a
 294+ 22D2 79           		ld a, c
 295+ 22D3 0F           		rrca			; Shift to position
 296+ 22D4 0F           		rrca
 297+ 22D5 0F           		rrca
 298+ 22D6 E6 E0        		and %11100000		; Calculate Y5, Y4, Y3
 299+ 22D8 6F           		ld l, a			; Store in L
 300+ 22D9 5F           		ld e, a
 301+ 22DA 1C           		inc e
 302+ 22DB              		;
 303+ 22DB 08           		ex af, af'		; recuperamos atributos
 304+ 22DC C5           		push bc			; guardamos BC
 305+ 22DD              		;
 306+ 22DD 77           		ld (hl), a
 307+ 22DE 01 1F 00     		ld bc, 32-1
 308+ 22E1 ED B0        		ldir
 309+ 22E3              		;
 310+ 22E3 C1           		pop bc			; recuperamos BC
 311+ 22E4 08           		ex af, af'		; guardamos atributos
 312+ 22E5              		;
 313+ 22E5              		; bitmap
 314+ 22E5              		;
 315+ 22E5 79           		ld a, c			; Calculate Y7, Y6
 316+ 22E6 E6 18        		and %00011000		; Mask out unwanted bits
 317+ 22E8 F6 40        		or %01000000		; Set base address of screen
 318+ 22EA 67           		ld h, a			; Store in H
 319+ 22EB 57           		ld d, a
 320+ 22EC 79           		ld a, c
 321+ 22ED 0F           		rrca			; Shift to position
 322+ 22EE 0F           		rrca
 323+ 22EF 0F           		rrca
 324+ 22F0 E6 E0        		and %11100000		; Calculate Y5, Y4, Y3
 325+ 22F2 6F           		ld l, a			; Store in L
 326+ 22F3 5F           		ld e, a
 327+ 22F4 1C           		inc e
 328+ 22F5              		;
 329+ 22F5 C5           		push bc			; guardamos BC
 330+ 22F6              		;
 331+ 22F6 AF           		xor a
 332+ 22F7 06 08        		ld b, 8			; B pixel rows to clear
 333+ 22F9 E5           clScrL0		push hl
 334+ 22FA D5           		push de
 335+ 22FB C5           		push bc
 336+ 22FC 77           		ld (hl), a
 337+ 22FD 01 1F 00     		ld bc, 32-1
 338+ 2300 ED B0        		ldir
 339+ 2302 C1           		pop bc
 340+ 2303 D1           		pop de
 341+ 2304 E1           		pop hl
 342+ 2305 24           		inc h
 343+ 2306 14           		inc d
 344+ 2307 10 F0        		djnz clScrL0
 345+ 2309              		;
 346+ 2309 08           		ex af, af'		; recuperamos atributos
 347+ 230A C1           		pop bc			; recuperamos BC
 348+ 230B              		;
 349+ 230B 0C           		inc c
 350+ 230C 10 B9        		djnz clrScr
 351+ 230E              		;
 352+ 230E C9           		ret
 353+ 230F
 354+ 230F              ; -----------------------------------------------------------------------------
 355+ 230F              ; Converts an unsigned int to an 6 char ASCII string
 356+ 230F              ; Skip '0' on the left
 357+ 230F              ;
 358+ 230F              ; input:    hl = unigned int to convert
 359+ 230F              ;           de = pointer to ASCII string
 360+ 230F              ; output:   c:hl = 6 digits BCD number
 361+ 230F              ;           de = pointer to end of string
 362+ 230F              ; destroys: af,bc,de,hl
 363+ 230F              ; -----------------------------------------------------------------------------
 364+ 230F D5           _utoa		push de
 365+ 2310 01 00 10     		ld bc, 16*256+0		; handle 16 bits, one bit per iteration
 366+ 2313 11 00 00     		ld de, 0
 367+ 2316              cvtLoop
 368+ 2316 29           		add hl, hl
 369+ 2317 7B           		ld a, e
 370+ 2318 8F           		adc a, a
 371+ 2319 27           		daa
 372+ 231A 5F           		ld e, a
 373+ 231B 7A           		ld a, d
 374+ 231C 8F           		adc a, a
 375+ 231D 27           		daa
 376+ 231E 57           		ld d, a
 377+ 231F 79           		ld a, c
 378+ 2320 8F           		adc a, a
 379+ 2321 27           		daa
 380+ 2322 4F           		ld c, a
 381+ 2323 10 F1        		djnz cvtLoop
 382+ 2325 EB           		ex de, hl		; C:HL = numero BCD de 6 digitos
 383+ 2326
 384+ 2326              bcd2hex
 385+ 2326 D1           		pop de
 386+ 2327              		//ld de, utoaBuf	//
 387+ 2327 D5           		push de
 388+ 2328              		//
 389+ 2328 79           		ld a, c			// skip left zeroes
 390+ 2329 E6 F0        		and $f0
 391+ 232B 20 16        		jr nz, _1_
 392+ 232D 79           		ld a, c
 393+ 232E E6 0F        		and $0f
 394+ 2330 20 15        		jr nz, _2_
 395+ 2332 7C           		ld a, h
 396+ 2333 E6 F0        		and $f0
 397+ 2335 20 14        		jr nz, _3_
 398+ 2337 7C           		ld a, h
 399+ 2338 E6 0F        		and $0f
 400+ 233A 20 13        		jr nz, _4_
 401+ 233C 7D           		ld a, l
 402+ 233D E6 F0        		and $f0
 403+ 233F 20 12        		jr nz, _5_
 404+ 2341 18 13        		jr _6_
 405+ 2343
 406+ 2343 CD 5E 23     _1_		call cvtUpperNibble
 407+ 2346 79           		ld a, c
 408+ 2347 CD 62 23     _2_		call cvtLowerNibble
 409+ 234A 7C           		ld a, h
 410+ 234B CD 5E 23     _3_		call cvtUpperNibble
 411+ 234E 7C           		ld a, h
 412+ 234F CD 62 23     _4_		call cvtLowerNibble
 413+ 2352 7D           		ld a, l
 414+ 2353 CD 5E 23     _5_		call cvtUpperNibble
 415+ 2356 7D           _6_		ld a, l
 416+ 2357 CD 62 23     		call cvtLowerNibble
 417+ 235A AF           		xor a
 418+ 235B 12           		ld (de), a
 419+ 235C E1           		pop hl
 420+ 235D              		//jr prtDec		//
 421+ 235D C9           		ret
 422+ 235E
 423+ 235E              cvtUpperNibble
 424+ 235E 1F           		rra			; move upper nibble into lower nibble
 425+ 235F 1F           		rra
 426+ 2360 1F           		rra
 427+ 2361 1F           		rra
 428+ 2362              cvtLowerNibble
 429+ 2362 E6 0F        		and $0F			; isolate lower nibble
 430+ 2364 F6 30        		or %00110000		; convert to ASCII
 431+ 2366 12           		ld (de), a
 432+ 2367 13           		inc de
 433+ 2368 C9           		ret
 434+ 2369
 435+ 2369 11 F8 26     utoa		ld de, utoaBuf
 436+ 236C CD 0F 23     		call _utoa
 437+ 236F              		//jr prStr
 438+ 236F
 439+ 236F              ; -----------------------------------------------------------------------------
 440+ 236F              ; Print a asciiz string at cursor position
 441+ 236F              ; Updates cursor coordinates
 442+ 236F              ;
 443+ 236F              ; input:    hl = pointer to asciiz string
 444+ 236F              ; output:   hl = pointer to end of string
 445+ 236F              ; destroys: af,bc,de,hl,af'
 446+ 236F              ; -----------------------------------------------------------------------------
 447+ 236F 7E           prStr		ld a, (hl)
 448+ 2370 47           		ld b, a
 449+ 2371 3A F3 26     		ld a, (flgAT)
 450+ 2374 A7           		and a
 451+ 2375 78           		ld a, b
 452+ 2376 20 02        		jr nz, notChk
 453+ 2378 B7           		or a
 454+ 2379 C8           		ret z
 455+ 237A E5           notChk		push hl
 456+ 237B CD 82 23     		call prChr
 457+ 237E E1           		pop hl
 458+ 237F 23           		inc hl
 459+ 2380 18 ED        		jr prStr
 460+ 2382
 461+ 2382              ; -----------------------------------------------------------------------------
 462+ 2382              ; Print a character at cursor
 463+ 2382              ; Updates cursor coordinates
 464+ 2382              ;
 465+ 2382              ; The source code for 64 column printing was originally provided by Andrew Owen
 466+ 2382              ; in a thread on WoSF.
 467+ 2382              ;
 468+ 2382              ; Based on code by Tony Samuels from Your Spectrum issue 13, April 1985.
 469+ 2382              ; A channel wrapper for the 64-column display driver.
 470+ 2382              ;
 471+ 2382              ; input:    a = char to print
 472+ 2382              ; output:   -
 473+ 2382              ; destroys: af,bc,de,hl,af'
 474+ 2382              ; -----------------------------------------------------------------------------
 475+ 2382
 476+ 2382 47           prChr		ld b,a			; save character
 477+ 2383 3A F3 26     		ld a,(flgAT)		; value of AT flag
 478+ 2386 A7           		and a			; test against zero
 479+ 2387 20 0B        		jr nz,getrow		; jump if not
 480+ 2389 78           		ld a,b			; restore character
 481+ 238A
 482+ 238A FE 16        atchk		cp $16			; test for AT
 483+ 238C 20 29        		jr nz,crchk		; if not test for CR
 484+ 238E 3E FF        		ld a,$ff		; set the AT flag
 485+ 2390 32 F3 26     		ld (flgAT),a		; next character will be row
 486+ 2393 C9           		ret			; return
 487+ 2394
 488+ 2394 FE FE        getrow		cp $fe			; test AT flag
 489+ 2396 28 0D        		jr z,getcol		; jump if setting col
 490+ 2398 78           		ld a,b			; restore character
 491+ 2399 FE 18        		cp $18			; greater or equal than 24?
 492+ 239B 30 15        		jr nc,err_b		; error if so
 493+ 239D
 494+ 239D 32 F4 26     		ld (row),a		; store it in row
 495+ 23A0 21 F3 26     		ld hl,flgAT		; AT flag
 496+ 23A3 35           		dec (hl)		; indicates next character is col
 497+ 23A4 C9           		ret			; return
 498+ 23A5
 499+ 23A5 78           getcol		ld a,b			; restore character
 500+ 23A6 FE 40        		cp $40			; greater or equal than 64?
 501+ 23A8 30 08        		jr nc,err_b		; error if so
 502+ 23AA 32 F5 26     		ld (col),a		; store it in col
 503+ 23AD AF           		xor a			; set a to zero
 504+ 23AE 32 F3 26     		ld (flgAT),a		; store in AT flag
 505+ 23B1 C9           		ret			; return
 506+ 23B2
 507+ 23B2 AF           err_b		xor a			; set a to zero
 508+ 23B3 32 F3 26     		ld (flgAT),a		; clear AT flag
 509+ 23B6              		;rst	08h		;
 510+ 23B6              		;defb	$0a		; ERROR, PENSAR QUE HACER AQUI
 511+ 23B6 C9           		ret
 512+ 23B7
 513+ 23B7 FE 0D        crchk		cp $0d			; check for return
 514+ 23B9 28 15        		jr z,do_cr		; to carriage return if so
 515+ 23BB              		;cp      $84             ; greater or equal than 132?
 516+ 23BB FE 80        		cp $80			; greater or equal than 128?
 517+ 23BD 30 04        		jr nc,prErr		;
 518+ 23BF FE 20        		cp $20			; greater or equal than 32?
 519+ 23C1 30 02        		jr nc,prOk		;
 520+ 23C3              prErr		;ld      a,$80
 521+ 23C3 3E 3F        		ld a, '?'
 522+ 23C5 CD E3 23     prOk		call pr_64		; print it
 523+ 23C8
 524+ 23C8 21 F5 26     		ld hl,col		; increment
 525+ 23CB 34           		inc (hl)		; the column
 526+ 23CC 7E           		ld a,(hl)		;
 527+ 23CD
 528+ 23CD FE 40        		cp $40			; column 64?
 529+ 23CF C0           		ret nz			;
 530+ 23D0
 531+ 23D0 AF           do_cr		xor a			; set A to zero
 532+ 23D1 32 F5 26     		ld (col),a		; reset column
 533+ 23D4 3A F4 26     		ld a,(row)		; get the row
 534+ 23D7 3C           		inc a			; increment it
 535+ 23D8 FE 18        		cp $18			; row 24?
 536+ 23DA 28 04        		jr z,wrap		;
 537+ 23DC
 538+ 23DC 32 F4 26     zend		ld (row),a		; write it back
 539+ 23DF C9           		ret
 540+ 23E0
 541+ 23E0 AF           wrap		xor a			;
 542+ 23E1 18 F9        		jr zend			;
 543+ 23E3
 544+ 23E3              ; ------------------------
 545+ 23E3              ; 64 COLUMN DISPLAY DRIVER
 546+ 23E3              ; ------------------------
 547+ 23E3
 548+ 23E3 B7           pr_64		or a			; clear C flag
 549+ 23E4 1F           		rra			; divide by two with remainder in carry flag
 550+ 23E5
 551+ 23E5 26 00        		ld h,$00		; clear H
 552+ 23E7 6F           		ld l,a			; CHAR to low byte of HL
 553+ 23E8
 554+ 23E8 08           		ex af,af'		; save the carry flag
 555+ 23E9
 556+ 23E9 E5           		push hl			;
 557+ 23EA D1           		pop de			;
 558+ 23EB 29           		add hl,hl		; multiply
 559+ 23EC 19           		add hl,de		; by
 560+ 23ED 29           		add hl,hl		; seven
 561+ 23EE 19           		add hl,de		; character map in FONT
 562+ 23EF 11 AF 24     		ld de,dbTbFont-32*7/2	; offset to FONT
 563+ 23F2 19           		add hl,de		; HL holds address of first byte of
 564+ 23F3 E5           		push hl			; save font address
 565+ 23F4
 566+ 23F4              ; convert the row to the base screen address
 567+ 23F4
 568+ 23F4 3A F4 26     		ld a,(row)		; get the row
 569+ 23F7 47           		ld b,a			; save it
 570+ 23F8 E6 18        		and $18			; mask off bit 3-4
 571+ 23FA 57           		ld d,a			; store high byte of offset in D
 572+ 23FB 78           		ld a,b			; retrieve it
 573+ 23FC E6 07        		and $07			; mask off bit 0-2
 574+ 23FE 07           		rlca			; shift
 575+ 23FF 07           		rlca			; five
 576+ 2400 07           		rlca			; bits
 577+ 2401 07           		rlca			; to the
 578+ 2402 07           		rlca			; left
 579+ 2403 5F           		ld e,a			; store low byte of offset in E
 580+ 2404
 581+ 2404              ; add the column
 582+ 2404
 583+ 2404 3A F5 26     		ld a,(col)		; get the column
 584+ 2407 1F           		rra			; divide by two with remainder in carry flag
 585+ 2408 F5           		push af			; store the carry flag
 586+ 2409
 587+ 2409 26 40        		ld h,$40		; base location
 588+ 240B 6F           		ld l,a			; plus column offset
 589+ 240C
 590+ 240C 19           		add hl,de		; add the offset
 591+ 240D
 592+ 240D EB           		ex de,hl		; put the result back in DE
 593+ 240E
 594+ 240E AF           		xor a			; the upper bits of char are always 0
 595+ 240F 12           		ld (de),a		; set to 0 and reduce font from 8x4 to
 596+ 2410 14           		inc d			; 7x4
 597+ 2411
 598+ 2411              ; HL now points to the location of the first byte of char data in FONT_1
 599+ 2411              ; DE points to the first screen byte in SCREEN_1
 600+ 2411              ; C holds the offset to the routine
 601+ 2411
 602+ 2411 F1           		pop af			; restore column carry flag
 603+ 2412 E1           		pop hl			; restore the font address
 604+ 2413
 605+ 2413 30 05        		jr nc,odd_col		; jump if odd column
 606+ 2415
 607+ 2415              even_col
 608+ 2415 08           		ex af,af'		; restore char position carry flag
 609+ 2416 38 07        		jr c,l_on_l		; left char on left col
 610+ 2418 18 3C        		jr r_on_l		; right char on left col
 611+ 241A
 612+ 241A              odd_col
 613+ 241A 08           		ex af,af'		; restore char position carry flag
 614+ 241B 30 13        		jr nc,r_on_r		; right char on right col
 615+ 241D 18 22        		jr l_on_r		; left char on right col
 616+ 241F
 617+ 241F              ; -------------------------------
 618+ 241F              ; WRITE A CHARACTER TO THE SCREEN
 619+ 241F              ; -------------------------------
 620+ 241F              ;
 621+ 241F              ; There are four separate routines
 622+ 241F
 623+ 241F              ; HL points to the first byte of a character in FONT
 624+ 241F              ; DE points to the first byte of the screen address
 625+ 241F
 626+ 241F              ; left nibble on left hand side
 627+ 241F
 628+ 241F 0E 07        l_on_l		ld c,$07		; 7 bytes to write
 629+ 2421 1A           ll_lp		ld a,(de)		; read byte at destination
 630+ 2422 E6 F0        		and $f0			; mask area used by new character
 631+ 2424 47           		ld b,a			; store in b
 632+ 2425 7E           		ld a,(hl)		; get byte of font
 633+ 2426 E6 0F        		and $0f			; mask off unused half
 634+ 2428 B0           		or b			; combine with background
 635+ 2429 12           		ld (de),a		; write it back
 636+ 242A 14           		inc d			; point to next screen location
 637+ 242B 23           		inc hl			; point to next font data
 638+ 242C 0D           		dec c			; adjust counter
 639+ 242D 20 F2        		jr nz,ll_lp		; loop 7 times
 640+ 242F C9           		ret			; done
 641+ 2430
 642+ 2430              ; right nibble on right hand side
 643+ 2430
 644+ 2430 0E 07        r_on_r		ld c,$07		; 7 bytes to write
 645+ 2432 1A           rr_lp		ld a,(de)		; read byte at destination
 646+ 2433 E6 0F        		and $0f			; mask area used by new character
 647+ 2435 47           		ld b,a			; store in b
 648+ 2436 7E           		ld a,(hl)		; get byte of font
 649+ 2437 E6 F0        		and $f0			; mask off unused half
 650+ 2439 B0           		or b			; combine with background
 651+ 243A 12           		ld (de),a		; write it back
 652+ 243B 14           		inc d			; point to next screen location
 653+ 243C 23           		inc hl			; point to next font data
 654+ 243D 0D           		dec c			; adjust counter
 655+ 243E 20 F2        		jr nz,rr_lp		; loop 7 times
 656+ 2440 C9           		ret			; done
 657+ 2441
 658+ 2441              ; left nibble on right hand side
 659+ 2441
 660+ 2441 0E 07        l_on_r		ld c,$07		; 7 bytes to write
 661+ 2443 1A           lr_lp		ld a,(de)		; read byte at destination
 662+ 2444 E6 0F        		and $0f			; mask area used by new character
 663+ 2446 47           		ld b,a			; store in b
 664+ 2447 7E           		ld a,(hl)		; get byte of font
 665+ 2448 0F           		rrca			; shift right
 666+ 2449 0F           		rrca			; four bits
 667+ 244A 0F           		rrca			; leaving 7-4
 668+ 244B 0F           		rrca			; empty
 669+ 244C E6 F0        		and $f0			;
 670+ 244E B0           		or b			; combine with background
 671+ 244F 12           		ld (de),a		; write it back
 672+ 2450 14           		inc d			; point to next screen location
 673+ 2451 23           		inc hl			; point to next font data
 674+ 2452 0D           		dec c			; adjust counter
 675+ 2453 20 EE        		jr nz,lr_lp		; loop 7 times
 676+ 2455 C9           		ret			; done
 677+ 2456
 678+ 2456              ; right nibble on left hand side
 679+ 2456
 680+ 2456 0E 07        r_on_l		ld c,$07		; 7 bytes to write
 681+ 2458 1A           rl_lp		ld a,(de)		; read byte at destination
 682+ 2459 E6 F0        		and $f0			; mask area used by new character
 683+ 245B 47           		ld b,a			; store in b
 684+ 245C 7E           		ld a,(hl)		; get byte of font
 685+ 245D 07           		rlca			; shift left
 686+ 245E 07           		rlca			; four bits
 687+ 245F 07           		rlca			; leaving 3-0
 688+ 2460 07           		rlca			; empty
 689+ 2461 E6 0F        		and $0f			;
 690+ 2463 B0           		or b			; combine with background
 691+ 2464 12           		ld (de),a		; write it back
 692+ 2465 14           		inc d			; point to next screen location
 693+ 2466 23           		inc hl			; point to next font data
 694+ 2467 0D           		dec c			; adjust counter
 695+ 2468 20 EE        		jr nz,rl_lp		; loop 7 times
 696+ 246A C9           		ret			; done
 697+ 246B
# file closed: sharedfunctions.asm
 172  246B              		include "page6functions.asm"
# file opened: page6functions.asm
   1+ 246B              ;==============================================================================
   2+ 246B              ; Project: NMI.zdsp
   3+ 246B              ; File: page6functions.asm
   4+ 246B              ; Date: 03/11/2022 18:38:20
   5+ 246B              ;
   6+ 246B              ; Created with zDevStudio - Z80 Development Studio.
   7+ 246B              ;
   8+ 246B              ;==============================================================================
   9+ 246B
  10+ 246B              ; -----------------------
  11+ 246B              ; read configuration file
  12+ 246B              ; -----------------------
  13+ 246B              ;
  14+ 246B 21 52 2C     readCnf		ld hl, dbFnConfigFile	; asciiz string containg path and/or filename
  15+ 246E 06 01        		ld b, FA_OPEN_EX|FA_READ
  16+ 2470              					; open if exists, else error
  17+ 2470              					; read access
  18+ 2470 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  19+ 2472 CD 13 21     		call fOpen1
  20+ 2475
  21+ 2475 21 D0 2C     		ld hl, bufConf		; dest
  22+ 2478 01 08 00     		ld bc, 8		; size
  23+ 247B CD 1C 21     		call fRead
  24+ 247E
  25+ 247E CD 39 21     		call fClose
  26+ 2481
  27+ 2481 C9           		ret
  28+ 2482
  29+ 2482              ; ------------------------
  30+ 2482              ; write configuration file
  31+ 2482              ; ------------------------
  32+ 2482              ;
  33+ 2482 21 52 2C     writeCnf	ld hl, dbFnConfigFile	; asciiz string containg path and/or filename
  34+ 2485 06 0A        		ld b, FA_OPEN_AL|FA_WRITE
  35+ 2487              					; open if exists, if not create
  36+ 2487              					; write access
  37+ 2487 3E 24        		ld a, SYS_DRIVE		; system/boot drive
  38+ 2489 CD 13 21     		call fOpen1
  39+ 248C
  40+ 248C 21 D0 2C     		ld hl, bufConf		; dest
  41+ 248F 01 08 00     		ld bc, 8		; size
  42+ 2492 CD 25 21     		call fWrite
  43+ 2495
  44+ 2495 CD 39 21     		call fClose
  45+ 2498
  46+ 2498 C9           		ret
  47+ 2499
  48+ 2499              ; --------------
  49+ 2499              ; print key name
  50+ 2499              ; --------------
  51+ 2499              ;
  52+ 2499 21 83 2C     prKeyName	ld hl, mDelete
  53+ 249C FE 0C        		cp K_DELETE
  54+ 249E 28 58        		jr z, prSelL1
  55+ 24A0 21 90 2C     		ld hl, mEnter
  56+ 24A3 FE 0D        		cp K_ENTER
  57+ 24A5 28 51        		jr z, prSelL1
  58+ 24A7 21 8A 2C     		ld hl, mSpace
  59+ 24AA FE 20        		cp ' '
  60+ 24AC 28 4A        		jr z, prSelL1
  61+ 24AE 21 96 2C     		ld hl, mBreak
  62+ 24B1 FE 1C        		cp K_BREAK
  63+ 24B3 28 43        		jr z, prSelL1
  64+ 24B5 21 9C 2C     		ld hl, mLeft
  65+ 24B8 FE 08        		cp K_LEFT
  66+ 24BA 28 3C        		jr z, prSelL1
  67+ 24BC 21 A1 2C     		ld hl, mRight
  68+ 24BF FE 09        		cp K_RIGHT
  69+ 24C1 28 35        		jr z, prSelL1
  70+ 24C3 21 A7 2C     		ld hl, mUp
  71+ 24C6 FE 0B        		cp K_UP
  72+ 24C8 28 2E        		jr z, prSelL1
  73+ 24CA 21 AA 2C     		ld hl, mDown
  74+ 24CD FE 0A        		cp K_DOWN
  75+ 24CF 28 27        		jr z, prSelL1
  76+ 24D1 21 AF 2C     		ld hl, mEdit
  77+ 24D4 FE 07        		cp K_EDIT
  78+ 24D6 28 20        		jr z, prSelL1
  79+ 24D8 21 B4 2C     		ld hl, mTo
  80+ 24DB FE CC        		cp K_TO
  81+ 24DD 28 19        		jr z, prSelL1
  82+ 24DF 21 CB 2C     		ld hl, mAt
  83+ 24E2 FE AC        		cp K_AT
  84+ 24E4 28 12        		jr z, prSelL1
  85+ 24E6 21 B9 2C     		ld hl, mSSEnt
  86+ 24E9 FE 1D        		cp K_SS_ENTER
  87+ 24EB 28 0B        		jr z, prSelL1
  88+ 24ED 21 C2 2C     		ld hl, mCSEnt
  89+ 24F0 FE 1E        		cp K_CS_ENTER
  90+ 24F2 28 04        		jr z, prSelL1
  91+ 24F4              		;
  92+ 24F4 CD 82 23     chrNorm		call prChr
  93+ 24F7 C9           		ret
  94+ 24F8
  95+ 24F8 CD 6F 23     prSelL1		call prStr
  96+ 24FB C9           		ret
  97+ 24FC
  98+ 24FC              ; -----------------------------------------------------------------------------
  99+ 24FC              ; Error handler
 100+ 24FC              ; -----------------------------------------------------------------------------
 101+ 24FC              ;
 102+ 24FC F5           closeFilePrErr	push af
 103+ 24FD 3A F2 26     		ld a, (fhandle)		;
 104+ 2500 CF           		rst $08			;
 105+ 2501 9B           		db F_CLOSE		; close file
 106+ 2502 F1           		pop af
 107+ 2503
 108+ 2503 F5           prError		push af
 109+ 2504              		;ld      bc, 24*256+0    ; 24 lines from line 0
 110+ 2504              		;ld      a, COL_MID      ; color
 111+ 2504              		;call    clrScr
 112+ 2504 01 0B 03     		ld bc, 3*256+11
 113+ 2507 3E 57        		ld a, COL_ERR
 114+ 2509 CD C7 22     		call clrScr
 115+ 250C 21 25 27     		ld hl, msgErr
 116+ 250F CD 6F 23     		call prStr
 117+ 2512 F1           		pop af
 118+ 2513
 119+ 2513 26 00        		ld h, 0			; esxDOS err
 120+ 2515 6F           		ld l, a
 121+ 2516 CD 69 23     		call utoa
 122+ 2519 CD F7 21     		call waitKey
 123+ 251C
 124+ 251C              		//ld sp, (savedSP)
 125+ 251C              		//jp mainL1
 126+ 251C C3 03 21     		jp helpEnd
 127+ 251F
# file closed: page6functions.asm
 173  251F
 174  251F              		; -------------------------------------------------------------
 175  251F              		; DATA
 176  251F              		; -------------------------------------------------------------
 177  251F
 178  251F              		include "shareddata.asm"
# file opened: shareddata.asm
   1+ 251F              ;==============================================================================
   2+ 251F              ; Project: NMI.zdsp
   3+ 251F              ; File: shareddata.asm
   4+ 251F              ; Date: 03/11/2022 19:30:30
   5+ 251F              ;
   6+ 251F              ; Created with zDevStudio - Z80 Development Studio.
   7+ 251F              ;
   8+ 251F              ;==============================================================================
   9+ 251F
  10+ 251F              ;==============================================================================
  11+ 251F              ; DATA
  12+ 251F              ;==============================================================================
  13+ 251F
  14+ 251F              ; -------------------
  15+ 251F              ; half width 4x7 font
  16+ 251F              ; -------------------
  17+ 251F              ;
  18+ 251F              ; 50 x 7 = 350 bytes
  19+ 251F              ;
  20+ 251F 02 02 02 02  dbTbFont	DB $02,$02,$02,$02,$00,$02,$00; SPACE !
  20+ 2523 00 02 00
  21+ 2526 52 57 02 02  		DB $52,$57,$02,$02,$07,$02,$00; " #
  21+ 252A 07 02 00
  22+ 252D 25 71 62 32  		DB $25,$71,$62,$32,$74,$25,$00; $ %
  22+ 2531 74 25 00
  23+ 2534 22 42 30 50  		DB $22,$42,$30,$50,$50,$30,$00; & '
  23+ 2538 50 30 00
  24+ 253B 14 22 41 41  		DB $14,$22,$41,$41,$41,$22,$14; ( )
  24+ 253F 41 22 14
  25+ 2542 20 70 22 57  		DB $20,$70,$22,$57,$02,$00,$00; * +
  25+ 2546 02 00 00
  26+ 2549 00 00 00 07  		DB $00,$00,$00,$07,$00,$20,$20; , -
  26+ 254D 00 20 20
  27+ 2550 01 01 02 02  		DB $01,$01,$02,$02,$04,$14,$00; . /
  27+ 2554 04 14 00
  28+ 2557 22 56 52 52  		DB $22,$56,$52,$52,$52,$27,$00; 0 1
  28+ 255B 52 27 00
  29+ 255E 27 51 12 21  		DB $27,$51,$12,$21,$45,$72,$00; 2 3
  29+ 2562 45 72 00
  30+ 2565 57 54 56 71  		DB $57,$54,$56,$71,$15,$12,$00; 4 5
  30+ 2569 15 12 00
  31+ 256C 17 21 61 52  		DB $17,$21,$61,$52,$52,$22,$00; 6 7
  31+ 2570 52 22 00
  32+ 2573 22 55 25 53  		DB $22,$55,$25,$53,$52,$24,$00; 8 9
  32+ 2577 52 24 00
  33+ 257A 00 00 22 00  		DB $00,$00,$22,$00,$00,$22,$02; : ;
  33+ 257E 00 22 02
  34+ 2581 00 10 27 40  		DB $00,$10,$27,$40,$27,$10,$00; < =
  34+ 2585 27 10 00
  35+ 2588 02 45 21 12  		DB $02,$45,$21,$12,$20,$42,$00; > ?
  35+ 258C 20 42 00
  36+ 258F 23 55 75 77  		DB $23,$55,$75,$77,$45,$35,$00; @ A
  36+ 2593 45 35 00
  37+ 2596 63 54 64 54  		DB $63,$54,$64,$54,$54,$63,$00; B C
  37+ 259A 54 63 00
  38+ 259D 67 54 56 54  		DB $67,$54,$56,$54,$54,$67,$00; D E
  38+ 25A1 54 67 00
  39+ 25A4 73 44 64 45  		DB $73,$44,$64,$45,$45,$43,$00; F G
  39+ 25A8 45 43 00
  40+ 25AB 57 52 72 52  		DB $57,$52,$72,$52,$52,$57,$00; H I
  40+ 25AF 52 57 00
  41+ 25B2 35 15 16 55  		DB $35,$15,$16,$55,$55,$25,$00; J K
  41+ 25B6 55 25 00
  42+ 25B9 45 47 45 45  		DB $45,$47,$45,$45,$45,$75,$00; L M
  42+ 25BD 45 75 00
  43+ 25C0 62 55 55 55  		DB $62,$55,$55,$55,$55,$52,$00; N O
  43+ 25C4 55 52 00
  44+ 25C7 62 55 55 65  		DB $62,$55,$55,$65,$45,$43,$00; P Q
  44+ 25CB 45 43 00
  45+ 25CE 63 54 52 61  		DB $63,$54,$52,$61,$55,$52,$00; R S
  45+ 25D2 55 52 00
  46+ 25D5 75 25 25 25  		DB $75,$25,$25,$25,$25,$22,$00; T U
  46+ 25D9 25 22 00
  47+ 25DC 55 55 55 55  		DB $55,$55,$55,$55,$27,$25,$00; V W
  47+ 25E0 27 25 00
  48+ 25E3 55 55 25 22  		DB $55,$55,$25,$22,$52,$52,$00; X Y
  48+ 25E7 52 52 00
  49+ 25EA 73 12 22 22  		DB $73,$12,$22,$22,$42,$72,$03; Z [
  49+ 25EE 42 72 03
  50+ 25F1 46 42 22 22  		DB $46,$42,$22,$22,$12,$12,$06; \ ]
  50+ 25F5 12 12 06
  51+ 25F8 20 50 00 00  		DB $20,$50,$00,$00,$00,$00,$0F; ^ _
  51+ 25FC 00 00 0F
  52+ 25FF 20 10 03 05  		DB $20,$10,$03,$05,$05,$03,$00; sterling_pound a
  52+ 2603 05 03 00
  53+ 2606 40 40 63 54  		DB $40,$40,$63,$54,$54,$63,$00; b c
  53+ 260A 54 63 00
  54+ 260D 10 10 32 55  		DB $10,$10,$32,$55,$56,$33,$00; d e
  54+ 2611 56 33 00
  55+ 2614 10 20 73 25  		DB $10,$20,$73,$25,$25,$43,$06; f g
  55+ 2618 25 43 06
  56+ 261B 42 40 66 52  		DB $42,$40,$66,$52,$52,$57,$00; h i
  56+ 261F 52 57 00
  57+ 2622 14 04 35 16  		DB $14,$04,$35,$16,$15,$55,$20; j k
  57+ 2626 15 55 20
  58+ 2629 60 20 25 27  		DB $60,$20,$25,$27,$25,$75,$00; l m
  58+ 262D 25 75 00
  59+ 2630 00 00 62 55  		DB $00,$00,$62,$55,$55,$52,$00; n o
  59+ 2634 55 52 00
  60+ 2637 00 00 63 55  		DB $00,$00,$63,$55,$55,$63,$41; p q
  60+ 263B 55 63 41
  61+ 263E 00 00 53 66  		DB $00,$00,$53,$66,$43,$46,$00; r s
  61+ 2642 43 46 00
  62+ 2645 00 20 75 25  		DB $00,$20,$75,$25,$25,$12,$00; t u
  62+ 2649 25 12 00
  63+ 264C 00 00 55 55  		DB $00,$00,$55,$55,$27,$25,$00; v w
  63+ 2650 27 25 00
  64+ 2653 00 00 55 25  		DB $00,$00,$55,$25,$25,$53,$06; x y
  64+ 2657 25 53 06
  65+ 265A 01 02 72 34  		DB $01,$02,$72,$34,$62,$72,$01; z {
  65+ 265E 62 72 01
  66+ 2661 24 22 22 21  		DB $24,$22,$22,$21,$22,$22,$04; | }
  66+ 2665 22 22 04
  67+ 2668 56 A9 06 04  		DB $56,$A9,$06,$04,$06,$09,$06; ~ copyright
  67+ 266C 06 09 06
  68+ 266F
  69+ 266F              		;DB      $50,$20,$60,$50,$70,$55,$70     ; [?] [..]      128, 129
  70+ 266F
  71+ 266F              ; ---------
  72+ 266F              ; key table
  73+ 266F              ; ---------
  74+ 266F              ;
  75+ 266F              ; (5 x 3 + 1) x 8 + 1 = 129 bytes
  76+ 266F              ; (5 x 4 + 1) x 8 + 1 = 169 bytes
  77+ 266F              ;
  78+ 266F F7           dbTbKeys	DB $f7
  79+ 2670 35 34 33 32  		DB '5', '4', '3', '2', '1'		; NORMAL
  79+ 2674 31
  80+ 2675 25 24 23 40  		DB '%', '$', '#', '@', '!'		; SS
  80+ 2679 21
  81+ 267A 08 00 00 00  		DB K_LEFT, $00, $00, $00, K_EDIT	; CS -> ESTO SON MAYUSCULAS, ME EQUIVOQUE Y PUSE EXTENDED MODE (E)
  81+ 267E 07
  82+ 267F              		;DB      $00, $00, $00, $00, $00	; E+SS
  83+ 267F EF           		DB $ef
  84+ 2680 36 37 38 39  		DB '6', '7', '8', '9', '0'
  84+ 2684 30
  85+ 2685 26 27 28 29  		DB '&', $27, '(', ')', '_'
  85+ 2689 5F
  86+ 268A 0A 0B 09 00  		DB K_DOWN, K_UP, K_RIGHT, $00, K_DELETE
  86+ 268E 0C
  87+ 268F              		;DB      $00, $00, $00, $00, $00
  88+ 268F FB           		DB $fb
  89+ 2690 54 52 45 57  		DB 'T', 'R', 'E', 'W', 'Q'
  89+ 2694 51
  90+ 2695 3E 3C 00 00  		DB '>', '<', $00, $00, $00
  90+ 2699 00
  91+ 269A D5 00 00 00  		DB K_MERGE, $00, $00, $00, $00
  91+ 269E 00
  92+ 269F              		;DB      $00, $00, $00, $00, $00
  93+ 269F DF           		DB $df
  94+ 26A0 59 55 49 4F  		DB 'Y', 'U', 'I', 'O', 'P'
  94+ 26A4 50
  95+ 26A5 00 00 AC 3B  		DB $00, $00, K_AT, ';', '"'
  95+ 26A9 22
  96+ 26AA 5B 5D 00 00  		DB '[', ']', $00, $00, $7f
  96+ 26AE 7F
  97+ 26AF              		;DB      $00, $00, $00, $00, $00
  98+ 26AF FD           		DB $fd
  99+ 26B0 47 46 44 53  		DB 'G', 'F', 'D', 'S', 'A'
  99+ 26B4 41
 100+ 26B5 00 CC 00 00  		DB $00, K_TO, $00, $00, $00
 100+ 26B9 00
 101+ 26BA 7D 7B 5C 7C  		DB '}', '{', '\', '|', '~'
 101+ 26BE 7E
 102+ 26BF              		;DB      $00, $00, $00, $00, $00
 103+ 26BF BF           		DB $bf
 104+ 26C0 48 4A 4B 4C  		DB 'H', 'J', 'K', 'L', K_ENTER
 104+ 26C4 0D
 105+ 26C5 5E 2D 2B 3D  		DB '^', '-', '+', '=', K_SS_ENTER
 105+ 26C9 1D
 106+ 26CA 00 00 00 00  		DB $00, $00, $00, $00, K_CS_ENTER
 106+ 26CE 1E
 107+ 26CF              		;DB      $00, $00, $00, $00, $00
 108+ 26CF FE           		DB $fe
 109+ 26D0 56 43 58 5A  		DB 'V', 'C', 'X', 'Z', $00		; CS IGNORED
 109+ 26D4 00
 110+ 26D5 2F 3F 60 3A  		DB '/', '?', $60, ':', $00
 110+ 26D9 00
 111+ 26DA 00 00 00 00  		DB $00, $00, $00, $00, $00
 111+ 26DE 00
 112+ 26DF              		;DB      $00, $00, $00, $00, $00
 113+ 26DF 7F           		DB $7f
 114+ 26E0 42 4E 4D 00  		DB 'B', 'N', 'M', $00, ' '		; SS IGNORED
 114+ 26E4 20
 115+ 26E5 2A 2C 2E 00  		DB '*', ',', '.', $00, $00
 115+ 26E9 00
 116+ 26EA 00 00 00 00  		DB $00, $00, $00, $00, K_BREAK
 116+ 26EE 1C
 117+ 26EF              		;DB      $00, $00, $00, $00, $00
 118+ 26EF 00           		DB 0
 119+ 26F0
 120+ 26F0              ; --------------
 121+ 26F0              ; keyboard flags
 122+ 26F0              ; --------------
 123+ 26F0              ;
 124+ 26F0 00           flagCS		DB 0					; CS pressed
 125+ 26F1 00           flagSS		DB 0					; SS pressed
 126+ 26F2
 127+ 26F2              ; ---------------
 128+ 26F2              ; other variables
 129+ 26F2              ; ---------------
 130+ 26F2              ;
 131+ 26F2 00           fhandle		DB 0			; file handle of files/dir opened by NMI.sys
 132+ 26F3
 133+ 26F3 00           flgAT		DB 0			; AT flag
 134+ 26F4 00           row		DB 0			; row
 135+ 26F5 00           col		DB 0			; col
 136+ 26F6
 137+ 26F6 00           prevJoy		DB 0			; previous joystroke
 138+ 26F7 00           prevKey		DB 0			; previous keystroke
 139+ 26F8
 140+ 26F8 00 00 00...  utoaBuf		DS 6+1			; buffer to utoa function
 141+ 26FF
 142+ 26FF              //
 143+ 26FF              // VARIABLES USED BY API CALLS (PAGE 5)
 144+ 26FF              //
 145+ 26FF
 146+ 26FF 2E 2E 00     dotDot		DB '..', 0		; used to open/change to current/upper dir (./..)
 147+ 2702
 148+ 2702              ; ----------------
 149+ 2702              ; dir entry buffer
 150+ 2702              ; ----------------
 151+ 2702              ;
 152+ 2702              ; <byte>    attributes (like MSDOS)
 153+ 2702              ; <asciiz>  file/dirname
 154+ 2702              ; <DWord>   date
 155+ 2702              ; <DWord>   filesize
 156+ 2702              ;
 157+ 2702              ; date and filesize are relatives to the end of file/dirname asciiz string
 158+ 2702              ;
 159+ 2702              bufDir					; dir entry buffer
 160+ 2702 00           bDAttr		DB 0
 161+ 2703 00 00 00...  bDName		DS 8+1+3+1+4+4, 0	; set to possible max size
 162+ 2718
 163+ 2718 00 00 00...  buffer		DS 13			; buffer lo load TRD
 164+ 2725              					; 'Virtual Disk', 0
 165+ 2725
# file closed: shareddata.asm
 179  2725              		include "page6data.asm"
# file opened: page6data.asm
   1+ 2725              ;==============================================================================
   2+ 2725              ; Project: NMI.zdsp
   3+ 2725              ; File: page6data.asm
   4+ 2725              ; Date: 03/11/2022 18:35:18
   5+ 2725              ;
   6+ 2725              ; Created with zDevStudio - Z80 Development Studio.
   7+ 2725              ;
   8+ 2725              ;==============================================================================
   9+ 2725
  10+ 2725              ; ==============================================================================
  11+ 2725              ; MESSAGES
  12+ 2725              ; ==============================================================================
  13+ 2725              ;
  14+ 2725
  15+ 2725 16 0C 18 45  msgErr		DB $16,12,32-8,'ESXDOS error ', 0
  15+ 2729 53 58 44 4F
  15+ 272D 53 20 65 72
  15+ 2731 72 6F 72 20
  15+ 2735 00
  16+ 2736
  17+ 2736 16 01 01 44  msg0001		DB $16,1,1,'DR SLUMP NMI NAVIGATOR'
  17+ 273A 52 20 53 4C
  17+ 273E 55 4D 50 20
  17+ 2742 4E 4D 49 20
  17+ 2746 4E 41 56 49
  17+ 274A 47 41 54 4F
  17+ 274E 52
  18+ 274F 16 01 38     msg0002		DB $16,1,56
  19+ 2752              		M_VERSION
  19+ 2752             >		//db 'v0.0.20'
  19+ 2752 76 2D 2E 2D >		db 'v-.-.--'
  19+ 2756 2E 2D 2D    >
  20+ 2759 00           		DB 0
  21+ 275A 16 04 01 44  msg0003		DB $16,4,1,'DEFINE KEYS: '//,0
  21+ 275E 45 46 49 4E
  21+ 2762 45 20 4B 45
  21+ 2766 59 53 3A 20
  22+ 276A 16 06 01 4B  msg0004		DB $16,6,1,'KEY FOR UP? ',0
  22+ 276E 45 59 20 46
  22+ 2772 4F 52 20 55
  22+ 2776 50 3F 20 00
  23+ 277A 16 07 01 4B  msg0005		DB $16,7,1,'KEY FOR DOWN? ',0
  23+ 277E 45 59 20 46
  23+ 2782 4F 52 20 44
  23+ 2786 4F 57 4E 3F
  23+ 278A 20 00
  24+ 278C 16 08 01 4B  msg0006		DB $16,8,1,'KEY FOR LEFT? ',0
  24+ 2790 45 59 20 46
  24+ 2794 4F 52 20 4C
  24+ 2798 45 46 54 3F
  24+ 279C 20 00
  25+ 279E 16 09 01 4B  msg0007		DB $16,9,1,'KEY FOR RIGHT? ',0
  25+ 27A2 45 59 20 46
  25+ 27A6 4F 52 20 52
  25+ 27AA 49 47 48 54
  25+ 27AE 3F 20 00
  26+ 27B1 16 0A 01 4B  msg0008		DB $16,10,1,'KEY FOR ENTER? ',0
  26+ 27B5 45 59 20 46
  26+ 27B9 4F 52 20 45
  26+ 27BD 4E 54 45 52
  26+ 27C1 3F 20 00
  27+ 27C4 16 0B 01 53  msg0009		DB $16,11,1,'SHOW START POPUP WINDOW (Y/N)? ',0
  27+ 27C8 48 4F 57 20
  27+ 27CC 53 54 41 52
  27+ 27D0 54 20 50 4F
  27+ 27D4 50 55 50 20
  27+ 27D8 57 49 4E 44
  27+ 27DC 4F 57 20 28
  27+ 27E0 59 2F 4E 29
  27+ 27E4 3F 20 00
  28+ 27E7 16 0C 01 53  msg0010		DB $16,12,1,'SET STANDARD GRAPHICS ON TIMEX (Y/N)? ',0
  28+ 27EB 45 54 20 53
  28+ 27EF 54 41 4E 44
  28+ 27F3 41 52 44 20
  28+ 27F7 47 52 41 50
  28+ 27FB 48 49 43 53
  28+ 27FF 20 4F 4E 20
  28+ 2803 54 49 4D 45
  28+ 2807 58 20 28 59
  28+ 280B 2F 4E 29 3F
  28+ 280F 20 00
  29+ 2811 16 0D 01 48  msg0011		DB $16,13,1,'HIDE SYSTEM & HIDDEN FILES (Y/N)? ',0
  29+ 2815 49 44 45 20
  29+ 2819 53 59 53 54
  29+ 281D 45 4D 20 26
  29+ 2821 20 48 49 44
  29+ 2825 44 45 4E 20
  29+ 2829 46 49 4C 45
  29+ 282D 53 20 28 59
  29+ 2831 2F 4E 29 3F
  29+ 2835 20 00
  30+ 2837 16 0F 01 48  msgHapp		DB $16,15,1,'HAPPY (Y/N)? ',0
  30+ 283B 41 50 50 59
  30+ 283F 20 28 59 2F
  30+ 2843 4E 29 3F 20
  30+ 2847 00
  31+ 2848
  32+ 2848              		//           +---------+---------+---------+---------+---------+---------+---
  33+ 2848 16 00 00 55  msgHelp		DB $16,0,0, 'UP DOWN LEFT RIGHT / BREAK - Move cursor / leave navigator.'
  33+ 284C 50 20 44 4F
  33+ 2850 57 4E 20 4C
  33+ 2854 45 46 54 20
  33+ 2858 52 49 47 48
  33+ 285C 54 20 2F 20
  33+ 2860 42 52 45 41
  33+ 2864 4B 20 2D 20
  33+ 2868 4D 6F 76 65
  33+ 286C 20 63 75 72
  33+ 2870 73 6F 72 20
  33+ 2874 2F 20 6C 65
  33+ 2878 61 76 65 20
  33+ 287C 6E 61 76 69
  33+ 2880 67 61 74 6F
  33+ 2884 72 2E
  34+ 2886 16 01 00 45  		DB $16,1,0, 'EDIT     - Open upper dir.'
  34+ 288A 44 49 54 20
  34+ 288E 20 20 20 20
  34+ 2892 2D 20 4F 70
  34+ 2896 65 6E 20 75
  34+ 289A 70 70 65 72
  34+ 289E 20 64 69 72
  34+ 28A2 2E
  35+ 28A3 16 02 00 45  		DB $16,2,0, 'ENTER    - Do action over cursor. If dir, open it. If file,'
  35+ 28A7 4E 54 45 52
  35+ 28AB 20 20 20 20
  35+ 28AF 2D 20 44 6F
  35+ 28B3 20 61 63 74
  35+ 28B7 69 6F 6E 20
  35+ 28BB 6F 76 65 72
  35+ 28BF 20 63 75 72
  35+ 28C3 73 6F 72 2E
  35+ 28C7 20 49 66 20
  35+ 28CB 64 69 72 2C
  35+ 28CF 20 6F 70 65
  35+ 28D3 6E 20 69 74
  35+ 28D7 2E 20 49 66
  35+ 28DB 20 66 69 6C
  35+ 28DF 65 2C
  36+ 28E1 16 03 00 20  		DB $16,3,0, '           load it (SNA, TAP, Z80, BAS, ROM, TRD, SCL, SCR).'
  36+ 28E5 20 20 20 20
  36+ 28E9 20 20 20 20
  36+ 28ED 20 20 6C 6F
  36+ 28F1 61 64 20 69
  36+ 28F5 74 20 28 53
  36+ 28F9 4E 41 2C 20
  36+ 28FD 54 41 50 2C
  36+ 2901 20 5A 38 30
  36+ 2905 2C 20 42 41
  36+ 2909 53 2C 20 52
  36+ 290D 4F 4D 2C 20
  36+ 2911 54 52 44 2C
  36+ 2915 20 53 43 4C
  36+ 2919 2C 20 53 43
  36+ 291D 52 29 2E
  37+ 2920 16 04 00 41  		DB $16,4,0, 'A B C D  - Attach TRD or SCL file to virtual disk.'
  37+ 2924 20 42 20 43
  37+ 2928 20 44 20 20
  37+ 292C 2D 20 41 74
  37+ 2930 74 61 63 68
  37+ 2934 20 54 52 44
  37+ 2938 20 6F 72 20
  37+ 293C 53 43 4C 20
  37+ 2940 66 69 6C 65
  37+ 2944 20 74 6F 20
  37+ 2948 76 69 72 74
  37+ 294C 75 61 6C 20
  37+ 2950 64 69 73 6B
  37+ 2954 2E
  38+ 2955 16 05 00 45  		DB $16,5,0, 'E DELETE - Delete file or dir.'
  38+ 2959 20 44 45 4C
  38+ 295D 45 54 45 20
  38+ 2961 2D 20 44 65
  38+ 2965 6C 65 74 65
  38+ 2969 20 66 69 6C
  38+ 296D 65 20 6F 72
  38+ 2971 20 64 69 72
  38+ 2975 2E
  39+ 2976 16 06 00 53  		DB $16,6,0, 'SS+F     - Configure Fast-ramp loader.'
  39+ 297A 53 2B 46 20
  39+ 297E 20 20 20 20
  39+ 2982 2D 20 43 6F
  39+ 2986 6E 66 69 67
  39+ 298A 75 72 65 20
  39+ 298E 46 61 73 74
  39+ 2992 2D 72 61 6D
  39+ 2996 70 20 6C 6F
  39+ 299A 61 64 65 72
  39+ 299E 2E
  40+ 299F 16 07 00 46  		DB $16,7,0, 'F        - Fast-ramp loader.'
  40+ 29A3 20 20 20 20
  40+ 29A7 20 20 20 20
  40+ 29AB 2D 20 46 61
  40+ 29AF 73 74 2D 72
  40+ 29B3 61 6D 70 20
  40+ 29B7 6C 6F 61 64
  40+ 29BB 65 72 2E
  41+ 29BE 16 08 00 47  		DB $16,8,0, 'G        - Load <mon> debugger.'
  41+ 29C2 20 20 20 20
  41+ 29C6 20 20 20 20
  41+ 29CA 2D 20 4C 6F
  41+ 29CE 61 64 20 3C
  41+ 29D2 6D 6F 6E 3E
  41+ 29D6 20 64 65 62
  41+ 29DA 75 67 67 65
  41+ 29DE 72 2E
  42+ 29E0 16 09 00 48  		DB $16,9,0, 'H        - This help.'
  42+ 29E4 20 20 20 20
  42+ 29E8 20 20 20 20
  42+ 29EC 2D 20 54 68
  42+ 29F0 69 73 20 68
  42+ 29F4 65 6C 70 2E
  43+ 29F8 16 0A 00 49  		DB $16,10,0,'I / SS+I - Attach / detach file to / from tapein.'
  43+ 29FC 20 2F 20 53
  43+ 2A00 53 2B 49 20
  43+ 2A04 2D 20 41 74
  43+ 2A08 74 61 63 68
  43+ 2A0C 20 2F 20 64
  43+ 2A10 65 74 61 63
  43+ 2A14 68 20 66 69
  43+ 2A18 6C 65 20 74
  43+ 2A1C 6F 20 2F 20
  43+ 2A20 66 72 6F 6D
  43+ 2A24 20 74 61 70
  43+ 2A28 65 69 6E 2E
  44+ 2A2C 16 0B 00 4A  		DB $16,11,0,'J        - Load old NMI handler.'
  44+ 2A30 20 20 20 20
  44+ 2A34 20 20 20 20
  44+ 2A38 2D 20 4C 6F
  44+ 2A3C 61 64 20 6F
  44+ 2A40 6C 64 20 4E
  44+ 2A44 4D 49 20 68
  44+ 2A48 61 6E 64 6C
  44+ 2A4C 65 72 2E
  45+ 2A4F 16 0C 00 4B  		DB $16,12,0,'K        - Configure navigator.'
  45+ 2A53 20 20 20 20
  45+ 2A57 20 20 20 20
  45+ 2A5B 2D 20 43 6F
  45+ 2A5F 6E 66 69 67
  45+ 2A63 75 72 65 20
  45+ 2A67 6E 61 76 69
  45+ 2A6B 67 61 74 6F
  45+ 2A6F 72 2E
  46+ 2A71 16 0D 00 4C  		DB $16,13,0,'L        - Lock paging register.'
  46+ 2A75 20 20 20 20
  46+ 2A79 20 20 20 20
  46+ 2A7D 2D 20 4C 6F
  46+ 2A81 63 6B 20 70
  46+ 2A85 61 67 69 6E
  46+ 2A89 67 20 72 65
  46+ 2A8D 67 69 73 74
  46+ 2A91 65 72 2E
  47+ 2A94 16 0E 00 4E  		DB $16,14,0,'N        - Rename file.'
  47+ 2A98 20 20 20 20
  47+ 2A9C 20 20 20 20
  47+ 2AA0 2D 20 52 65
  47+ 2AA4 6E 61 6D 65
  47+ 2AA8 20 66 69 6C
  47+ 2AAC 65 2E
  48+ 2AAE 16 0F 00 4F  		DB $16,15,0,'O / SS+O - Attach / detach file to / from tapeout.'
  48+ 2AB2 20 2F 20 53
  48+ 2AB6 53 2B 4F 20
  48+ 2ABA 2D 20 41 74
  48+ 2ABE 74 61 63 68
  48+ 2AC2 20 2F 20 64
  48+ 2AC6 65 74 61 63
  48+ 2ACA 68 20 66 69
  48+ 2ACE 6C 65 20 74
  48+ 2AD2 6F 20 2F 20
  48+ 2AD6 66 72 6F 6D
  48+ 2ADA 20 74 61 70
  48+ 2ADE 65 6F 75 74
  48+ 2AE2 2E
  49+ 2AE3 16 10 00 50  		DB $16,16,0,'P        - Poke.'
  49+ 2AE7 20 20 20 20
  49+ 2AEB 20 20 20 20
  49+ 2AEF 2D 20 50 6F
  49+ 2AF3 6B 65 2E
  50+ 2AF6 16 11 00 52  		DB $16,17,0,'R        - Reset.'
  50+ 2AFA 20 20 20 20
  50+ 2AFE 20 20 20 20
  50+ 2B02 2D 20 52 65
  50+ 2B06 73 65 74 2E
  51+ 2B0A 16 12 00 53  		DB $16,18,0,'S        - Save snapshot on current dir.'
  51+ 2B0E 20 20 20 20
  51+ 2B12 20 20 20 20
  51+ 2B16 2D 20 53 61
  51+ 2B1A 76 65 20 73
  51+ 2B1E 6E 61 70 73
  51+ 2B22 68 6F 74 20
  51+ 2B26 6F 6E 20 63
  51+ 2B2A 75 72 72 65
  51+ 2B2E 6E 74 20 64
  51+ 2B32 69 72 2E
  52+ 2B35 16 13 00 54  		DB $16,19,0,'T        - Start TR-DOS Emulator & autoload from virtual disk.'
  52+ 2B39 20 20 20 20
  52+ 2B3D 20 20 20 20
  52+ 2B41 2D 20 53 74
  52+ 2B45 61 72 74 20
  52+ 2B49 54 52 2D 44
  52+ 2B4D 4F 53 20 45
  52+ 2B51 6D 75 6C 61
  52+ 2B55 74 6F 72 20
  52+ 2B59 26 20 61 75
  52+ 2B5D 74 6F 6C 6F
  52+ 2B61 61 64 20 66
  52+ 2B65 72 6F 6D 20
  52+ 2B69 76 69 72 74
  52+ 2B6D 75 61 6C 20
  52+ 2B71 64 69 73 6B
  52+ 2B75 2E
  53+ 2B76 16 14 00 43  		DB $16,20,0,'CS+T     - Start TR-DOS Emulator & enter TR-DOS mode.'
  53+ 2B7A 53 2B 54 20
  53+ 2B7E 20 20 20 20
  53+ 2B82 2D 20 53 74
  53+ 2B86 61 72 74 20
  53+ 2B8A 54 52 2D 44
  53+ 2B8E 4F 53 20 45
  53+ 2B92 6D 75 6C 61
  53+ 2B96 74 6F 72 20
  53+ 2B9A 26 20 65 6E
  53+ 2B9E 74 65 72 20
  53+ 2BA2 54 52 2D 44
  53+ 2BA6 4F 53 20 6D
  53+ 2BAA 6F 64 65 2E
  54+ 2BAE 16 15 00 53  		DB $16,21,0,'SS+T     - Start TR-DOS Emulator & loads TR-DOS Navigator.'
  54+ 2BB2 53 2B 54 20
  54+ 2BB6 20 20 20 20
  54+ 2BBA 2D 20 53 74
  54+ 2BBE 61 72 74 20
  54+ 2BC2 54 52 2D 44
  54+ 2BC6 4F 53 20 45
  54+ 2BCA 6D 75 6C 61
  54+ 2BCE 74 6F 72 20
  54+ 2BD2 26 20 6C 6F
  54+ 2BD6 61 64 73 20
  54+ 2BDA 54 52 2D 44
  54+ 2BDE 4F 53 20 4E
  54+ 2BE2 61 76 69 67
  54+ 2BE6 61 74 6F 72
  54+ 2BEA 2E
  55+ 2BEB 16 16 00 55  		DB $16,22,0,'U        - Change current drive (cycling).'
  55+ 2BEF 20 20 20 20
  55+ 2BF3 20 20 20 20
  55+ 2BF7 2D 20 43 68
  55+ 2BFB 61 6E 67 65
  55+ 2BFF 20 63 75 72
  55+ 2C03 72 65 6E 74
  55+ 2C07 20 64 72 69
  55+ 2C0B 76 65 20 28
  55+ 2C0F 63 79 63 6C
  55+ 2C13 69 6E 67 29
  55+ 2C17 2E
  56+ 2C18 16 17 00 56  		DB $16,23,0,'V / SS+V - View screen (SCR, SNA) / view with hexview.'
  56+ 2C1C 20 2F 20 53
  56+ 2C20 53 2B 56 20
  56+ 2C24 2D 20 56 69
  56+ 2C28 65 77 20 73
  56+ 2C2C 63 72 65 65
  56+ 2C30 6E 20 28 53
  56+ 2C34 43 52 2C 20
  56+ 2C38 53 4E 41 29
  56+ 2C3C 20 2F 20 76
  56+ 2C40 69 65 77 20
  56+ 2C44 77 69 74 68
  56+ 2C48 20 68 65 78
  56+ 2C4C 76 69 65 77
  56+ 2C50 2E
  57+ 2C51 00           		DB 0
  58+ 2C52
  59+ 2C52              ; =============================================================================
  60+ 2C52              ; ACTIONS DATA
  61+ 2C52              ; =============================================================================
  62+ 2C52
  63+ 2C52 2F 53 59 53  dbFnConfigFile	DB '/SYS/NMI/NMI.CNF',0
  63+ 2C56 2F 4E 4D 49
  63+ 2C5A 2F 4E 4D 49
  63+ 2C5E 2E 43 4E 46
  63+ 2C62 00
  64+ 2C63
  65+ 2C63 ~            		/*
  66+ 2C63 ~            dbFnHelFile1	DB '/SYS/NMI/HELP1.SCR',0
  67+ 2C63 ~            dbFnHelFile2	DB '/SYS/NMI/HELP2.SCR',0
  68+ 2C63 ~            dbFnHelFile3	DB '/SYS/NMI/HELP3.SCR',0
  69+ 2C63 ~            		*/
  70+ 2C63
  71+ 2C63 41 42 43 44  unavail		DB 'ABCDEFGHIJKLNOPRSTUV',K_DELETE,K_TO,K_EDIT	; M deleted
  71+ 2C67 45 46 47 48
  71+ 2C6B 49 4A 4B 4C
  71+ 2C6F 4E 4F 50 52
  71+ 2C73 53 54 55 56
  71+ 2C77 0C CC 07
  72+ 2C7A AC 3B 1D 1E  		DB K_AT,';',K_SS_ENTER,K_CS_ENTER
  73+ 2C7E 00 00 00 00  usedK		DB 0,0,0,0,0
  73+ 2C82 00
  74+ 2C83
  75+ 2C83              ; ---------
  76+ 2C83              ; key names
  77+ 2C83              ; ---------
  78+ 2C83              ;
  79+ 2C83 44 45 4C 45  mDelete		DB 'DELETE',0
  79+ 2C87 54 45 00
  80+ 2C8A 53 50 41 43  mSpace		DB 'SPACE',0
  80+ 2C8E 45 00
  81+ 2C90 45 4E 54 45  mEnter		DB 'ENTER',0
  81+ 2C94 52 00
  82+ 2C96 42 52 45 41  mBreak		DB 'BREAK',0
  82+ 2C9A 4B 00
  83+ 2C9C 4C 45 46 54  mLeft		DB 'LEFT',0
  83+ 2CA0 00
  84+ 2CA1 52 49 47 48  mRight		DB 'RIGHT',0
  84+ 2CA5 54 00
  85+ 2CA7 55 50 00     mUp		DB 'UP',0
  86+ 2CAA 44 4F 57 4E  mDown		DB 'DOWN',0
  86+ 2CAE 00
  87+ 2CAF 45 44 49 54  mEdit		DB 'EDIT',0
  87+ 2CB3 00
  88+ 2CB4 53 53 2B 46  mTo		DB 'SS+F',0
  88+ 2CB8 00
  89+ 2CB9 53 53 2B 45  mSSEnt		DB 'SS+ENTER',0
  89+ 2CBD 4E 54 45 52
  89+ 2CC1 00
  90+ 2CC2 43 53 2B 45  mCSEnt		DB 'CS+ENTER',0
  90+ 2CC6 4E 54 45 52
  90+ 2CCA 00
  91+ 2CCB 53 53 2B 49  mAt		DB 'SS+I',0
  91+ 2CCF 00
  92+ 2CD0
  93+ 2CD0
  94+ 2CD0              ; ---------------
  95+ 2CD0              ; other variables
  96+ 2CD0              ; ---------------
  97+ 2CD0              ;
  98+ 2CD0              bufConf					; config buffer
  99+ 2CD0 00           cfPopUp		DB 0
 100+ 2CD1 00           cfLeft		DB 0
 101+ 2CD2 00           cfRight		DB 0
 102+ 2CD3 00           cfDown		DB 0
 103+ 2CD4 00           cfUp		DB 0
 104+ 2CD5 00           cfEnter		DB 0
 105+ 2CD6 00           cfOut		DB 0
 106+ 2CD7 00           cfHidden	DB 0
 107+ 2CD8
 108+ 2CD8              //
 109+ 2CD8              // PARA JOYSTICK, PERO LAS ACTUALIZADAS CON LA CONFIG ESTAN EN LA PAGINA 5
 110+ 2CD8              // LAS TECLAS UTILIZADAS EN LOS MODULOS NO UTILIZAN LA CONFIGURACION?!
 111+ 2CD8              //
 112+ 2CD8 08           kLeft		DB K_LEFT		; prev page
 113+ 2CD9 0A           kDown		DB K_DOWN		; line down
 114+ 2CDA 0B           kUp		DB K_UP			; line up
 115+ 2CDB 09           kRight		DB K_RIGHT		; next page
 116+ 2CDC 0D           kEnter		DB K_ENTER		; do action
 117+ 2CDD
 118+ 2CDD
# file closed: page6data.asm
 180  2CDD
 181  2CDD              		; -------------------------------------------------------------
 182  2CDD              		IF $ > PAGE_START+PAGE_LENGTH
 183  2CDD ~            		LUA
 184  2CDD ~            		sj.error("Page ".._c("DivXXXPg")..": Resulting code too long ("
 185  2CDD ~            		..(_c("$")-(_c("PAGE_START")+_c("PAGE_LENGTH"))).." bytes)")
 186  2CDD ~            		ENDLUA
 187  2CDD              		ENDIF
 188  2CDD              		; -------------------------------------------------------------
 189  2CDD
 190  2CDD              		ENDMODULE
 191  2CDD
 192  2CDD              pg6end		ENT
 193  566B
 194  566B              ;==============================================================================
 195  566B              ; END
 196  566B              ;==============================================================================
 197  566B
 198  566B              offsetEnd	EQU $-NMI_OVERLAY	; offset relative to start of file
 199  566B              					; used to see file length
 200  566B
 201  566B              		LUA
 202  566B ~            		print("----------------------")
 203  566B ~            		print("NMI_SIZE:    "..string.format("%04x ",_c("NMI_SIZE")).._c("NMI_SIZE"))
 204  566B ~            		print("PAGE_LENGTH: "..string.format("%04x ",_c("PAGE_LENGTH")).._c("PAGE_LENGTH"))
 205  566B ~            		print("Size p0:     "..string.format("%04x ",_c("pg0end-pg0start")).._c("pg0end-pg0start"))
 206  566B ~            		print("Size p5:     "..string.format("%04x ",_c("pg5end-pg5start")).._c("pg5end-pg5start"))
 207  566B ~            		print("Size p6:     "..string.format("%04x ",_c("pg6end-pg6start")).._c("pg6end-pg6start"))
 208  566B ~            		print("offsetPg5:   "..string.format("%04x ",_c("offsetPg5")).._c("offsetPg5"))
 209  566B ~            		print("offsetPg6:   "..string.format("%04x ",_c("offsetPg6")).._c("offsetPg6"))
 210  566B ~            		print("offsetEnd:   "..string.format("%04x ",_c("offsetEnd")).._c("offsetEnd"))
 211  566B ~            		print("----------------------")
 212  566B              		ENDLUA
 213  566B
 214  566B              		END
# file closed: NMI.asm

Value    Label
------ - -----------------------------------------------------------
0x276B X offsetEnd
0x2CDD X pg6end
0x276A X page6.msg0004
0x274F X page6.msg0002
0x2703 X page6.bDName
0x2702 X page6.bDAttr
0x2725   page6.msgErr
0x24F4 X page6.chrNorm
0x2CC2   page6.mCSEnt
0x2CB9   page6.mSSEnt
0x2CCB   page6.mAt
0x2CB4   page6.mTo
0x2CAF   page6.mEdit
0x2CAA   page6.mDown
0x2CA7   page6.mUp
0x2CA1   page6.mRight
0x2C9C   page6.mLeft
0x2C96   page6.mBreak
0x2C8A   page6.mSpace
0x2C90   page6.mEnter
0x24F8   page6.prSelL1
0x2C83   page6.mDelete
0x2CD0   page6.bufConf
0x2C52   page6.dbFnConfigFile
0x2458   page6.rl_lp
0x2443   page6.lr_lp
0x2432   page6.rr_lp
0x2421   page6.ll_lp
0x2441   page6.l_on_r
0x2430   page6.r_on_r
0x2456   page6.r_on_l
0x241F   page6.l_on_l
0x2415 X page6.even_col
0x241A   page6.odd_col
0x251F   page6.dbTbFont
0x23DC   page6.zend
0x23E0   page6.wrap
0x23E3   page6.pr_64
0x23C5   page6.prOk
0x23C3   page6.prErr
0x23D0   page6.do_cr
0x26F5   page6.col
0x26F4   page6.row
0x23B2   page6.err_b
0x23A5   page6.getcol
0x23B7   page6.crchk
0x238A X page6.atchk
0x2394   page6.getrow
0x237A   page6.notChk
0x26F3   page6.flgAT
0x26F8   page6.utoaBuf
0x2362   page6.cvtLowerNibble
0x2356   page6._6_
0x2353   page6._5_
0x234F   page6._4_
0x234B   page6._3_
0x2347   page6._2_
0x2343   page6._1_
0x2326 X page6.bcd2hex
0x2316   page6.cvtLoop
0x230F   page6._utoa
0x22F9   page6.clScrL0
0x22C1   page6.waitL0
0x2CDC   page6.kEnter
0x22BD   page6.joy5
0x2CDA   page6.kUp
0x22AF   page6.joy4
0x22A7   page6.joy3
0x2CD8   page6.kLeft
0x229F   page6.joy2
0x2CDB   page6.kRight
0x2297   page6.joy1
0x22B7   page6.joy6
0x225D   page6.paso2
0x26F0   page6.flagCS
0x2255   page6.paso1
0x26F1   page6.flagSS
0x223A   page6.ignCol
0x2245   page6.pressed
0x2236   page6.nextCol
0x222C   page6.nextRow
0x266F   page6.dbTbKeys
0x225F   page6.ckMods
0x2223   page6.readKey
0x2212   page6._L3
0x26F7   page6.prevKey
0x220D   page6._L2
0x2276   page6.readJoy
0x21FC   page6._L1
0x26F6   page6.prevJoy
0x21F1   page6.beep03
0x21E9   page6.beep02
0x21E2   page6.beep01
0x21E0 X page6.beep
0x21DB X page6.fDetachTapeOut
0x21D1 X page6.fAttachTapeOut
0x21CC X page6.fDetachTapeIn
0x21C2 X page6.fAttachTapeIn
0x2718   page6.buffer
0x21B5 X page6.fMountVDisk
0x21B2 X page6.fEjectVDisk
0x21AC X page6.fGetSetDrv
0x21AB X page6.fGetSetDrv1
0x21A5 X page6.fAutoLoad
0x2194 X page6.fExecCMD
0x218C X page6.fGetCWD
0x2184 X page6.fChDir
0x2176 X page6.fRename
0x216D X page6.fRewindDir
0x2164 X page6.fTellDir
0x215B X page6.fSeekDir
0x2702   page6.bufDir
0x2152 X page6.fReadDir
0x26FF   page6.dotDot
0x2142 X page6.fOpenDir
0x2139   page6.fClose
0x212E X page6.fSeek
0x2125   page6.fWrite
0x24FC   page6.closeFilePrErr
0x211C   page6.fRead
0x26F2   page6.fhandle
0x2503   page6.prError
0x2113   page6.fOpen1
0x2111 X page6.fOpen
0x2848   page6.msgHelp
0x20F2   page6.help
0x20EF   page6.chkKey2
0x20E5   page6.chkKey1
0x2103   page6.helpEnd
0x20D8   page6.exit
0x2482   page6.writeCnf
0x22BF   page6.wait
0x2837   page6.msgHapp
0x2CD7   page6.cfHidden
0x20BC   page6.configL3
0x2811   page6.msg0011
0x2CD6   page6.cfOut
0x20A3   page6.configL2
0x27E7   page6.msg0010
0x2CD0   page6.cfPopUp
0x208A   page6.configL1
0x2382   page6.prChr
0x21F7   page6.waitKey
0x2CD5   page6.cfEnter
0x27B1   page6.msg0008
0x2CD2   page6.cfRight
0x279E   page6.msg0007
0x2CD1   page6.cfLeft
0x278C   page6.msg0006
0x2CD3   page6.cfDown
0x277A   page6.msg0005
0x2499   page6.prKeyName
0x2CD4   page6.cfUp
0x20DA   page6.chkKey
0x275A   page6.msg0003
0x236F   page6.prStr
0x2736   page6.msg0001
0x2C7E   page6.usedK
0x246B   page6.readCnf
0x22C7   page6.clrScr
0x2000   page6.config
0x2000 X pg6start
0x1A8E   offsetPg6
0x380C X pg5end
0x37F7 X page5.endData
0x35FB   page5.pPrvDir
0x34F1 X page5.msg0002
0x33C1 X page5.msgTypeErr
0x323C   page5.dbdwTbExtView
0x2F84 X page5.view.isDir
0x2F87   page5.view.isFile
0x2F7D   page5.view.start
0x33E9   page5.msgOkSelDrv
0x2F63   page5.seldrv.noErr
0x2F54   page5.seldrv.start
0x2F42   page5.savSNA.saveL3
0x2F27   page5.savSNA.saveL2
0x2F1A   page5.savSNA.v085_L2
0x2F03   page5.savSNA.v085_L1
0x2F48   page5.savSNA.saveL4
0x358D   page5.NMIbuf
0x2EC2   page5.savSNA.saveL0
0x2ECF   page5.savSNA.saveL1
0x355F   page5.dbFnSnapName
0x2CD9   page6.kDown
0x2EAF   page5.savSNA.fileExt
0x3380   page5.msgSave
0x2EA1   page5.savSNA.start
0x3371   page5.msgReseting
0x2E86   page5.reset.start
0x3354   page5.msgPok4
0x3352   page5.msgPok3
0x3349   page5.msgPok2
0x2E47   page5.pokeC3
0x2E2C   page5.pokeC2
0x2E2B   page5.pokeC1
0x2E0F   page5.pokeC0
0x2DDF   page5.pokeG5
0x2DF0   page5.pokeG6
0x2E0A   page5.pokeG7
0x2DC2   page5.pokeG4
0x2D8C   page5.pokeG1
0x2D9D   page5.pokeG2
0x2DB7   page5.pokeG3
0x2E83   page5.retPoke
0x2D73   page5.pokeG0
0x3548   page5.dbStrPokeValue
0x333F   page5.msgPok1
0x37FE   page5.pokeVal
0x37FC   page5.pokeAdd
0x2D57   page5.poke.start
0x345B   page5.msgAttOut
0x2D3A X page5.tapeout.isDir
0x2D3D   page5.tapeout.isFile
0x2D1C X page5.tapeout.detach
0x2D33   page5.tapeout.attach
0x2D13   page5.tapeout.start
0x2CEB   page5.renL4
0x2D05   page5.renL3
0x2CBE   page5.renL2
0x3552   page5.dbFnNewFileName
0x3363   page5.msgNewN
0x2CAB   page5.rename.start
0x3331   page5.msgLocking
0x2C80   page5.lock.start
0x2C6D   page5.config.start
0x5B0E   page5.loadOld_reloc
0x2C2D   page5.loadOld
0x5B4C   page5.sp_reloc
0x5B4A   page5.hl_reloc
0x5B49   page5.fh_reloc
0x2C68   page5.fh
0x5B35   page5.fn_reloc
0x2C54   page5.fn
0x2C6D   page5.loaderEnd
0x2C1F   page5.loader
0x2C62   page5.fnv
0x2C6B   page5.copySP
0x2C69   page5.copyHL
0x358B   page5.NMIbuf_org
0x2BF9   page5.loadOld.start
0x3409   page5.msgAttIn
0x2BDC X page5.tapein.isDir
0x2BDF   page5.tapein.isFile
0x3431   page5.msgDetIn
0x2BBE X page5.tapein.detach
0x2BD5   page5.tapein.attach
0x2BA7   page5.help.start
0x3735   page5.dotCommMon
0x331A   page5.msgStat
0x2B90   page5.debug.start
0x2B84 X page5.fastLoad.updDrv
0x2B70 X page5.fastLoad.chgDrv
0x2B41   page5.fastLoad.start
0x2B0F X page5.fastcfg.getCWD
0x2AFD X page5.fastcfg.getCDrv
0x3533   page5.dbFnFastFile
0x32E1   page5.msgSaveFC
0x2AE2 X page5.fastcfg.isDir
0x2AE5   page5.fastcfg.isFile
0x2ADB   page5.fastcfg.start
0x3739   page5.dotCommRm
0x3740   page5.bDName2
0x3305   page5.msgDel
0x32F3   page5.msgOkDel
0x2AAB   page5.delFile.start
0x2AA8 X page5.trd2drv.retMnt
0x34AF   page5.msgOk
0x2A75   page5.trd2drv.strcmp2
0x3237   page5.extSCL
0x2A7E   page5.trd2drv.attTRD
0x2A6B   page5.trd2drv.chkSCL
0x2A61   page5.trd2drv.strcmp
0x3232   page5.extTRD
0x3801   page5.dwPtrExt
0x2A58 X page5.trd2drv.yesDot
0x2A55 X page5.trd2drv.noDot
0x2A3F X page5.trd2drv.isDir
0x2A42   page5.trd2drv.isFile
0x34C7   page5.unitLet
0x3800   page5.dbDrive
0x2A2E   page5.trd2drv.start3
0x2A2A   page5.trd2drv.start2
0x2A26   page5.trd2drv.start1
0x2A30   page5.trd2drv.trd2drv
0x2A23   page5.trd2drv.start0
0x372E   page5.dotCommOwnrom
0x2A06   page5.loadROM
0x356C   page5.trdBas
0x29F3   page5.ldTRD02
0x29FB   page5.ldTRD01
0x29DC   page5.startTRDOS
0x29CF   page5.loadTRD
0x29B6   page5.loadTAP
0x3762   page5.dotCommSnapload
0x29AD   page5.loadSNA
0x374D   page5.dotCommHexview
0x3755   page5.bDName3
0x2985   page5.viewSNA
0x2973   page5.readSCR
0x296B   page5.viewSCR
0x2949   page5.doAct.strcmp
0x2999   page5.viewHex
0x2940   page5.doAct.compStr
0x293D X page5.doAct.yesDot
0x29C4   page5.loadBAS
0x293A X page5.doAct.noDot
0x2929   page5.doAct.exeAction
0x3219   page5.dbdwTbExtAct
0x2926   page5.doAct.exeAction1
0x3396   page5.msgDir
0x2901 X page5.doAct.isDir
0x295E   page5.doAct.otra
0x2915   page5.doAct.isFile
0x28F2   page5.doAct.start
0x32A6   page5.msgLock
0x28C8   page5.isUnlocked
0x3582   page5.flgLOCK
0x3506   page5.msgUnlocked
0x28CD   page5.notToastrack
0x28AC   page5.skipReload
0x2899   page5.doReload
0x3729   page5.ldDir
0x288B   page5.skipSetStdGr
0x287E   page5.wait1
0x2877   page5.wait0
0x286F   page5.wait2
0x286C   page5.wait3
0x28D1   page5.clrAttr
0x2857   page5.waitE
0x34D8   page5.msg0001
0x380B   page5.cfHidden
0x372B   page5.flgOut
0x380A   page5.cfOut
0x372A   page5.flgPopUp
0x33AE   page5.msgFile
0x3804   page5.cfPopUp
0x3809   page5.cfEnter
0x3807   page5.cfDown
0x3808   page5.cfUp
0x3806   page5.cfRight
0x3805   page5.cfLeft
0x2882   page5.skipLoadConfig
0x3728   page5.ldConf
0x32C4   page5.msgRAM2
0x3586   page5.divRAM
0x32AF   page5.msgRAM1
0x3502   page5.msg128k
0x34FF   page5.msg48k
0x27DE   page5.noes48k
0x27E4   page5.copyRAM
0x34FC   page5.msg16k
0x27D2   page5.noes16k
0x3588   page5.speccyRAM
0x32B6   page5.msgVer
0x27BB   page5.copyVersion
0x27AE X page5.ver086_8
0x27B8   page5.ver087
0x27B3   page5.ver085
0x358A   page5.esxDOSv
0x279F X page5.doInit
0x2801   page5.skipInit
0x3727   page5.ldInit
0x3247   page5.msgErr
0x3804   page5.bufConf
0x3522   page5.dbFnConfigFile
0x275A   page5.readCnf
0x2757   page5.Nuevo
0x2748   page5.Otro
0x2746   page5.findDrv
0x357E   page5.prefix
0x2721   page5.divL2
0x2717   page5.divL1
0x270D   page5.divL0
0x217E X page6.fUnlink1
0x270B X page5.div1024
0x272B   page5.normL6
0x2708   page5.normL5
0x26F7   page5.normL4
0x37F9   page5.pDSizeH
0x37F7   page5.pDSizeL
0x37FB   page5.prefixCnt
0x26CE   page5.label2
0x26CB   page5.label1
0x26B5   page5.skipDotSavePtr
0x26AD   page5.testCWD2
0x325F   page5.msgPath
0x269C   page5.testCWD1
0x2694   page5.testCWD
0x325B   page5.msgDrv
0x267D   page5.copyCWD
0x372D   page5.strLen
0x2678   page5.noCrop
0x265C   page5.itsOk
0x2656   page5.notRoot
0x376B   page5.dbStrPathName
0x3401   page5.drvName
0x2631   page5.getCWD
0x261F   page5.convDrv
0x2611   page5.deleteScreen
0x25FA   page5.toFile
0x25EB   page5.restoreScreen
0x3510   page5.dbFnBackupFile
0x25D4   page5.SavetoFile
0x3589   page5.savRAM
0x25C5   page5.saveScreen
0x25B2   page5.rl_lp
0x259D   page5.lr_lp
0x258C   page5.rr_lp
0x257B   page5.ll_lp
0x259B   page5.l_on_r
0x258A   page5.r_on_r
0x25B0   page5.r_on_l
0x2579   page5.l_on_l
0x256F X page5.even_col
0x2574   page5.odd_col
0x2FA6   page5.dbTbFont
0x2536   page5.zend
0x253A   page5.wrap
0x253D   page5.pr_64
0x251F   page5.prOk
0x251D   page5.prErr
0x252A   page5.do_cr
0x317B   page5.row
0x250C   page5.err_b
0x24FF   page5.getcol
0x2511   page5.crchk
0x24E4 X page5.atchk
0x24EE   page5.getrow
0x24D4   page5.notChk
0x317A   page5.flgAT
0x317F   page5.utoaBuf
0x24BC   page5.cvtLowerNibble
0x24B8   page5.cvtUpperNibble
0x24B0   page5._6_
0x24AD   page5._5_
0x24A9   page5._4_
0x24A5   page5._3_
0x24A1   page5._2_
0x249D   page5._1_
0x2480 X page5.bcd2hex
0x2470   page5.cvtLoop
0x2469   page5._utoa
0x2453   page5.clScrL0
0x241B   page5.waitL0
0x2C63   page6.unavail
0x320C   page5.kEnter
0x2417   page5.joy5
0x3206   page5.kUp
0x2409   page5.joy4
0x3203   page5.kDown
0x2401   page5.joy3
0x3200   page5.kLeft
0x23F9   page5.joy2
0x3209   page5.kRight
0x23F1   page5.joy1
0x2411   page5.joy6
0x23B7   page5.paso2
0x3177   page5.flagCS
0x23AF   page5.paso1
0x3178   page5.flagSS
0x2394   page5.ignCol
0x239F   page5.pressed
0x2390   page5.nextCol
0x2386   page5.nextRow
0x30F6   page5.dbTbKeys
0x23B9   page5.ckMods
0x237D   page5.readKey
0x236C   page5._L3
0x317E   page5.prevKey
0x2367   page5._L2
0x23D0   page5.readJoy
0x2356   page5._L1
0x317D   page5.prevJoy
0x234B   page5.beep03
0x2343   page5.beep02
0x233C   page5.beep01
0x2335   page5.fDetachTapeOut
0x232B   page5.fAttachTapeOut
0x2326   page5.fDetachTapeIn
0x231C   page5.fAttachTapeIn
0x319F   page5.buffer
0x230F   page5.fMountVDisk
0x230C   page5.fEjectVDisk
0x2306   page5.fGetSetDrv
0x2305   page5.fGetSetDrv1
0x22FF   page5.fAutoLoad
0x22EE   page5.fExecCMD
0x22E6   page5.fGetCWD
0x22D8   page5.fUnlink1
0x22D0   page5.fRename
0x22C7   page5.fRewindDir
0x3189   page5.bufDir
0x2288   page5.fSeek
0x227F   page5.fWrite
0x2771   page5.closeFilePrErr
0x2276   page5.fRead
0x3179   page5.fhandle
0x2778   page5.prError
0x226D   page5.fOpen1
0x226B   page5.fOpen
0x2267   page5.prMidL5
0x26DD   page5.prtSize
0x2249   page5.prMidL2
0x32D7   page5.msgMid2
0x223E X page5.isDir
0x3803   page5.flagT
0x2246   page5.isFile
0x318A   page5.bDName
0x32DD   page5.msgMid4
0x32D3   page5.msgMid1
0x221B X page5.prMidL1
0x2258   page5.prMidL4
0x372C   page5.flgHidden
0x3189   page5.bDAttr
0x224E   page5.prMidL3
0x22BE   page5.fTellDir
0x21D9   page5.prMidL0
0x32A3   page5.msgBot5
0x32A1   page5.msgBot4
0x21B1   page5.prBot2
0x24DC   page5.prChr
0x21AE   page5.prBot1
0x329F   page5.msgBot3
0x24C3   page5.utoa
0x329A   page5.msgBot1
0x24C9   page5.prStr
0x3258   page5.msgTop1
0x215E   page5.multx2
0x2157   page5.prCurL0
0x2293   page5.fClose
0x22AC   page5.fReadDir
0x22B5   page5.fSeekDir
0x229C   page5.fOpenDir
0x20F2   page5.nextPg
0x35B4   page5.ofY
0x35B6   page5.pCurDir
0x35AE   page5.pCurPg
0x20AE   page5.prevPg
0x35B0   page5.Xof
0x2107   page5.nextPg1
0x20DD   page5.nextCk
0x2098   page5.nextLn1
0x35B2   page5.Xlim
0x2080   page5.nextLn
0x20BE   page5.prevPg1
0x20A4   page5.prevCk
0x2073   page5.prevLn1
0x35AC   page5.curLn
0x2151   page5.clCur
0x2063   page5.prevLn
0x22DE   page5.fChDir
0x3186   page5.dotDot
0x3583   page5.flgROOT
0x2053   page5.upDir
0x2419   page5.wait
0x2042   page5.exitNMI
0x2131   page5.readEnt
0x2030   page5.nextKey
0x31AC   page5.dbdwTbActions
0x233A   page5.beep
0x2351   page5.waitKey
0x2026   page5.mainL5
0x2155   page5.prCur
0x2180   page5.prBot
0x2020   page5.mainL4
0x21BE   page5.prMid
0x201D   page5.mainL3
0x2171   page5.prTop
0x2421   page5.clrScr
0x2012   page5.mainL2
0x2798   page5.startup.start
0x200B   page5.mainL1
0x3584   page5.savedSP
0x2000   page5.mainNMI
0x2000 X pg5start
0x0282   offsetPg5
0x3182 X pg0end
0x5B22   initNMI.__4
0x5B05   initNMI.__3
0x2369   page6.utoa
0x5B37   initNMI.dbPtrTestBuf
0x3FFF   initNMI.dbTestedByte
0x30A9   initNMI.__2
0x309F   initNMI.__1
0x3094   initNMI.lbDeleteScreen
0x3078   initNMI.lbToFile
0x3069 X initNMI.lbRestoreScreen
0x3065   initNMI.lbBack
0x303D   3>LoadPageL1
0x3018   2>LoadPageL1
0x30F3   initNMI.dbFnNMISys
0x2FF3   1>InitPagesL2
0x2FD9   1>InitPagesL1
0x3112   initNMI.msgErrRAM
0x313F   initNMI.msgErrVer
0x30EA   initNMI.dwDivRAM
0x0037   initNMI.lbTestLen
0x30B1   initNMI.lbTest
0x30EC   initNMI.dbSpeccyRAM
0x2FA6   initNMI.lbRAMsize
0x30EE   initNMI.dbEsxDOSv
0x317C   page5.col
0x309C   initNMI.lbPrtErr
0x3163   initNMI.msgUnkVer
0x2F8C   initNMI.ver089
0x2F8C   initNMI.ver088
0x2F8C   initNMI.ver086
0x2F8B   initNMI.notV086
0x2F8C   initNMI.ver087
0x2F6B   initNMI.notV087
0x2F8C   initNMI.ver085
0x2F55   initNMI.notV085
0x3041   initNMI.lbStart
0x30F1   initNMI.dbFirstTime
0x30F2   initNMI.dbFileHandle
0x3100   initNMI.dbFnBackupFile
0x2F38   initNMI.lbChkFirstTime
0x2F17   initNMI.lbSkipErr
0x30ED   initNMI.dbSavRAM
0x2F07 X initNMI.lbSaveScreen
0x30EF   initNMI.dwPtrNMIbuf
0x30E8   initNMI.dwSavedSP
0x2F00 X pg0start
0x0081 X EEOF
0x2BB5   page5.tapein.start
0x0080 X EEOC
0x001F X EDEVBUSY
0x001E X EFILESYS
0x001D X EDRVBUSY
0x001C X EMAPRAM
0x001B X ENOTEMPTY
0x001A X ELOADKO
0x0019 X EVERIFY
0x0018 X ERDONLY
0x27C4   page6.msg0009
0x0017 X EINUSE
0x0016 X ENOCMD
0x0015 X ENAMETOOLONG
0x0014 X ENOSYS
0x0013 X EPATH
0x0012 X EEXIST
0x0011 X ENOTDIR
0x0010 X EISDIR
0x000F X EOVERFLOW
0x000E X ENODEV
0x000D X EBADF
0x000C X ENFILE
0x000B X ENODRV
0x000A X ENXIO
0x0009 X ENOSPC
0x0008 X EACCES
0x0007 X EINVAL
0x0006 X EIO
0x0005 X ENOENT
0x0004 X EWRTYPE
0x0003 X ESTEND
0x0002 X ENONSENSE
0x0001 X EOK
0x002A   CUR_DRIVE
0x0010   A_DIR
0x00E7 X A_ALL
0x0040 X A_EXEC
0x0020 X A_ARCH
0x0004   A_SYSTEM
0x0002   A_HIDDEN
0x0081 X A_RDWR
0x0080 X A_READ
0x0001 X A_WRITE
0x0E00   NMI_SIZE
0x2F00   NMI_OVERLAY
0x0024   SYS_DRIVE
0x0040 X FA_USE_HEADER
0x000C   FA_CREATE_AL
0x0004   FA_CREATE_NEW
0x0008   FA_OPEN_AL
0x0000   FA_OPEN_EX
0x0002   FA_WRITE
0x0001   FA_READ
0x00B1 X F_GETFREE
0x00B0   F_RENAME
0x00AF X F_CHMOD
0x00AE X F_TRUNCATE
0x00AD   F_UNLINK
0x00AC X F_STAT
0x00AB X F_RMDIR
0x00AA X F_MKDIR
0x00A9   F_CHDIR
0x00A8   F_GETCWD
0x00A7   F_REWINDDIR
0x00A6   F_SEEKDIR
0x00A5   F_TELLDIR
0x00A4   F_READDIR
0x00A3   F_OPENDIR
0x00A2 X F_FTRUNCATE
0x00A1 X F_FSTAT
0x00A0 X F_FGETPOS
0x009F   F_SEEK
0x009E   F_WRITE
0x009D   F_READ
0x009C X F_SYNC
0x009B   F_CLOSE
0x009A   F_OPEN
0x0099 X F_UMOUNT
0x0098 X F_MOUNT
0x0090   M_AUTOLOAD
0x008F   M_EXECCMD
0x008E X M_GETDATE
0x008D X M_GETHANDLE
0x008C   M_TAPEOUT
0x008B   M_TAPEIN
0x008A X M_DRIVEINFO
0x0089   M_GETSETDRV
0x0088 X M_DOSVERSION
0x3484   page5.msgDetOut
0x0084 X DISK_INFO
0x0083 X DISK_IOCTL
0x0082 X DISK_WRITE
0x0081 X DISK_READ
0x0080   DISK_STATUS
0x0098   FSYS_BASE
0x0088   MISC_BASE
0x0080   HOOK_BASE
0x0057   COL_ERR
0x004F   COL_CUR
0x0038   COL_BOT
0x0038   COL_TOP
0x0007   COL_MID
0x001E   K_CS_ENTER
0x001D   K_SS_ENTER
0x001C   K_BREAK
0x00D5   K_MERGE
0x00CC   K_TO
0x00AC   K_AT
0x000D   K_ENTER
0x000C   K_DELETE
0x000B   K_UP
0x000A   K_DOWN
0x0009   K_RIGHT
0x235E   page6.cvtUpperNibble
0x0008   K_LEFT
0x0007   K_EDIT
0x0080 X FLASH
0x0040   BRIGHT
0x0007   WHITE
0x0006 X YELLOW
0x0005 X CYAN
0x0004 X GREEN
0x0003 X MAGENTA
0x0002   RED
0x0001   BLUE
0x0000   BLACK
0x02B5 X SIZ_OVR
0x0898   MAXENTR
0x5B00   BACKED_UP_RAM
0x5C00   NMI_STACK
0x3DF9   RAM_PAGE
0x1C00   PAGE_LENGTH
0x2000   PAGE_START
